"""
# `kubernetes_daemon_set_v1`

Refer to the Terraform Registory for docs: [`kubernetes_daemon_set_v1`](https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1).
"""
import abc
import builtins
import datetime
import enum
import typing

import cdktf as _cdktf_9a9027ec
import constructs as _constructs_77d1e7e8
import jsii
import publication
import typing_extensions
from typeguard import check_type

from .._jsii import *


class DaemonSetV1(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1",
):
    """Represents a {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1 kubernetes_daemon_set_v1}."""

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id_: builtins.str,
        *,
        metadata: typing.Union[
            "DaemonSetV1Metadata", typing.Dict[builtins.str, typing.Any]
        ],
        spec: typing.Union["DaemonSetV1Spec", typing.Dict[builtins.str, typing.Any]],
        id: typing.Optional[builtins.str] = None,
        timeouts: typing.Optional[
            typing.Union["DaemonSetV1Timeouts", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        wait_for_rollout: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        connection: typing.Optional[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.SSHProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.WinrmProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ] = None,
        count: typing.Optional[
            typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
        ] = None,
        depends_on: typing.Optional[
            typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
        ] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.TerraformResourceLifecycle,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[
            typing.Sequence[
                typing.Union[
                    typing.Union[
                        _cdktf_9a9027ec.FileProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.LocalExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.RemoteExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                ]
            ]
        ] = None,
    ) -> None:
        """Create a new {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1 kubernetes_daemon_set_v1} Resource.

        :param scope: The scope in which to define this construct.
        :param id_: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param metadata: metadata block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#metadata DaemonSetV1#metadata}
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#spec DaemonSetV1#spec}
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#id DaemonSetV1#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeouts DaemonSetV1#timeouts}
        :param wait_for_rollout: Wait for the rollout of the deployment to complete. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#wait_for_rollout DaemonSetV1#wait_for_rollout}
        :param connection:
        :param count:
        :param depends_on:
        :param for_each:
        :param lifecycle:
        :param provider:
        :param provisioners:
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bdf87e882aaaa889ed81b3c02ee15493ec662875fa634d633e3b2349d5f0500b
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument id_", value=id_, expected_type=type_hints["id_"]
            )
        config = DaemonSetV1Config(
            metadata=metadata,
            spec=spec,
            id=id,
            timeouts=timeouts,
            wait_for_rollout=wait_for_rollout,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id_, config])

    @jsii.member(jsii_name="putMetadata")
    def put_metadata(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        generate_name: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param annotations: An unstructured key value map stored with the daemonset that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#annotations DaemonSetV1#annotations}
        :param generate_name: Prefix, used by the server, to generate a unique name ONLY IF the ``name`` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#generate_name DaemonSetV1#generate_name}
        :param labels: Map of string keys and values that can be used to organize and categorize (scope and select) the daemonset. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#labels DaemonSetV1#labels}
        :param name: Name of the daemonset, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Namespace defines the space within which name of the daemonset must be unique. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        value = DaemonSetV1Metadata(
            annotations=annotations,
            generate_name=generate_name,
            labels=labels,
            name=name,
            namespace=namespace,
        )

        return typing.cast(None, jsii.invoke(self, "putMetadata", [value]))

    @jsii.member(jsii_name="putSpec")
    def put_spec(
        self,
        *,
        template: typing.Union[
            "DaemonSetV1SpecTemplate", typing.Dict[builtins.str, typing.Any]
        ],
        min_ready_seconds: typing.Optional[jsii.Number] = None,
        revision_history_limit: typing.Optional[jsii.Number] = None,
        selector: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecSelector", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        strategy: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecStrategy", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
    ) -> None:
        """
        :param template: template block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#template DaemonSetV1#template}
        :param min_ready_seconds: Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#min_ready_seconds DaemonSetV1#min_ready_seconds}
        :param revision_history_limit: The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#revision_history_limit DaemonSetV1#revision_history_limit}
        :param selector: selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#selector DaemonSetV1#selector}
        :param strategy: strategy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#strategy DaemonSetV1#strategy}
        """
        value = DaemonSetV1Spec(
            template=template,
            min_ready_seconds=min_ready_seconds,
            revision_history_limit=revision_history_limit,
            selector=selector,
            strategy=strategy,
        )

        return typing.cast(None, jsii.invoke(self, "putSpec", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#create DaemonSetV1#create}.
        :param delete: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#delete DaemonSetV1#delete}.
        :param update: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#update DaemonSetV1#update}.
        """
        value = DaemonSetV1Timeouts(create=create, delete=delete, update=update)

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetId")
    def reset_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetId", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="resetWaitForRollout")
    def reset_wait_for_rollout(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWaitForRollout", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(
            typing.Mapping[builtins.str, typing.Any],
            jsii.invoke(self, "synthesizeAttributes", []),
        )

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(self) -> "DaemonSetV1MetadataOutputReference":
        return typing.cast(
            "DaemonSetV1MetadataOutputReference", jsii.get(self, "metadata")
        )

    @builtins.property
    @jsii.member(jsii_name="spec")
    def spec(self) -> "DaemonSetV1SpecOutputReference":
        return typing.cast("DaemonSetV1SpecOutputReference", jsii.get(self, "spec"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "DaemonSetV1TimeoutsOutputReference":
        return typing.cast(
            "DaemonSetV1TimeoutsOutputReference", jsii.get(self, "timeouts")
        )

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="metadataInput")
    def metadata_input(self) -> typing.Optional["DaemonSetV1Metadata"]:
        return typing.cast(
            typing.Optional["DaemonSetV1Metadata"], jsii.get(self, "metadataInput")
        )

    @builtins.property
    @jsii.member(jsii_name="specInput")
    def spec_input(self) -> typing.Optional["DaemonSetV1Spec"]:
        return typing.cast(
            typing.Optional["DaemonSetV1Spec"], jsii.get(self, "specInput")
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, "DaemonSetV1Timeouts"]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, "DaemonSetV1Timeouts"]
            ],
            jsii.get(self, "timeoutsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="waitForRolloutInput")
    def wait_for_rollout_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "waitForRolloutInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f57d7ec1e461b521aff4fd5c09fcd6b18a42142458c99092f59884959735d161
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "id", value)

    @builtins.property
    @jsii.member(jsii_name="waitForRollout")
    def wait_for_rollout(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "waitForRollout"),
        )

    @wait_for_rollout.setter
    def wait_for_rollout(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cdbaa0bd30250376303dc754a961dd4c57407e9e61007cc3125e1ea35db179d2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "waitForRollout", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1Config",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "metadata": "metadata",
        "spec": "spec",
        "id": "id",
        "timeouts": "timeouts",
        "wait_for_rollout": "waitForRollout",
    },
)
class DaemonSetV1Config(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.SSHProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.WinrmProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ] = None,
        count: typing.Optional[
            typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
        ] = None,
        depends_on: typing.Optional[
            typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
        ] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.TerraformResourceLifecycle,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[
            typing.Sequence[
                typing.Union[
                    typing.Union[
                        _cdktf_9a9027ec.FileProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.LocalExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.RemoteExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                ]
            ]
        ] = None,
        metadata: typing.Union[
            "DaemonSetV1Metadata", typing.Dict[builtins.str, typing.Any]
        ],
        spec: typing.Union["DaemonSetV1Spec", typing.Dict[builtins.str, typing.Any]],
        id: typing.Optional[builtins.str] = None,
        timeouts: typing.Optional[
            typing.Union["DaemonSetV1Timeouts", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        wait_for_rollout: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param connection:
        :param count:
        :param depends_on:
        :param for_each:
        :param lifecycle:
        :param provider:
        :param provisioners:
        :param metadata: metadata block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#metadata DaemonSetV1#metadata}
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#spec DaemonSetV1#spec}
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#id DaemonSetV1#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeouts DaemonSetV1#timeouts}
        :param wait_for_rollout: Wait for the rollout of the deployment to complete. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#wait_for_rollout DaemonSetV1#wait_for_rollout}
        """
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(metadata, dict):
            metadata = DaemonSetV1Metadata(**metadata)
        if isinstance(spec, dict):
            spec = DaemonSetV1Spec(**spec)
        if isinstance(timeouts, dict):
            timeouts = DaemonSetV1Timeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__27a15e0e156c16ea0494d9083f085edd123c5c3e0c12573c5e36803ba559947b
            )
            check_type(
                argname="argument connection",
                value=connection,
                expected_type=type_hints["connection"],
            )
            check_type(
                argname="argument count", value=count, expected_type=type_hints["count"]
            )
            check_type(
                argname="argument depends_on",
                value=depends_on,
                expected_type=type_hints["depends_on"],
            )
            check_type(
                argname="argument for_each",
                value=for_each,
                expected_type=type_hints["for_each"],
            )
            check_type(
                argname="argument lifecycle",
                value=lifecycle,
                expected_type=type_hints["lifecycle"],
            )
            check_type(
                argname="argument provider",
                value=provider,
                expected_type=type_hints["provider"],
            )
            check_type(
                argname="argument provisioners",
                value=provisioners,
                expected_type=type_hints["provisioners"],
            )
            check_type(
                argname="argument metadata",
                value=metadata,
                expected_type=type_hints["metadata"],
            )
            check_type(
                argname="argument spec", value=spec, expected_type=type_hints["spec"]
            )
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(
                argname="argument timeouts",
                value=timeouts,
                expected_type=type_hints["timeouts"],
            )
            check_type(
                argname="argument wait_for_rollout",
                value=wait_for_rollout,
                expected_type=type_hints["wait_for_rollout"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "metadata": metadata,
            "spec": spec,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if id is not None:
            self._values["id"] = id
        if timeouts is not None:
            self._values["timeouts"] = timeouts
        if wait_for_rollout is not None:
            self._values["wait_for_rollout"] = wait_for_rollout

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.SSHProvisionerConnection,
            _cdktf_9a9027ec.WinrmProvisionerConnection,
        ]
    ]:
        """
        :stability: experimental
        """
        result = self._values.get("connection")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.SSHProvisionerConnection,
                    _cdktf_9a9027ec.WinrmProvisionerConnection,
                ]
            ],
            result,
        )

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        """
        :stability: experimental
        """
        result = self._values.get("count")
        return typing.cast(
            typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]],
            result,
        )

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        """
        :stability: experimental
        """
        result = self._values.get("depends_on")
        return typing.cast(
            typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result
        )

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        """
        :stability: experimental
        """
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        """
        :stability: experimental
        """
        result = self._values.get("lifecycle")
        return typing.cast(
            typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result
        )

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        """
        :stability: experimental
        """
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[
        typing.List[
            typing.Union[
                _cdktf_9a9027ec.FileProvisioner,
                _cdktf_9a9027ec.LocalExecProvisioner,
                _cdktf_9a9027ec.RemoteExecProvisioner,
            ]
        ]
    ]:
        """
        :stability: experimental
        """
        result = self._values.get("provisioners")
        return typing.cast(
            typing.Optional[
                typing.List[
                    typing.Union[
                        _cdktf_9a9027ec.FileProvisioner,
                        _cdktf_9a9027ec.LocalExecProvisioner,
                        _cdktf_9a9027ec.RemoteExecProvisioner,
                    ]
                ]
            ],
            result,
        )

    @builtins.property
    def metadata(self) -> "DaemonSetV1Metadata":
        """metadata block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#metadata DaemonSetV1#metadata}
        """
        result = self._values.get("metadata")
        assert result is not None, "Required property 'metadata' is missing"
        return typing.cast("DaemonSetV1Metadata", result)

    @builtins.property
    def spec(self) -> "DaemonSetV1Spec":
        """spec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#spec DaemonSetV1#spec}
        """
        result = self._values.get("spec")
        assert result is not None, "Required property 'spec' is missing"
        return typing.cast("DaemonSetV1Spec", result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#id DaemonSetV1#id}.

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        """
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["DaemonSetV1Timeouts"]:
        """timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeouts DaemonSetV1#timeouts}
        """
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["DaemonSetV1Timeouts"], result)

    @builtins.property
    def wait_for_rollout(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Wait for the rollout of the deployment to complete. Defaults to true.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#wait_for_rollout DaemonSetV1#wait_for_rollout}
        """
        result = self._values.get("wait_for_rollout")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1Config(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1Metadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "generate_name": "generateName",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class DaemonSetV1Metadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        generate_name: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param annotations: An unstructured key value map stored with the daemonset that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#annotations DaemonSetV1#annotations}
        :param generate_name: Prefix, used by the server, to generate a unique name ONLY IF the ``name`` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#generate_name DaemonSetV1#generate_name}
        :param labels: Map of string keys and values that can be used to organize and categorize (scope and select) the daemonset. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#labels DaemonSetV1#labels}
        :param name: Name of the daemonset, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Namespace defines the space within which name of the daemonset must be unique. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2cd343ae86f2ef126cd6894822726942c4d49d197a63dacfc9d86d7a53427944
            )
            check_type(
                argname="argument annotations",
                value=annotations,
                expected_type=type_hints["annotations"],
            )
            check_type(
                argname="argument generate_name",
                value=generate_name,
                expected_type=type_hints["generate_name"],
            )
            check_type(
                argname="argument labels",
                value=labels,
                expected_type=type_hints["labels"],
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument namespace",
                value=namespace,
                expected_type=type_hints["namespace"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if generate_name is not None:
            self._values["generate_name"] = generate_name
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """An unstructured key value map stored with the daemonset that may be used to store arbitrary metadata.

        More info: http://kubernetes.io/docs/user-guide/annotations

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#annotations DaemonSetV1#annotations}
        """
        result = self._values.get("annotations")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def generate_name(self) -> typing.Optional[builtins.str]:
        """Prefix, used by the server, to generate a unique name ONLY IF the ``name`` field has not been provided.

        This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#generate_name DaemonSetV1#generate_name}
        """
        result = self._values.get("generate_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Map of string keys and values that can be used to organize and categorize (scope and select) the daemonset.

        May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#labels DaemonSetV1#labels}
        """
        result = self._values.get("labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the daemonset, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        """Namespace defines the space within which name of the daemonset must be unique.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1Metadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1MetadataOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1MetadataOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d3006c862f51f00f5be736fbaf88b09d5b04133e095dab79579f25a59df48e3f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAnnotations")
    def reset_annotations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAnnotations", []))

    @jsii.member(jsii_name="resetGenerateName")
    def reset_generate_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGenerateName", []))

    @jsii.member(jsii_name="resetLabels")
    def reset_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabels", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetNamespace")
    def reset_namespace(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespace", []))

    @builtins.property
    @jsii.member(jsii_name="generation")
    def generation(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "generation"))

    @builtins.property
    @jsii.member(jsii_name="resourceVersion")
    def resource_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceVersion"))

    @builtins.property
    @jsii.member(jsii_name="uid")
    def uid(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "uid"))

    @builtins.property
    @jsii.member(jsii_name="annotationsInput")
    def annotations_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "annotationsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="generateNameInput")
    def generate_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "generateNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="labelsInput")
    def labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "labelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="namespaceInput")
    def namespace_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "namespaceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="annotations")
    def annotations(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "annotations")
        )

    @annotations.setter
    def annotations(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56c9de6f2b67d52bf391e8e64aa83a10635505e263a604db111d439c605045d9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "annotations", value)

    @builtins.property
    @jsii.member(jsii_name="generateName")
    def generate_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "generateName"))

    @generate_name.setter
    def generate_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__799d57cdc71719e6f8bb0e1a2e63ff2792e18dc179098a8f95d11e13936d080b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "generateName", value)

    @builtins.property
    @jsii.member(jsii_name="labels")
    def labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "labels")
        )

    @labels.setter
    def labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__02fc12f399b252957b53537bd9d9044732df65508c3703fdd10f0d2da2556f0f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "labels", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__001f63b2aa37fb24edde93bacfc790c9b659d90b6631480cfc5656d976da98a7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @namespace.setter
    def namespace(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b04d34e9b39a99f0854e0ab065a51ef0700f6566cdf8b378dd99f5e239bd436
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespace", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1Metadata]:
        return typing.cast(
            typing.Optional[DaemonSetV1Metadata], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[DaemonSetV1Metadata]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f648822835c7ab315a5a9682227b536e8e85b99614e6c097d40476292d4b4c1c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1Spec",
    jsii_struct_bases=[],
    name_mapping={
        "template": "template",
        "min_ready_seconds": "minReadySeconds",
        "revision_history_limit": "revisionHistoryLimit",
        "selector": "selector",
        "strategy": "strategy",
    },
)
class DaemonSetV1Spec:
    def __init__(
        self,
        *,
        template: typing.Union[
            "DaemonSetV1SpecTemplate", typing.Dict[builtins.str, typing.Any]
        ],
        min_ready_seconds: typing.Optional[jsii.Number] = None,
        revision_history_limit: typing.Optional[jsii.Number] = None,
        selector: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecSelector", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        strategy: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecStrategy", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
    ) -> None:
        """
        :param template: template block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#template DaemonSetV1#template}
        :param min_ready_seconds: Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#min_ready_seconds DaemonSetV1#min_ready_seconds}
        :param revision_history_limit: The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#revision_history_limit DaemonSetV1#revision_history_limit}
        :param selector: selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#selector DaemonSetV1#selector}
        :param strategy: strategy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#strategy DaemonSetV1#strategy}
        """
        if isinstance(template, dict):
            template = DaemonSetV1SpecTemplate(**template)
        if isinstance(selector, dict):
            selector = DaemonSetV1SpecSelector(**selector)
        if isinstance(strategy, dict):
            strategy = DaemonSetV1SpecStrategy(**strategy)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2c2dd4db9b50ecedebab6ce23ba29de842ed2ee4233f3cd99c36d98a428c0502
            )
            check_type(
                argname="argument template",
                value=template,
                expected_type=type_hints["template"],
            )
            check_type(
                argname="argument min_ready_seconds",
                value=min_ready_seconds,
                expected_type=type_hints["min_ready_seconds"],
            )
            check_type(
                argname="argument revision_history_limit",
                value=revision_history_limit,
                expected_type=type_hints["revision_history_limit"],
            )
            check_type(
                argname="argument selector",
                value=selector,
                expected_type=type_hints["selector"],
            )
            check_type(
                argname="argument strategy",
                value=strategy,
                expected_type=type_hints["strategy"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "template": template,
        }
        if min_ready_seconds is not None:
            self._values["min_ready_seconds"] = min_ready_seconds
        if revision_history_limit is not None:
            self._values["revision_history_limit"] = revision_history_limit
        if selector is not None:
            self._values["selector"] = selector
        if strategy is not None:
            self._values["strategy"] = strategy

    @builtins.property
    def template(self) -> "DaemonSetV1SpecTemplate":
        """template block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#template DaemonSetV1#template}
        """
        result = self._values.get("template")
        assert result is not None, "Required property 'template' is missing"
        return typing.cast("DaemonSetV1SpecTemplate", result)

    @builtins.property
    def min_ready_seconds(self) -> typing.Optional[jsii.Number]:
        """Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available.

        Defaults to 0 (pod will be considered available as soon as it is ready)

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#min_ready_seconds DaemonSetV1#min_ready_seconds}
        """
        result = self._values.get("min_ready_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def revision_history_limit(self) -> typing.Optional[jsii.Number]:
        """The number of old ReplicaSets to retain to allow rollback.

        This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#revision_history_limit DaemonSetV1#revision_history_limit}
        """
        result = self._values.get("revision_history_limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def selector(self) -> typing.Optional["DaemonSetV1SpecSelector"]:
        """selector block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#selector DaemonSetV1#selector}
        """
        result = self._values.get("selector")
        return typing.cast(typing.Optional["DaemonSetV1SpecSelector"], result)

    @builtins.property
    def strategy(self) -> typing.Optional["DaemonSetV1SpecStrategy"]:
        """strategy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#strategy DaemonSetV1#strategy}
        """
        result = self._values.get("strategy")
        return typing.cast(typing.Optional["DaemonSetV1SpecStrategy"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__86d4d2de0194aae4a8ff9ddd7ef5bc1bba9584146be0c624893e025948c781db
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSelector")
    def put_selector(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecSelectorMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        match_labels: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        :param match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        value = DaemonSetV1SpecSelector(
            match_expressions=match_expressions, match_labels=match_labels
        )

        return typing.cast(None, jsii.invoke(self, "putSelector", [value]))

    @jsii.member(jsii_name="putStrategy")
    def put_strategy(
        self,
        *,
        rolling_update: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecStrategyRollingUpdate",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param rolling_update: rolling_update block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rolling_update DaemonSetV1#rolling_update}
        :param type: Type of deployment. Can be 'RollingUpdate' or 'OnDelete'. Default is RollingUpdate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        value = DaemonSetV1SpecStrategy(rolling_update=rolling_update, type=type)

        return typing.cast(None, jsii.invoke(self, "putStrategy", [value]))

    @jsii.member(jsii_name="putTemplate")
    def put_template(
        self,
        *,
        metadata: typing.Union[
            "DaemonSetV1SpecTemplateMetadata", typing.Dict[builtins.str, typing.Any]
        ],
        spec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpec", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
    ) -> None:
        """
        :param metadata: metadata block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#metadata DaemonSetV1#metadata}
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#spec DaemonSetV1#spec}
        """
        value = DaemonSetV1SpecTemplate(metadata=metadata, spec=spec)

        return typing.cast(None, jsii.invoke(self, "putTemplate", [value]))

    @jsii.member(jsii_name="resetMinReadySeconds")
    def reset_min_ready_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinReadySeconds", []))

    @jsii.member(jsii_name="resetRevisionHistoryLimit")
    def reset_revision_history_limit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRevisionHistoryLimit", []))

    @jsii.member(jsii_name="resetSelector")
    def reset_selector(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSelector", []))

    @jsii.member(jsii_name="resetStrategy")
    def reset_strategy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStrategy", []))

    @builtins.property
    @jsii.member(jsii_name="selector")
    def selector(self) -> "DaemonSetV1SpecSelectorOutputReference":
        return typing.cast(
            "DaemonSetV1SpecSelectorOutputReference", jsii.get(self, "selector")
        )

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def strategy(self) -> "DaemonSetV1SpecStrategyOutputReference":
        return typing.cast(
            "DaemonSetV1SpecStrategyOutputReference", jsii.get(self, "strategy")
        )

    @builtins.property
    @jsii.member(jsii_name="template")
    def template(self) -> "DaemonSetV1SpecTemplateOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateOutputReference", jsii.get(self, "template")
        )

    @builtins.property
    @jsii.member(jsii_name="minReadySecondsInput")
    def min_ready_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "minReadySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="revisionHistoryLimitInput")
    def revision_history_limit_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "revisionHistoryLimitInput")
        )

    @builtins.property
    @jsii.member(jsii_name="selectorInput")
    def selector_input(self) -> typing.Optional["DaemonSetV1SpecSelector"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecSelector"], jsii.get(self, "selectorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="strategyInput")
    def strategy_input(self) -> typing.Optional["DaemonSetV1SpecStrategy"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecStrategy"], jsii.get(self, "strategyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="templateInput")
    def template_input(self) -> typing.Optional["DaemonSetV1SpecTemplate"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplate"], jsii.get(self, "templateInput")
        )

    @builtins.property
    @jsii.member(jsii_name="minReadySeconds")
    def min_ready_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "minReadySeconds"))

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__10aa235c91906686100bf3f8b5102aa125326a6698aaf5080fb50bcc8621a2e1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "minReadySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="revisionHistoryLimit")
    def revision_history_limit(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "revisionHistoryLimit"))

    @revision_history_limit.setter
    def revision_history_limit(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__86a07c848ccbac09a945c431d80b89363330f95231993ef8ba78da1286acae0d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "revisionHistoryLimit", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1Spec]:
        return typing.cast(
            typing.Optional[DaemonSetV1Spec], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[DaemonSetV1Spec]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__da90b63f635d949178d81d73584ac7c8e321304dba0d80fda0f1b1f7b761f381
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class DaemonSetV1SpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecSelectorMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        match_labels: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        :param match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c116c58e5d3eceda218a1bcd212f898078b47802578066c4a78be800cf4ea389
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
            check_type(
                argname="argument match_labels",
                value=match_labels,
                expected_type=type_hints["match_labels"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecSelectorMatchExpressions"],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecSelectorMatchExpressions"],
                ]
            ],
            result,
        )

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """A map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        result = self._values.get("match_labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: An array of string values. If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fdd9effe98b473b7e97434ed037b29f4a282c74613198175621a400d43fd315a
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """An array of string values.

        If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecSelectorMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecSelectorMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8a4fccae171fd98ab7d332172561725b53f05f921e827f4da730de4d7ede8ec4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecSelectorMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6c17479f21754a2f1cd57e56578a5124e52224d394d1ede5d7c8fc17e476a670
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecSelectorMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__491e7030b2eb8a6d3e98179a9cd3d041b3aa446f483c2c705d47f13a3b1d9934
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ede15fcac64afda970f9a193ae132b7dd442712b96f00aedf784cff0f9d1c0e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e662d92ee894672d217c81e2e96e8b9c833c9063d4ae2789e3a9f1d1d75c45f7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecSelectorMatchExpressions],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecSelectorMatchExpressions],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecSelectorMatchExpressions],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fdcd686d680226aab1e9ee8e37b3395412f105c692a832577343837a5838415e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecSelectorMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecSelectorMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1e6f1056578f3597e9acff6bb3fd86bee090ba620dd6c716ea8ec4969256f418
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6a22b1c83597a33ec4a0a4576efc0c34ec368f82b8db8feeb12830ef15a2fcc3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e2ef5d6446f963185b6265976d16fe223a4ade49b8bad36553babda7a93c71ab
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4db8fc3e55a3e99f1908f7e80520dbe05ae62b673840a1933efe498114274970
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecSelectorMatchExpressions
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecSelectorMatchExpressions
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecSelectorMatchExpressions
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c76841c53090df1b6f2ee1c3288f1fa279bdff14449f2063209c63e887825a3f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecSelectorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecSelectorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47a50c816db5b1d20bc76f873abe7b134d0414a1245a55570d082ede4a3ef050
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47856dc44ab561f53624c8269ad53effcee81bfb215df6d8ac06e7c4923f0537
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @jsii.member(jsii_name="resetMatchLabels")
    def reset_match_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchLabels", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(self) -> DaemonSetV1SpecSelectorMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecSelectorMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecSelectorMatchExpressions],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecSelectorMatchExpressions],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabelsInput")
    def match_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "matchLabelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabels")
    def match_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "matchLabels")
        )

    @match_labels.setter
    def match_labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__48ba1a8038e995570d4174d459d90e6822435039031e832e963c77a0af417a5b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "matchLabels", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecSelector]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecSelector], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[DaemonSetV1SpecSelector]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2e6a2f6e14d72230fc6a056f6edd404ee4791ec6bdc885d6575529197aacaf3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecStrategy",
    jsii_struct_bases=[],
    name_mapping={"rolling_update": "rollingUpdate", "type": "type"},
)
class DaemonSetV1SpecStrategy:
    def __init__(
        self,
        *,
        rolling_update: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecStrategyRollingUpdate",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param rolling_update: rolling_update block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rolling_update DaemonSetV1#rolling_update}
        :param type: Type of deployment. Can be 'RollingUpdate' or 'OnDelete'. Default is RollingUpdate. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        if isinstance(rolling_update, dict):
            rolling_update = DaemonSetV1SpecStrategyRollingUpdate(**rolling_update)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7ddfafbc99809b8986501c897d7d83096d14fe82d8ebe5c7d025eb2922392b27
            )
            check_type(
                argname="argument rolling_update",
                value=rolling_update,
                expected_type=type_hints["rolling_update"],
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rolling_update is not None:
            self._values["rolling_update"] = rolling_update
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def rolling_update(self) -> typing.Optional["DaemonSetV1SpecStrategyRollingUpdate"]:
        """rolling_update block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rolling_update DaemonSetV1#rolling_update}
        """
        result = self._values.get("rolling_update")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecStrategyRollingUpdate"], result
        )

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type of deployment. Can be 'RollingUpdate' or 'OnDelete'. Default is RollingUpdate.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecStrategy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecStrategyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecStrategyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7af34dabe55b2deb8e3437395fb3bc93740d16ff61307c34ee69347f3c2f3789
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putRollingUpdate")
    def put_rolling_update(
        self,
        *,
        max_unavailable: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param max_unavailable: The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#max_unavailable DaemonSetV1#max_unavailable}
        """
        value = DaemonSetV1SpecStrategyRollingUpdate(max_unavailable=max_unavailable)

        return typing.cast(None, jsii.invoke(self, "putRollingUpdate", [value]))

    @jsii.member(jsii_name="resetRollingUpdate")
    def reset_rolling_update(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRollingUpdate", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="rollingUpdate")
    def rolling_update(self) -> "DaemonSetV1SpecStrategyRollingUpdateOutputReference":
        return typing.cast(
            "DaemonSetV1SpecStrategyRollingUpdateOutputReference",
            jsii.get(self, "rollingUpdate"),
        )

    @builtins.property
    @jsii.member(jsii_name="rollingUpdateInput")
    def rolling_update_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecStrategyRollingUpdate"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecStrategyRollingUpdate"],
            jsii.get(self, "rollingUpdateInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__06492ccabcfd4c7091d0e3d3bb777ee68217fcebc6ddfa151e4bc9b30306e095
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecStrategy]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecStrategy], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[DaemonSetV1SpecStrategy]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b7f9a16b03863bc4b0dbcf6df9cb8d551cd42e707dd6a1354b9d572f3f278038
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecStrategyRollingUpdate",
    jsii_struct_bases=[],
    name_mapping={"max_unavailable": "maxUnavailable"},
)
class DaemonSetV1SpecStrategyRollingUpdate:
    def __init__(
        self,
        *,
        max_unavailable: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param max_unavailable: The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#max_unavailable DaemonSetV1#max_unavailable}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ddc69aa1277d9351d9eff2b09a3f53a01350eb37770b3f131756acf510543bdf
            )
            check_type(
                argname="argument max_unavailable",
                value=max_unavailable,
                expected_type=type_hints["max_unavailable"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_unavailable is not None:
            self._values["max_unavailable"] = max_unavailable

    @builtins.property
    def max_unavailable(self) -> typing.Optional[builtins.str]:
        """The maximum number of DaemonSet pods that can be unavailable during the update.

        Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#max_unavailable DaemonSetV1#max_unavailable}
        """
        result = self._values.get("max_unavailable")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecStrategyRollingUpdate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecStrategyRollingUpdateOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecStrategyRollingUpdateOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba460bb4d7a5523b6cb4eb44ddf0743eebcc204eaabe23a1b11abe78dfbd3b5c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetMaxUnavailable")
    def reset_max_unavailable(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxUnavailable", []))

    @builtins.property
    @jsii.member(jsii_name="maxUnavailableInput")
    def max_unavailable_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "maxUnavailableInput")
        )

    @builtins.property
    @jsii.member(jsii_name="maxUnavailable")
    def max_unavailable(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxUnavailable"))

    @max_unavailable.setter
    def max_unavailable(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c2ad9ee8faef2b7a1ecfd91e330487b6fddf45fe58a21520ed88a0cbd528b9d1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "maxUnavailable", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecStrategyRollingUpdate]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecStrategyRollingUpdate],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecStrategyRollingUpdate],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1dbc73c86c074e380c680808d11cc951abae384e64af62f79734267c7a111682
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplate",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class DaemonSetV1SpecTemplate:
    def __init__(
        self,
        *,
        metadata: typing.Union[
            "DaemonSetV1SpecTemplateMetadata", typing.Dict[builtins.str, typing.Any]
        ],
        spec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpec", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
    ) -> None:
        """
        :param metadata: metadata block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#metadata DaemonSetV1#metadata}
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#spec DaemonSetV1#spec}
        """
        if isinstance(metadata, dict):
            metadata = DaemonSetV1SpecTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = DaemonSetV1SpecTemplateSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e404f94331ac675682095a83814e96690c6e9649b84cf9639bdd38f4ba490e97
            )
            check_type(
                argname="argument metadata",
                value=metadata,
                expected_type=type_hints["metadata"],
            )
            check_type(
                argname="argument spec", value=spec, expected_type=type_hints["spec"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "metadata": metadata,
        }
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> "DaemonSetV1SpecTemplateMetadata":
        """metadata block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#metadata DaemonSetV1#metadata}
        """
        result = self._values.get("metadata")
        assert result is not None, "Required property 'metadata' is missing"
        return typing.cast("DaemonSetV1SpecTemplateMetadata", result)

    @builtins.property
    def spec(self) -> typing.Optional["DaemonSetV1SpecTemplateSpec"]:
        """spec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#spec DaemonSetV1#spec}
        """
        result = self._values.get("spec")
        return typing.cast(typing.Optional["DaemonSetV1SpecTemplateSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "generate_name": "generateName",
        "labels": "labels",
        "name": "name",
    },
)
class DaemonSetV1SpecTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        generate_name: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param annotations: An unstructured key value map stored with the daemon set that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#annotations DaemonSetV1#annotations}
        :param generate_name: Prefix, used by the server, to generate a unique name ONLY IF the ``name`` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#generate_name DaemonSetV1#generate_name}
        :param labels: Map of string keys and values that can be used to organize and categorize (scope and select) the daemon set. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#labels DaemonSetV1#labels}
        :param name: Name of the daemon set, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__be5a863dd417d1b5880bffcd7ecd5fd851dcdad7f8af2c78d0573337343a14a0
            )
            check_type(
                argname="argument annotations",
                value=annotations,
                expected_type=type_hints["annotations"],
            )
            check_type(
                argname="argument generate_name",
                value=generate_name,
                expected_type=type_hints["generate_name"],
            )
            check_type(
                argname="argument labels",
                value=labels,
                expected_type=type_hints["labels"],
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if generate_name is not None:
            self._values["generate_name"] = generate_name
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """An unstructured key value map stored with the daemon set that may be used to store arbitrary metadata.

        More info: http://kubernetes.io/docs/user-guide/annotations

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#annotations DaemonSetV1#annotations}
        """
        result = self._values.get("annotations")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def generate_name(self) -> typing.Optional[builtins.str]:
        """Prefix, used by the server, to generate a unique name ONLY IF the ``name`` field has not been provided.

        This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#generate_name DaemonSetV1#generate_name}
        """
        result = self._values.get("generate_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Map of string keys and values that can be used to organize and categorize (scope and select) the daemon set.

        May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#labels DaemonSetV1#labels}
        """
        result = self._values.get("labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the daemon set, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateMetadataOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateMetadataOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__75a23c8967a668a796b8621a35975e105fe7e2ebde913f3751fd1c9321b22059
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAnnotations")
    def reset_annotations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAnnotations", []))

    @jsii.member(jsii_name="resetGenerateName")
    def reset_generate_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGenerateName", []))

    @jsii.member(jsii_name="resetLabels")
    def reset_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabels", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @builtins.property
    @jsii.member(jsii_name="generation")
    def generation(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "generation"))

    @builtins.property
    @jsii.member(jsii_name="resourceVersion")
    def resource_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceVersion"))

    @builtins.property
    @jsii.member(jsii_name="uid")
    def uid(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "uid"))

    @builtins.property
    @jsii.member(jsii_name="annotationsInput")
    def annotations_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "annotationsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="generateNameInput")
    def generate_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "generateNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="labelsInput")
    def labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "labelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="annotations")
    def annotations(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "annotations")
        )

    @annotations.setter
    def annotations(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c08697ee1e2d8c356e9f4ddd913e601e0bafcab0f5df58ac6e487fdaf22a8eb7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "annotations", value)

    @builtins.property
    @jsii.member(jsii_name="generateName")
    def generate_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "generateName"))

    @generate_name.setter
    def generate_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0a8da97cc57054b85fbe1d71bbe6f6cb2d5af910471e58980c6cbbd44b890c9f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "generateName", value)

    @builtins.property
    @jsii.member(jsii_name="labels")
    def labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "labels")
        )

    @labels.setter
    def labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__84358d7e0032c504f9b174d1785a1c2f82a7fa403483877060cb084f064a9265
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "labels", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aa06747850d7f48e2ebdcd3095169e7ab584cdc011991c9d50a04b2ea7a12bab
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateMetadata]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateMetadata],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateMetadata],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f08c09315c1a3e706b10adf0c5cdb94b4e7c503e75587a5ac01c275c4b4cd72
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0931e46a1acd1b6f1a2543b8d315a5f806b98fa1e0e62f66e938bb968261543a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putMetadata")
    def put_metadata(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        generate_name: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param annotations: An unstructured key value map stored with the daemon set that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#annotations DaemonSetV1#annotations}
        :param generate_name: Prefix, used by the server, to generate a unique name ONLY IF the ``name`` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#generate_name DaemonSetV1#generate_name}
        :param labels: Map of string keys and values that can be used to organize and categorize (scope and select) the daemon set. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#labels DaemonSetV1#labels}
        :param name: Name of the daemon set, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        value = DaemonSetV1SpecTemplateMetadata(
            annotations=annotations,
            generate_name=generate_name,
            labels=labels,
            name=name,
        )

        return typing.cast(None, jsii.invoke(self, "putMetadata", [value]))

    @jsii.member(jsii_name="putSpec")
    def put_spec(
        self,
        *,
        active_deadline_seconds: typing.Optional[jsii.Number] = None,
        affinity: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecAffinity",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        automount_service_account_token: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        container: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainer",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        dns_config: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecDnsConfig",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        dns_policy: typing.Optional[builtins.str] = None,
        enable_service_links: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        host_aliases: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecHostAliases",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        host_ipc: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        hostname: typing.Optional[builtins.str] = None,
        host_network: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        host_pid: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        image_pull_secrets: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecImagePullSecrets",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        init_container: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainer",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        node_name: typing.Optional[builtins.str] = None,
        node_selector: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        readiness_gate: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecReadinessGate",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        restart_policy: typing.Optional[builtins.str] = None,
        runtime_class_name: typing.Optional[builtins.str] = None,
        scheduler_name: typing.Optional[builtins.str] = None,
        security_context: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecSecurityContext",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        share_process_namespace: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        subdomain: typing.Optional[builtins.str] = None,
        termination_grace_period_seconds: typing.Optional[jsii.Number] = None,
        toleration: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecToleration",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        topology_spread_constraint: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecTopologySpreadConstraint",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        volume: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolume",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#active_deadline_seconds DaemonSetV1#active_deadline_seconds}
        :param affinity: affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#affinity DaemonSetV1#affinity}
        :param automount_service_account_token: AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#automount_service_account_token DaemonSetV1#automount_service_account_token}
        :param container: container block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container DaemonSetV1#container}
        :param dns_config: dns_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dns_config DaemonSetV1#dns_config}
        :param dns_policy: Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Optional: Defaults to 'ClusterFirst', see `Kubernetes reference <https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dns_policy DaemonSetV1#dns_policy}
        :param enable_service_links: Enables generating environment variables for service discovery. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#enable_service_links DaemonSetV1#enable_service_links}
        :param host_aliases: host_aliases block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_aliases DaemonSetV1#host_aliases}
        :param host_ipc: Use the host's ipc namespace. Optional: Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_ipc DaemonSetV1#host_ipc}
        :param hostname: Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#hostname DaemonSetV1#hostname}
        :param host_network: Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_network DaemonSetV1#host_network}
        :param host_pid: Use the host's pid namespace. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_pid DaemonSetV1#host_pid}
        :param image_pull_secrets: image_pull_secrets block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image_pull_secrets DaemonSetV1#image_pull_secrets}
        :param init_container: init_container block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#init_container DaemonSetV1#init_container}
        :param node_name: NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_name DaemonSetV1#node_name}
        :param node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: http://kubernetes.io/docs/user-guide/node-selection. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_selector DaemonSetV1#node_selector}
        :param priority_class_name: If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#priority_class_name DaemonSetV1#priority_class_name}
        :param readiness_gate: readiness_gate block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#readiness_gate DaemonSetV1#readiness_gate}
        :param restart_policy: Restart policy for all containers within the pod. One of Always, OnFailure, Never. More info: http://kubernetes.io/docs/user-guide/pod-states#restartpolicy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#restart_policy DaemonSetV1#restart_policy}
        :param runtime_class_name: RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#runtime_class_name DaemonSetV1#runtime_class_name}
        :param scheduler_name: If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheduler_name DaemonSetV1#scheduler_name}
        :param security_context: security_context block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#security_context DaemonSetV1#security_context}
        :param service_account_name: ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service_account_name DaemonSetV1#service_account_name}
        :param share_process_namespace: Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#share_process_namespace DaemonSetV1#share_process_namespace}
        :param subdomain: If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all.. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#subdomain DaemonSetV1#subdomain}
        :param termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_grace_period_seconds DaemonSetV1#termination_grace_period_seconds}
        :param toleration: toleration block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#toleration DaemonSetV1#toleration}
        :param topology_spread_constraint: topology_spread_constraint block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_spread_constraint DaemonSetV1#topology_spread_constraint}
        :param volume: volume block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume DaemonSetV1#volume}
        """
        value = DaemonSetV1SpecTemplateSpec(
            active_deadline_seconds=active_deadline_seconds,
            affinity=affinity,
            automount_service_account_token=automount_service_account_token,
            container=container,
            dns_config=dns_config,
            dns_policy=dns_policy,
            enable_service_links=enable_service_links,
            host_aliases=host_aliases,
            host_ipc=host_ipc,
            hostname=hostname,
            host_network=host_network,
            host_pid=host_pid,
            image_pull_secrets=image_pull_secrets,
            init_container=init_container,
            node_name=node_name,
            node_selector=node_selector,
            priority_class_name=priority_class_name,
            readiness_gate=readiness_gate,
            restart_policy=restart_policy,
            runtime_class_name=runtime_class_name,
            scheduler_name=scheduler_name,
            security_context=security_context,
            service_account_name=service_account_name,
            share_process_namespace=share_process_namespace,
            subdomain=subdomain,
            termination_grace_period_seconds=termination_grace_period_seconds,
            toleration=toleration,
            topology_spread_constraint=topology_spread_constraint,
            volume=volume,
        )

        return typing.cast(None, jsii.invoke(self, "putSpec", [value]))

    @jsii.member(jsii_name="resetSpec")
    def reset_spec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSpec", []))

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(self) -> DaemonSetV1SpecTemplateMetadataOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateMetadataOutputReference, jsii.get(self, "metadata")
        )

    @builtins.property
    @jsii.member(jsii_name="spec")
    def spec(self) -> "DaemonSetV1SpecTemplateSpecOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecOutputReference", jsii.get(self, "spec")
        )

    @builtins.property
    @jsii.member(jsii_name="metadataInput")
    def metadata_input(self) -> typing.Optional[DaemonSetV1SpecTemplateMetadata]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateMetadata],
            jsii.get(self, "metadataInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="specInput")
    def spec_input(self) -> typing.Optional["DaemonSetV1SpecTemplateSpec"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpec"], jsii.get(self, "specInput")
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplate]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplate], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[DaemonSetV1SpecTemplate]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8ed53d36f21b25140267ea48e0c0a25804cca0801dd65758a5d0bcdafccdac62
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "active_deadline_seconds": "activeDeadlineSeconds",
        "affinity": "affinity",
        "automount_service_account_token": "automountServiceAccountToken",
        "container": "container",
        "dns_config": "dnsConfig",
        "dns_policy": "dnsPolicy",
        "enable_service_links": "enableServiceLinks",
        "host_aliases": "hostAliases",
        "host_ipc": "hostIpc",
        "hostname": "hostname",
        "host_network": "hostNetwork",
        "host_pid": "hostPid",
        "image_pull_secrets": "imagePullSecrets",
        "init_container": "initContainer",
        "node_name": "nodeName",
        "node_selector": "nodeSelector",
        "priority_class_name": "priorityClassName",
        "readiness_gate": "readinessGate",
        "restart_policy": "restartPolicy",
        "runtime_class_name": "runtimeClassName",
        "scheduler_name": "schedulerName",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "share_process_namespace": "shareProcessNamespace",
        "subdomain": "subdomain",
        "termination_grace_period_seconds": "terminationGracePeriodSeconds",
        "toleration": "toleration",
        "topology_spread_constraint": "topologySpreadConstraint",
        "volume": "volume",
    },
)
class DaemonSetV1SpecTemplateSpec:
    def __init__(
        self,
        *,
        active_deadline_seconds: typing.Optional[jsii.Number] = None,
        affinity: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecAffinity",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        automount_service_account_token: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        container: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainer",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        dns_config: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecDnsConfig",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        dns_policy: typing.Optional[builtins.str] = None,
        enable_service_links: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        host_aliases: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecHostAliases",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        host_ipc: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        hostname: typing.Optional[builtins.str] = None,
        host_network: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        host_pid: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        image_pull_secrets: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecImagePullSecrets",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        init_container: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainer",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        node_name: typing.Optional[builtins.str] = None,
        node_selector: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        readiness_gate: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecReadinessGate",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        restart_policy: typing.Optional[builtins.str] = None,
        runtime_class_name: typing.Optional[builtins.str] = None,
        scheduler_name: typing.Optional[builtins.str] = None,
        security_context: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecSecurityContext",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        share_process_namespace: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        subdomain: typing.Optional[builtins.str] = None,
        termination_grace_period_seconds: typing.Optional[jsii.Number] = None,
        toleration: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecToleration",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        topology_spread_constraint: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecTopologySpreadConstraint",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        volume: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolume",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#active_deadline_seconds DaemonSetV1#active_deadline_seconds}
        :param affinity: affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#affinity DaemonSetV1#affinity}
        :param automount_service_account_token: AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#automount_service_account_token DaemonSetV1#automount_service_account_token}
        :param container: container block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container DaemonSetV1#container}
        :param dns_config: dns_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dns_config DaemonSetV1#dns_config}
        :param dns_policy: Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Optional: Defaults to 'ClusterFirst', see `Kubernetes reference <https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dns_policy DaemonSetV1#dns_policy}
        :param enable_service_links: Enables generating environment variables for service discovery. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#enable_service_links DaemonSetV1#enable_service_links}
        :param host_aliases: host_aliases block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_aliases DaemonSetV1#host_aliases}
        :param host_ipc: Use the host's ipc namespace. Optional: Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_ipc DaemonSetV1#host_ipc}
        :param hostname: Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#hostname DaemonSetV1#hostname}
        :param host_network: Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_network DaemonSetV1#host_network}
        :param host_pid: Use the host's pid namespace. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_pid DaemonSetV1#host_pid}
        :param image_pull_secrets: image_pull_secrets block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image_pull_secrets DaemonSetV1#image_pull_secrets}
        :param init_container: init_container block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#init_container DaemonSetV1#init_container}
        :param node_name: NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_name DaemonSetV1#node_name}
        :param node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: http://kubernetes.io/docs/user-guide/node-selection. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_selector DaemonSetV1#node_selector}
        :param priority_class_name: If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#priority_class_name DaemonSetV1#priority_class_name}
        :param readiness_gate: readiness_gate block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#readiness_gate DaemonSetV1#readiness_gate}
        :param restart_policy: Restart policy for all containers within the pod. One of Always, OnFailure, Never. More info: http://kubernetes.io/docs/user-guide/pod-states#restartpolicy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#restart_policy DaemonSetV1#restart_policy}
        :param runtime_class_name: RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#runtime_class_name DaemonSetV1#runtime_class_name}
        :param scheduler_name: If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheduler_name DaemonSetV1#scheduler_name}
        :param security_context: security_context block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#security_context DaemonSetV1#security_context}
        :param service_account_name: ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service_account_name DaemonSetV1#service_account_name}
        :param share_process_namespace: Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#share_process_namespace DaemonSetV1#share_process_namespace}
        :param subdomain: If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all.. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#subdomain DaemonSetV1#subdomain}
        :param termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_grace_period_seconds DaemonSetV1#termination_grace_period_seconds}
        :param toleration: toleration block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#toleration DaemonSetV1#toleration}
        :param topology_spread_constraint: topology_spread_constraint block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_spread_constraint DaemonSetV1#topology_spread_constraint}
        :param volume: volume block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume DaemonSetV1#volume}
        """
        if isinstance(affinity, dict):
            affinity = DaemonSetV1SpecTemplateSpecAffinity(**affinity)
        if isinstance(dns_config, dict):
            dns_config = DaemonSetV1SpecTemplateSpecDnsConfig(**dns_config)
        if isinstance(security_context, dict):
            security_context = DaemonSetV1SpecTemplateSpecSecurityContext(
                **security_context
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__95511a398776317ea2907cbb20d3b7f6f6becb7daf23a5bcadf2bc1290af1a46
            )
            check_type(
                argname="argument active_deadline_seconds",
                value=active_deadline_seconds,
                expected_type=type_hints["active_deadline_seconds"],
            )
            check_type(
                argname="argument affinity",
                value=affinity,
                expected_type=type_hints["affinity"],
            )
            check_type(
                argname="argument automount_service_account_token",
                value=automount_service_account_token,
                expected_type=type_hints["automount_service_account_token"],
            )
            check_type(
                argname="argument container",
                value=container,
                expected_type=type_hints["container"],
            )
            check_type(
                argname="argument dns_config",
                value=dns_config,
                expected_type=type_hints["dns_config"],
            )
            check_type(
                argname="argument dns_policy",
                value=dns_policy,
                expected_type=type_hints["dns_policy"],
            )
            check_type(
                argname="argument enable_service_links",
                value=enable_service_links,
                expected_type=type_hints["enable_service_links"],
            )
            check_type(
                argname="argument host_aliases",
                value=host_aliases,
                expected_type=type_hints["host_aliases"],
            )
            check_type(
                argname="argument host_ipc",
                value=host_ipc,
                expected_type=type_hints["host_ipc"],
            )
            check_type(
                argname="argument hostname",
                value=hostname,
                expected_type=type_hints["hostname"],
            )
            check_type(
                argname="argument host_network",
                value=host_network,
                expected_type=type_hints["host_network"],
            )
            check_type(
                argname="argument host_pid",
                value=host_pid,
                expected_type=type_hints["host_pid"],
            )
            check_type(
                argname="argument image_pull_secrets",
                value=image_pull_secrets,
                expected_type=type_hints["image_pull_secrets"],
            )
            check_type(
                argname="argument init_container",
                value=init_container,
                expected_type=type_hints["init_container"],
            )
            check_type(
                argname="argument node_name",
                value=node_name,
                expected_type=type_hints["node_name"],
            )
            check_type(
                argname="argument node_selector",
                value=node_selector,
                expected_type=type_hints["node_selector"],
            )
            check_type(
                argname="argument priority_class_name",
                value=priority_class_name,
                expected_type=type_hints["priority_class_name"],
            )
            check_type(
                argname="argument readiness_gate",
                value=readiness_gate,
                expected_type=type_hints["readiness_gate"],
            )
            check_type(
                argname="argument restart_policy",
                value=restart_policy,
                expected_type=type_hints["restart_policy"],
            )
            check_type(
                argname="argument runtime_class_name",
                value=runtime_class_name,
                expected_type=type_hints["runtime_class_name"],
            )
            check_type(
                argname="argument scheduler_name",
                value=scheduler_name,
                expected_type=type_hints["scheduler_name"],
            )
            check_type(
                argname="argument security_context",
                value=security_context,
                expected_type=type_hints["security_context"],
            )
            check_type(
                argname="argument service_account_name",
                value=service_account_name,
                expected_type=type_hints["service_account_name"],
            )
            check_type(
                argname="argument share_process_namespace",
                value=share_process_namespace,
                expected_type=type_hints["share_process_namespace"],
            )
            check_type(
                argname="argument subdomain",
                value=subdomain,
                expected_type=type_hints["subdomain"],
            )
            check_type(
                argname="argument termination_grace_period_seconds",
                value=termination_grace_period_seconds,
                expected_type=type_hints["termination_grace_period_seconds"],
            )
            check_type(
                argname="argument toleration",
                value=toleration,
                expected_type=type_hints["toleration"],
            )
            check_type(
                argname="argument topology_spread_constraint",
                value=topology_spread_constraint,
                expected_type=type_hints["topology_spread_constraint"],
            )
            check_type(
                argname="argument volume",
                value=volume,
                expected_type=type_hints["volume"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if active_deadline_seconds is not None:
            self._values["active_deadline_seconds"] = active_deadline_seconds
        if affinity is not None:
            self._values["affinity"] = affinity
        if automount_service_account_token is not None:
            self._values[
                "automount_service_account_token"
            ] = automount_service_account_token
        if container is not None:
            self._values["container"] = container
        if dns_config is not None:
            self._values["dns_config"] = dns_config
        if dns_policy is not None:
            self._values["dns_policy"] = dns_policy
        if enable_service_links is not None:
            self._values["enable_service_links"] = enable_service_links
        if host_aliases is not None:
            self._values["host_aliases"] = host_aliases
        if host_ipc is not None:
            self._values["host_ipc"] = host_ipc
        if hostname is not None:
            self._values["hostname"] = hostname
        if host_network is not None:
            self._values["host_network"] = host_network
        if host_pid is not None:
            self._values["host_pid"] = host_pid
        if image_pull_secrets is not None:
            self._values["image_pull_secrets"] = image_pull_secrets
        if init_container is not None:
            self._values["init_container"] = init_container
        if node_name is not None:
            self._values["node_name"] = node_name
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if priority_class_name is not None:
            self._values["priority_class_name"] = priority_class_name
        if readiness_gate is not None:
            self._values["readiness_gate"] = readiness_gate
        if restart_policy is not None:
            self._values["restart_policy"] = restart_policy
        if runtime_class_name is not None:
            self._values["runtime_class_name"] = runtime_class_name
        if scheduler_name is not None:
            self._values["scheduler_name"] = scheduler_name
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if share_process_namespace is not None:
            self._values["share_process_namespace"] = share_process_namespace
        if subdomain is not None:
            self._values["subdomain"] = subdomain
        if termination_grace_period_seconds is not None:
            self._values[
                "termination_grace_period_seconds"
            ] = termination_grace_period_seconds
        if toleration is not None:
            self._values["toleration"] = toleration
        if topology_spread_constraint is not None:
            self._values["topology_spread_constraint"] = topology_spread_constraint
        if volume is not None:
            self._values["volume"] = volume

    @builtins.property
    def active_deadline_seconds(self) -> typing.Optional[jsii.Number]:
        """Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.

        Value must be a positive integer.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#active_deadline_seconds DaemonSetV1#active_deadline_seconds}
        """
        result = self._values.get("active_deadline_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def affinity(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecAffinity"]:
        """affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#affinity DaemonSetV1#affinity}
        """
        result = self._values.get("affinity")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecAffinity"], result
        )

    @builtins.property
    def automount_service_account_token(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#automount_service_account_token DaemonSetV1#automount_service_account_token}
        """
        result = self._values.get("automount_service_account_token")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def container(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainer"],
        ]
    ]:
        """container block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container DaemonSetV1#container}
        """
        result = self._values.get("container")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainer"],
                ]
            ],
            result,
        )

    @builtins.property
    def dns_config(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecDnsConfig"]:
        """dns_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dns_config DaemonSetV1#dns_config}
        """
        result = self._values.get("dns_config")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecDnsConfig"], result
        )

    @builtins.property
    def dns_policy(self) -> typing.Optional[builtins.str]:
        """Set DNS policy for containers within the pod.

        Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Optional: Defaults to 'ClusterFirst', see `Kubernetes reference <https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy>`_.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dns_policy DaemonSetV1#dns_policy}
        """
        result = self._values.get("dns_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_service_links(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Enables generating environment variables for service discovery. Defaults to true.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#enable_service_links DaemonSetV1#enable_service_links}
        """
        result = self._values.get("enable_service_links")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def host_aliases(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecHostAliases"],
        ]
    ]:
        """host_aliases block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_aliases DaemonSetV1#host_aliases}
        """
        result = self._values.get("host_aliases")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecHostAliases"],
                ]
            ],
            result,
        )

    @builtins.property
    def host_ipc(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Use the host's ipc namespace. Optional: Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_ipc DaemonSetV1#host_ipc}
        """
        result = self._values.get("host_ipc")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def hostname(self) -> typing.Optional[builtins.str]:
        """Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#hostname DaemonSetV1#hostname}
        """
        result = self._values.get("hostname")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_network(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Host networking requested for this pod.

        Use the host's network namespace. If this option is set, the ports that will be used must be specified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_network DaemonSetV1#host_network}
        """
        result = self._values.get("host_network")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def host_pid(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Use the host's pid namespace.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_pid DaemonSetV1#host_pid}
        """
        result = self._values.get("host_pid")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def image_pull_secrets(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecImagePullSecrets"],
        ]
    ]:
        """image_pull_secrets block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image_pull_secrets DaemonSetV1#image_pull_secrets}
        """
        result = self._values.get("image_pull_secrets")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecImagePullSecrets"],
                ]
            ],
            result,
        )

    @builtins.property
    def init_container(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainer"],
        ]
    ]:
        """init_container block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#init_container DaemonSetV1#init_container}
        """
        result = self._values.get("init_container")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecInitContainer"],
                ]
            ],
            result,
        )

    @builtins.property
    def node_name(self) -> typing.Optional[builtins.str]:
        """NodeName is a request to schedule this pod onto a specific node.

        If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_name DaemonSetV1#node_name}
        """
        result = self._values.get("node_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """NodeSelector is a selector which must be true for the pod to fit on a node.

        Selector which must match a node's labels for the pod to be scheduled on that node. More info: http://kubernetes.io/docs/user-guide/node-selection.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_selector DaemonSetV1#node_selector}
        """
        result = self._values.get("node_selector")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        """If specified, indicates the pod's priority.

        "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#priority_class_name DaemonSetV1#priority_class_name}
        """
        result = self._values.get("priority_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def readiness_gate(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecReadinessGate"],
        ]
    ]:
        """readiness_gate block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#readiness_gate DaemonSetV1#readiness_gate}
        """
        result = self._values.get("readiness_gate")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecReadinessGate"],
                ]
            ],
            result,
        )

    @builtins.property
    def restart_policy(self) -> typing.Optional[builtins.str]:
        """Restart policy for all containers within the pod. One of Always, OnFailure, Never. More info: http://kubernetes.io/docs/user-guide/pod-states#restartpolicy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#restart_policy DaemonSetV1#restart_policy}
        """
        result = self._values.get("restart_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def runtime_class_name(self) -> typing.Optional[builtins.str]:
        """RuntimeClassName is a feature for selecting the container runtime configuration.

        The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#runtime_class_name DaemonSetV1#runtime_class_name}
        """
        result = self._values.get("runtime_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheduler_name(self) -> typing.Optional[builtins.str]:
        """If specified, the pod will be dispatched by specified scheduler.

        If not specified, the pod will be dispatched by default scheduler.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheduler_name DaemonSetV1#scheduler_name}
        """
        result = self._values.get("scheduler_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContext"]:
        """security_context block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#security_context DaemonSetV1#security_context}
        """
        result = self._values.get("security_context")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContext"], result
        )

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        """ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service_account_name DaemonSetV1#service_account_name}
        """
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def share_process_namespace(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Share a single process namespace between all of the containers in a pod.

        When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#share_process_namespace DaemonSetV1#share_process_namespace}
        """
        result = self._values.get("share_process_namespace")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def subdomain(self) -> typing.Optional[builtins.str]:
        """If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#subdomain DaemonSetV1#subdomain}
        """
        result = self._values.get("subdomain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination_grace_period_seconds(self) -> typing.Optional[jsii.Number]:
        """Optional duration in seconds the pod needs to terminate gracefully.

        May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_grace_period_seconds DaemonSetV1#termination_grace_period_seconds}
        """
        result = self._values.get("termination_grace_period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def toleration(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecToleration"],
        ]
    ]:
        """toleration block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#toleration DaemonSetV1#toleration}
        """
        result = self._values.get("toleration")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecToleration"],
                ]
            ],
            result,
        )

    @builtins.property
    def topology_spread_constraint(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecTopologySpreadConstraint"],
        ]
    ]:
        """topology_spread_constraint block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_spread_constraint DaemonSetV1#topology_spread_constraint}
        """
        result = self._values.get("topology_spread_constraint")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecTopologySpreadConstraint"],
                ]
            ],
            result,
        )

    @builtins.property
    def volume(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolume"],
        ]
    ]:
        """volume block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume DaemonSetV1#volume}
        """
        result = self._values.get("volume")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolume"],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class DaemonSetV1SpecTemplateSpecAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinity",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        pod_affinity: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinity",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        pod_anti_affinity: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param node_affinity: node_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_affinity DaemonSetV1#node_affinity}
        :param pod_affinity: pod_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_affinity DaemonSetV1#pod_affinity}
        :param pod_anti_affinity: pod_anti_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_anti_affinity DaemonSetV1#pod_anti_affinity}
        """
        if isinstance(node_affinity, dict):
            node_affinity = DaemonSetV1SpecTemplateSpecAffinityNodeAffinity(
                **node_affinity
            )
        if isinstance(pod_affinity, dict):
            pod_affinity = DaemonSetV1SpecTemplateSpecAffinityPodAffinity(
                **pod_affinity
            )
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity(
                **pod_anti_affinity
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__693cd2db5715b1b053e5e9228c51101a566d7aa64e97814ec4d066323bd0e168
            )
            check_type(
                argname="argument node_affinity",
                value=node_affinity,
                expected_type=type_hints["node_affinity"],
            )
            check_type(
                argname="argument pod_affinity",
                value=pod_affinity,
                expected_type=type_hints["pod_affinity"],
            )
            check_type(
                argname="argument pod_anti_affinity",
                value=pod_anti_affinity,
                expected_type=type_hints["pod_anti_affinity"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecAffinityNodeAffinity"]:
        """node_affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_affinity DaemonSetV1#node_affinity}
        """
        result = self._values.get("node_affinity")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecAffinityNodeAffinity"], result
        )

    @builtins.property
    def pod_affinity(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAffinity"]:
        """pod_affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_affinity DaemonSetV1#pod_affinity}
        """
        result = self._values.get("pod_affinity")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAffinity"], result
        )

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity"]:
        """pod_anti_affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_anti_affinity DaemonSetV1#pod_anti_affinity}
        """
        result = self._values.get("pod_anti_affinity")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity"],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        :param required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
                **required_during_scheduling_ignored_during_execution
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9349475339419afa4c75a269dd19e628e3821315740ba7358743aa269a61a9da
            )
            check_type(
                argname="argument preferred_during_scheduling_ignored_during_execution",
                value=preferred_during_scheduling_ignored_during_execution,
                expected_type=type_hints[
                    "preferred_during_scheduling_ignored_during_execution"
                ],
            )
            check_type(
                argname="argument required_during_scheduling_ignored_during_execution",
                value=required_during_scheduling_ignored_during_execution,
                expected_type=type_hints[
                    "required_during_scheduling_ignored_during_execution"
                ],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values[
                "preferred_during_scheduling_ignored_during_execution"
            ] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values[
                "required_during_scheduling_ignored_during_execution"
            ] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        """preferred_during_scheduling_ignored_during_execution block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        """
        result = self._values.get(
            "preferred_during_scheduling_ignored_during_execution"
        )
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"
    ]:
        """required_during_scheduling_ignored_during_execution block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cae1b019ed9c8ad4db95c9429ebb1918ab083e56501c75cfbca1fb0b88273deb
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPreferredDuringSchedulingIgnoredDuringExecution")
    def put_preferred_during_scheduling_ignored_during_execution(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3280415ad842a946f6c371aebb444aed02159cfa03a05fd6f095d9df9e91a964
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(
            None,
            jsii.invoke(
                self, "putPreferredDuringSchedulingIgnoredDuringExecution", [value]
            ),
        )

    @jsii.member(jsii_name="putRequiredDuringSchedulingIgnoredDuringExecution")
    def put_required_during_scheduling_ignored_during_execution(
        self,
        *,
        node_selector_term: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param node_selector_term: node_selector_term block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_selector_term DaemonSetV1#node_selector_term}
        """
        value = DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
            node_selector_term=node_selector_term
        )

        return typing.cast(
            None,
            jsii.invoke(
                self, "putRequiredDuringSchedulingIgnoredDuringExecution", [value]
            ),
        )

    @jsii.member(jsii_name="resetPreferredDuringSchedulingIgnoredDuringExecution")
    def reset_preferred_during_scheduling_ignored_during_execution(self) -> None:
        return typing.cast(
            None,
            jsii.invoke(
                self, "resetPreferredDuringSchedulingIgnoredDuringExecution", []
            ),
        )

    @jsii.member(jsii_name="resetRequiredDuringSchedulingIgnoredDuringExecution")
    def reset_required_during_scheduling_ignored_during_execution(self) -> None:
        return typing.cast(
            None,
            jsii.invoke(
                self, "resetRequiredDuringSchedulingIgnoredDuringExecution", []
            ),
        )

    @builtins.property
    @jsii.member(jsii_name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
            jsii.get(self, "preferredDuringSchedulingIgnoredDuringExecution"),
        )

    @builtins.property
    @jsii.member(jsii_name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
            jsii.get(self, "requiredDuringSchedulingIgnoredDuringExecution"),
        )

    @builtins.property
    @jsii.member(jsii_name="preferredDuringSchedulingIgnoredDuringExecutionInput")
    def preferred_during_scheduling_ignored_during_execution_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            jsii.get(self, "preferredDuringSchedulingIgnoredDuringExecutionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="requiredDuringSchedulingIgnoredDuringExecutionInput")
    def required_during_scheduling_ignored_during_execution_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"
            ],
            jsii.get(self, "requiredDuringSchedulingIgnoredDuringExecutionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecAffinityNodeAffinity]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecAffinityNodeAffinity],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinityNodeAffinity],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0b603d08b74f1b63be048da7bab6f119ecbf7be7502d631851733c1a12bf8f61
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union[
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
            typing.Dict[builtins.str, typing.Any],
        ],
        weight: jsii.Number,
    ) -> None:
        """
        :param preference: preference block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preference DaemonSetV1#preference}
        :param weight: weight is in the range 1-100. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#weight DaemonSetV1#weight}
        """
        if isinstance(preference, dict):
            preference = DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
                **preference
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4481b6bcb4f77a066eb24b820a4275069085fce0416a7d15620682b591c117bb
            )
            check_type(
                argname="argument preference",
                value=preference,
                expected_type=type_hints["preference"],
            )
            check_type(
                argname="argument weight",
                value=weight,
                expected_type=type_hints["weight"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        """preference block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preference DaemonSetV1#preference}
        """
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
            result,
        )

    @builtins.property
    def weight(self) -> jsii.Number:
        """weight is in the range 1-100.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#weight DaemonSetV1#weight}
        """
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__48644923600d433ed7c6b0d8628371c449b6926953868cc79b75962f0ce3b672
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__964f0459eb09bd54107d69873ac00687f981da3958f7164dd9f02a6ed1611adb
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5793281831dba73d197eaa6d3707d81d452e6ac8e15adc001af20dd4a001e9ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__37f6b58b51960cbcfb1c64e9a6330448ff71a8768c9ae9eebe64ba943163554a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08d80a47e97cdcefdc9016cf1ac4d9dd243e0e6b1d6d142f0609c1975df948e6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8733108ae58cf83da66a7017c25a586d06a487f713d9d6b6e28fb57f4bd42cac
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__61c18d6de823a4f1a90904ed2129ad75df0d9e1a471e67295f501289cecc31e3
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putPreference")
    def put_preference(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        value = DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
            match_expressions=match_expressions
        )

        return typing.cast(None, jsii.invoke(self, "putPreference", [value]))

    @builtins.property
    @jsii.member(jsii_name="preference")
    def preference(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference",
            jsii.get(self, "preference"),
        )

    @builtins.property
    @jsii.member(jsii_name="preferenceInput")
    def preference_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference"
            ],
            jsii.get(self, "preferenceInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="weightInput")
    def weight_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "weightInput"))

    @builtins.property
    @jsii.member(jsii_name="weight")
    def weight(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "weight"))

    @weight.setter
    def weight(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b5f33e2744e129dc3f30b67d8416d64c4d2027b4767af1fa09d8e04b0da1c734
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "weight", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a9b7624a4340ce70b063d88306cefbb90850d9c5046fd2ff830cc02f2998ddb4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={"match_expressions": "matchExpressions"},
)
class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5d11a9ca10f7ef9cfc92a760aa472e8bb0783b90e0041dfc0f650e8da640854f
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"
            ],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__414be9fba4ddb1db93504bc1ea784587cb9920e8ba86fc1a66f2a0f5e07aaccd
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """Operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """Values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b472534dd33b457e0a55f4f7935e03229c66ccd9152d543f68d625cccb9f57f5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f501757831ef760b2cb5cad82482e3a1a53788502c548d5c35b22a2ea188693
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0c94e342023998f1ea04ddc81d22bdff0f95df5aea225237cbe109083a6211ae
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__61b89b48c0ee8a0d19175928b95a4c0ba8c73e787548f775d9f5a80436f7d1ad
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15e5ef957890721c90acc75ef552385f43d40f67559861608615724ed42498d2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__87780a562e13a483750d8f73c0c3d6c68f71c2e79af19b66a366ca0e1474c773
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e08d8417a2471595cd0f838df12c2e99ededda9ae4a5bc0393c2680c94568c90
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d5745c487a19d7e456b7dc5ad2f9c757f635142e81aa2fd2521472a05398793a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2d00a2aee68497c0ece82b33c853c5e258419ec4ff46fdcffa3b967078080e8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85bb17c0194033beb1e98da9f5cd6a59df31e3a880beff33d11f49c333b0e775
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b6be36e9d74f2a385ba798c60a48161a9070c440a419a523c8e472341783e5b9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ae13f8be74d540ffa0fc4f9e28e59aa99ec0b9cee85a0481f2391015abc63602
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3ff1d821e9875b214d546ac3e7579948e5da0c3938ca9348bcbd93ecc1f16373
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__32377dc9813e151481b00e23926242ae69f87a1210fce83dcad422a034f27816
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_term": "nodeSelectorTerm"},
)
class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_term: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param node_selector_term: node_selector_term block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_selector_term DaemonSetV1#node_selector_term}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__98e964a2e0ed29054d31cbb069f702c7d5964e1d37b96611a85c38127fae6582
            )
            check_type(
                argname="argument node_selector_term",
                value=node_selector_term,
                expected_type=type_hints["node_selector_term"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_selector_term is not None:
            self._values["node_selector_term"] = node_selector_term

    @builtins.property
    def node_selector_term(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm"
            ],
        ]
    ]:
        """node_selector_term block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_selector_term DaemonSetV1#node_selector_term}
        """
        result = self._values.get("node_selector_term")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm",
    jsii_struct_bases=[],
    name_mapping={"match_expressions": "matchExpressions"},
)
class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7e69f4cb475abee38f96981d1ab7ec90a22e7131c1be24b64f36fbcddfbe884d
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions"
            ],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7356d7680ed7ab8cfb880ad2817c6acc7dc99bc235bda9f3fd36a0a46c169eeb
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__220fc297681773368f4aa80b9bb2cfff7cf8aa925eb3da1886df25078e0e2073
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cb9212d67bf4b6dc788c214f1c433f5af96d601012ac54ee004d21a8e0bc1295
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__98d5affcc4e04982b216972871f0fd75153e96366be78b03cd85804c03f9523d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1c7a303b05a21019893367f0fd87098bf16e57c9913c5966486a62d9d566039e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ad2a940a7bdbebdb44d2c3bb66129dd93567c4b0d7802127db9564d5136b3fa6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__86eae4794968b54acf252457cb375d18cb9f68de2ece868455b8349c8a054635
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """Operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """Values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f4d3101ce921028d6ea6907d5405d276cc2e491eba9d57caf4bd788fc075330d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__60df4c55047d53a26465745e92cd602372abc184a11e3efe4ada16abf1a3b995
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d029328a5a06a8a8fd6d7429b10d25833420d1223c3056c43478de3eb183ac00
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ee7377e3a3d7dc7f16ed26d10ae8848af834e259840e70df89c44a613551551c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc79f216107f60551a601ddb8f64b5f1d8786a7737ab63ec4b5b68c7716c2799
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c37a87b5b866281dbd7bebe09acda7d3aa2b367a7235c15bcb8b97551f83c56b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d21a259825801aa8dfc05e4e8b15d321ef3f4c01bcd1809c8670224e9fb98947
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d4edd2b18699ecacdae8a08a150615ab485f64f727455a59bd64ef7eadf4fe7c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__74b2d6713255dd6cf3734fc50f7c3acaa03ecac8ba5ba8fc374ed45c701af76e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__449b767986060950cb213b95a4aad380645c04a53fb35df11d966e06869e98fe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__12facbb081ed7e22886f8129e8928b2eb1455f1a6111e029a756a35ee3ec2e54
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__62b44a9d0301649af28a13d17d0e715c14d1412d3fd9cfa04cd761ec59994de7
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47b89b8c39acf9c9b17ed01c4867427204635a34a7dc5e3c2a7bf2f4a20d36fd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2dd0c58ada56bb2770faec84ef6a02698c784e7f13c705275f5f77ba12d7ca0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ebef385022fbbbf4d16b67af8dacb58d55fded0928d7b748bec62841a4d79dbe
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putNodeSelectorTerm")
    def put_node_selector_term(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9f8eb4b9a2a9154414374df2bb927c2c8f01291d26b2c1c141de7c7b3e60f767
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putNodeSelectorTerm", [value]))

    @jsii.member(jsii_name="resetNodeSelectorTerm")
    def reset_node_selector_term(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeSelectorTerm", []))

    @builtins.property
    @jsii.member(jsii_name="nodeSelectorTerm")
    def node_selector_term(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermList,
            jsii.get(self, "nodeSelectorTerm"),
        )

    @builtins.property
    @jsii.member(jsii_name="nodeSelectorTermInput")
    def node_selector_term_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm
                    ],
                ]
            ],
            jsii.get(self, "nodeSelectorTermInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aac43114436d50b13744b3ce5397bd805824286039e763b2557dbe26b84a7f72
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__17a7140b297f53c313b1a9112f7fddb69dd23afee06e0bfa80a7c1edfa7f066e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putNodeAffinity")
    def put_node_affinity(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        :param required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        value = DaemonSetV1SpecTemplateSpecAffinityNodeAffinity(
            preferred_during_scheduling_ignored_during_execution=preferred_during_scheduling_ignored_during_execution,
            required_during_scheduling_ignored_during_execution=required_during_scheduling_ignored_during_execution,
        )

        return typing.cast(None, jsii.invoke(self, "putNodeAffinity", [value]))

    @jsii.member(jsii_name="putPodAffinity")
    def put_pod_affinity(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        :param required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        value = DaemonSetV1SpecTemplateSpecAffinityPodAffinity(
            preferred_during_scheduling_ignored_during_execution=preferred_during_scheduling_ignored_during_execution,
            required_during_scheduling_ignored_during_execution=required_during_scheduling_ignored_during_execution,
        )

        return typing.cast(None, jsii.invoke(self, "putPodAffinity", [value]))

    @jsii.member(jsii_name="putPodAntiAffinity")
    def put_pod_anti_affinity(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        :param required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        value = DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity(
            preferred_during_scheduling_ignored_during_execution=preferred_during_scheduling_ignored_during_execution,
            required_during_scheduling_ignored_during_execution=required_during_scheduling_ignored_during_execution,
        )

        return typing.cast(None, jsii.invoke(self, "putPodAntiAffinity", [value]))

    @jsii.member(jsii_name="resetNodeAffinity")
    def reset_node_affinity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeAffinity", []))

    @jsii.member(jsii_name="resetPodAffinity")
    def reset_pod_affinity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodAffinity", []))

    @jsii.member(jsii_name="resetPodAntiAffinity")
    def reset_pod_anti_affinity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodAntiAffinity", []))

    @builtins.property
    @jsii.member(jsii_name="nodeAffinity")
    def node_affinity(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityNodeAffinityOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityOutputReference,
            jsii.get(self, "nodeAffinity"),
        )

    @builtins.property
    @jsii.member(jsii_name="podAffinity")
    def pod_affinity(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityOutputReference",
            jsii.get(self, "podAffinity"),
        )

    @builtins.property
    @jsii.member(jsii_name="podAntiAffinity")
    def pod_anti_affinity(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityOutputReference",
            jsii.get(self, "podAntiAffinity"),
        )

    @builtins.property
    @jsii.member(jsii_name="nodeAffinityInput")
    def node_affinity_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecAffinityNodeAffinity]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecAffinityNodeAffinity],
            jsii.get(self, "nodeAffinityInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="podAffinityInput")
    def pod_affinity_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAffinity"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAffinity"],
            jsii.get(self, "podAffinityInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="podAntiAffinityInput")
    def pod_anti_affinity_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity"],
            jsii.get(self, "podAntiAffinityInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecAffinity]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecAffinity],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinity],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4024630229508eda1049e78dd60f4afb4a3b35df45f5c4d3ff0ff5fdabcfc97b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        :param required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0dc4ab4df8c018cf6ac7e286465fe9aad94edc2012b548c811c3c1426c20b6ec
            )
            check_type(
                argname="argument preferred_during_scheduling_ignored_during_execution",
                value=preferred_during_scheduling_ignored_during_execution,
                expected_type=type_hints[
                    "preferred_during_scheduling_ignored_during_execution"
                ],
            )
            check_type(
                argname="argument required_during_scheduling_ignored_during_execution",
                value=required_during_scheduling_ignored_during_execution,
                expected_type=type_hints[
                    "required_during_scheduling_ignored_during_execution"
                ],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values[
                "preferred_during_scheduling_ignored_during_execution"
            ] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values[
                "required_during_scheduling_ignored_during_execution"
            ] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        """preferred_during_scheduling_ignored_during_execution block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        """
        result = self._values.get(
            "preferred_during_scheduling_ignored_during_execution"
        )
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        """required_during_scheduling_ignored_during_execution block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1ccc7ee91db6eec86d475414f6815d3bab166e9bd76ed31301f5971aeffb73d6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPreferredDuringSchedulingIgnoredDuringExecution")
    def put_preferred_during_scheduling_ignored_during_execution(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bfdb0fa49ce5fdf34e13c204414b8de772d11aa67545de0dc57217431dd927ab
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(
            None,
            jsii.invoke(
                self, "putPreferredDuringSchedulingIgnoredDuringExecution", [value]
            ),
        )

    @jsii.member(jsii_name="putRequiredDuringSchedulingIgnoredDuringExecution")
    def put_required_during_scheduling_ignored_during_execution(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97d199480ace5dcbe9d64454f61adac622c1338437ae89c7d336b4704458cda7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(
            None,
            jsii.invoke(
                self, "putRequiredDuringSchedulingIgnoredDuringExecution", [value]
            ),
        )

    @jsii.member(jsii_name="resetPreferredDuringSchedulingIgnoredDuringExecution")
    def reset_preferred_during_scheduling_ignored_during_execution(self) -> None:
        return typing.cast(
            None,
            jsii.invoke(
                self, "resetPreferredDuringSchedulingIgnoredDuringExecution", []
            ),
        )

    @jsii.member(jsii_name="resetRequiredDuringSchedulingIgnoredDuringExecution")
    def reset_required_during_scheduling_ignored_during_execution(self) -> None:
        return typing.cast(
            None,
            jsii.invoke(
                self, "resetRequiredDuringSchedulingIgnoredDuringExecution", []
            ),
        )

    @builtins.property
    @jsii.member(jsii_name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
            jsii.get(self, "preferredDuringSchedulingIgnoredDuringExecution"),
        )

    @builtins.property
    @jsii.member(jsii_name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
            jsii.get(self, "requiredDuringSchedulingIgnoredDuringExecution"),
        )

    @builtins.property
    @jsii.member(jsii_name="preferredDuringSchedulingIgnoredDuringExecutionInput")
    def preferred_during_scheduling_ignored_during_execution_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            jsii.get(self, "preferredDuringSchedulingIgnoredDuringExecutionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="requiredDuringSchedulingIgnoredDuringExecutionInput")
    def required_during_scheduling_ignored_during_execution_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            jsii.get(self, "requiredDuringSchedulingIgnoredDuringExecutionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAffinity]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAffinity],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAffinity],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__20699e3ac57af5bbaf5ef50f20a6678c3d7eeb35b6f7c64d41672466d53de60d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union[
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
            typing.Dict[builtins.str, typing.Any],
        ],
        weight: jsii.Number,
    ) -> None:
        """
        :param pod_affinity_term: pod_affinity_term block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_affinity_term DaemonSetV1#pod_affinity_term}
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#weight DaemonSetV1#weight}
        """
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
                **pod_affinity_term
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__683ccf583595e019f8b20c7e8907f39d2d99424fc6f303fa9a52fe73b52df0ec
            )
            check_type(
                argname="argument pod_affinity_term",
                value=pod_affinity_term,
                expected_type=type_hints["pod_affinity_term"],
            )
            check_type(
                argname="argument weight",
                value=weight,
                expected_type=type_hints["weight"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        """pod_affinity_term block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_affinity_term DaemonSetV1#pod_affinity_term}
        """
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
            result,
        )

    @builtins.property
    def weight(self) -> jsii.Number:
        """weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#weight DaemonSetV1#weight}
        """
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b54bd9a5e22f63b369af22a0548ef5d6af9c5920b757ee22bccebd6cfd57aaac
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fed7f274cfa8a211d9e9af0effd19792fd73c5e64658efa57c45522dad464569
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7f585b20ef6bfe65f5f610ff05571e6954c187b6ca65ae57c6de5c4535b25b5d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b3da42f3801d48b38e32941a3e9ca44618ec1e2d80879d5090c924b281efc425
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bec55d5badd9178b3e9db7dccf8145eea712c7826111609a3a26c97bcde02a8f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd0bcd0a9b8093c44b325e333e408476423ad66a67ecffffdbd5a3e16367ed19
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7aaa8843d68934439608a37fab967d71890f4f2b44bcbc1ad54d22756439948
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putPodAffinityTerm")
    def put_pod_affinity_term(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param topology_key: empty topology key is interpreted by the scheduler as 'all topologies'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        :param label_selector: label_selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        :param namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        value = DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
            topology_key=topology_key,
            label_selector=label_selector,
            namespaces=namespaces,
        )

        return typing.cast(None, jsii.invoke(self, "putPodAffinityTerm", [value]))

    @builtins.property
    @jsii.member(jsii_name="podAffinityTerm")
    def pod_affinity_term(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference",
            jsii.get(self, "podAffinityTerm"),
        )

    @builtins.property
    @jsii.member(jsii_name="podAffinityTermInput")
    def pod_affinity_term_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
            ],
            jsii.get(self, "podAffinityTermInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="weightInput")
    def weight_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "weightInput"))

    @builtins.property
    @jsii.member(jsii_name="weight")
    def weight(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "weight"))

    @weight.setter
    def weight(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__26363e434c221232c422d7b55bb75f91f1d2d350e8f85f0e84de1ea747c97db7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "weight", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f9967821da1fb6593795280a347f68bd863eb617ac80c8ae9a1ad4a39cdcf616
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param topology_key: empty topology key is interpreted by the scheduler as 'all topologies'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        :param label_selector: label_selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        :param namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b0de723eac2f29674bdd102e3c45efe62f781f2d62d1c3184ee7c1ce9056e731
            )
            check_type(
                argname="argument topology_key",
                value=topology_key,
                expected_type=type_hints["topology_key"],
            )
            check_type(
                argname="argument label_selector",
                value=label_selector,
                expected_type=type_hints["label_selector"],
            )
            check_type(
                argname="argument namespaces",
                value=namespaces,
                expected_type=type_hints["namespaces"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        """empty topology key is interpreted by the scheduler as 'all topologies'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        """
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
            ],
        ]
    ]:
        """label_selector block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        """
        result = self._values.get("label_selector")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        """namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        match_labels: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        :param match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6e80a2ebcd3617e6631991bc3f7317951b6a73f0c7629cb7baa44f22e4287f78
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
            check_type(
                argname="argument match_labels",
                value=match_labels,
                expected_type=type_hints["match_labels"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
            ],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """A map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        result = self._values.get("match_labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3550241bd1f57c102f8b59e2b0ce79e47f81748de6135c3bca0e298463a5aed6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2d19ce578f24e54587d08a76e8810b1af16166e2fa6fefa9b8b7070afb97c82b
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__836762c44c89cb2b94fdeb145dc27fdb8336e082b66c23699c2852a312f01c12
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a52ae74d5a348661bf59b8fbd9ade32c834218702fc40dfff2144c22507a2e86
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9d6ea088aab8ad7063ae4f1e2c6ab91be4203f3f867ddaf2c2653c1a8e94a67e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__48b303f8c80462f31a85bdda237d497ad57f73f1249e4720e91c0ce93f98138e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: An array of string values. If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__37b02f6fb468a29383ea24016698fdbef2463c6396b40591e10366172b3c4417
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """An array of string values.

        If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c3e92acf9d9825d8b786c5798eca63282cd9f2e5b049987b5f121ce09a31fa6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0d0e27cec765b0399b857530fca9a5eb6226d87cf170faebbeea7a3c987ac368
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3014ccac2275b2cbea7614e43d11a8ea33aea7bcd5e1df11cc398eb16d463907
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__39a79e27ca34efe83b00d90340d638a20e90bdcd5153548ab11e1961e1061e43
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__04a325243f65ccbc152522902f1dac692e96d1bca68730ef728b9555d2626ce9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a26421182ab3a7bde5fce992e50c73547aa8362bdf84caf01330c81fb49b8f1f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e61d1cfd350a4b9a26458f1671098943d5c84b5bde8ed52bfa1d49b02c672dbc
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d1c54d436ddccb4c55bf37b7319157d47f458dbe5c7945b1bc32835045a900b6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c2eecd491e4514496e36352afe6acf472c2820858156193ece1b88bac5c5ef25
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f0b8ad0c1215ba5b65b7417d000239c548b2ddb55aa952e1298ef0134f5c96f8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__28669c48820bbbd83ef31be2192e91e0c87dac6bea8dd453174f825f9308d9e4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__23b85596c92ae383416788c02eb3430a4d66632d88bd23307cd313543606c1d7
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__91701043d1f724685fcceeb11ed9773a5cafc70384fa0a16c9e5973fa9132ce6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @jsii.member(jsii_name="resetMatchLabels")
    def reset_match_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchLabels", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabelsInput")
    def match_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "matchLabelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabels")
    def match_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "matchLabels")
        )

    @match_labels.setter
    def match_labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b9d482ade1f51e41accb3a1640cb8b7a50a953a6dc57be73d256c4d89f21f68f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "matchLabels", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__341ab9dd0b89052ffb0a0f64dc9c5c6e74561036b1097c5c019aa9a98d616caa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a6b718047aecb82c276abbe49be4b8345af758ad3dd160513e6f49f82edd5a3
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putLabelSelector")
    def put_label_selector(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__235c35b9364efd295e24832f54340e0cdb0bd79d590b452044cbac22cd227f06
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLabelSelector", [value]))

    @jsii.member(jsii_name="resetLabelSelector")
    def reset_label_selector(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabelSelector", []))

    @jsii.member(jsii_name="resetNamespaces")
    def reset_namespaces(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespaces", []))

    @builtins.property
    @jsii.member(jsii_name="labelSelector")
    def label_selector(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList,
            jsii.get(self, "labelSelector"),
        )

    @builtins.property
    @jsii.member(jsii_name="labelSelectorInput")
    def label_selector_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "labelSelectorInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="namespacesInput")
    def namespaces_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "namespacesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="topologyKeyInput")
    def topology_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "topologyKeyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="namespaces")
    def namespaces(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "namespaces"))

    @namespaces.setter
    def namespaces(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c83f17fd203c2fd4be4f68f5f537e05668afe01d33cabe2bf395e5bcfffad4ca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespaces", value)

    @builtins.property
    @jsii.member(jsii_name="topologyKey")
    def topology_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "topologyKey"))

    @topology_key.setter
    def topology_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__94d3f60f3c892116e06ac37cf3cf504519298ee3f8d1fdf02d9dc6c6e3901655
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "topologyKey", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f4e2d3674904d2d64716c9fc6559592163b7ece719aa5a18b03206b74c37c55
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param topology_key: empty topology key is interpreted by the scheduler as 'all topologies'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        :param label_selector: label_selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        :param namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__adebf095bbbf71af062c42c048076c024492f9ba0c2ad29e7026f74f85175c06
            )
            check_type(
                argname="argument topology_key",
                value=topology_key,
                expected_type=type_hints["topology_key"],
            )
            check_type(
                argname="argument label_selector",
                value=label_selector,
                expected_type=type_hints["label_selector"],
            )
            check_type(
                argname="argument namespaces",
                value=namespaces,
                expected_type=type_hints["namespaces"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        """empty topology key is interpreted by the scheduler as 'all topologies'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        """
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
            ],
        ]
    ]:
        """label_selector block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        """
        result = self._values.get("label_selector")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        """namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        match_labels: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        :param match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__25379c6f73a89475d88335a67c43b5037aea1d9ea5188f46032493441482f145
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
            check_type(
                argname="argument match_labels",
                value=match_labels,
                expected_type=type_hints["match_labels"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
            ],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """A map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        result = self._values.get("match_labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b74982780e6c89fcba2dd83f91294c4eea7f95d40acfa7e699ed419612bb5a5c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9e065a8bf8dad6e652345fca28dcb8a925fd57df5ae6bd06e319170c12d89db8
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a99089bf6b68d132e5f26ed8a4eb08e352d2fbfd3396b6648f2d8f2a00c8b0fe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__090b91a492bec277207ee6708cf4c992efb259bf47f6e71d1af5096b01acdd8e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__02f92cf39ee3dbbba4991ce96f8cf1a85f0a282c7a1ecdab47f67ce3f75ed283
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ad5fb66922406f566fa151f4c56ce1b4774e09d0d497e2bbd40db5c11891c289
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: An array of string values. If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a3a88e3185adf47c9fb59922ce6392bcb565318d291415ea394150ed62101d71
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """An array of string values.

        If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__99581151f58ade508abf70941081538ddbe480c76272d56e2a2f61bc6eb8285e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0d92a3eadf24838e1cf7d9c2ac09f9cec5663352d08bf5784299fa61cd9ed6a5
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__53bc76c99f8174476a4e14953e5ea0a7b3238dd51e5d97cc39e450a49c9d8cef
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3d207529afee23225f527ba5da97484a5e104f26bc69e1fc2218ee0399383e0f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a9993f21da027ad4c629a7f578fb40b8f86b365b3a5f0c3ce9da4bae221b77d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc0bb5ac532a3504d18cebfa42d875fddcada78418396796aa078e877292ce66
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e66f8fb2591a4ae0322f447544a006a495a56c4d71500bc4a6ba206fe80d2040
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f9926943c32606c017fdf48e3cd7cd7390e60b4d1b8ffc44113f0504e58d00ca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5346deaa576e6c0a0c2d4cf2b456c62b81d4c46ce5da0627078feba2684534c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f514b6a21a5cf4589629c8aa9605f8e83ad6323e196ffaaa42ec868bbe265063
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0eeb05a1bca8b79a16f264741f6894e5fc5ad3a308755f360bd89216539ad87
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__556eb783908c24d5d1c716f02b7902cc903c59d381a9d18af4e72c47c80bf959
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9d03084f0c79844d11297b326c08f24e4b3d1079046b2bdb1be751976ff07143
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @jsii.member(jsii_name="resetMatchLabels")
    def reset_match_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchLabels", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabelsInput")
    def match_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "matchLabelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabels")
    def match_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "matchLabels")
        )

    @match_labels.setter
    def match_labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ec5332c289b024aac91482f330d8df7dcc0cb811d0d94359819a345a362577df
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "matchLabels", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__22e5c26c294d1fd7e7e300bc03c1e7fa0e7ffac93f9b5d63af9f995c97156882
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6a8b402cf6315ad8dbb1fca6dd3cba5ab585e9b99e4d254527a81f8e18181cbe
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fe4cd27efaa147964e04a64e48c8978e185670f19e4d1aa87cb8533e30f393e6
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c36e343b81f3b92fa8cd82badc3e9ef778bdd9b64123ac68579e9daa3c770d9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9aa0d935d61b037f69c9c0cb213ce450f291c7486447ba8d0adaee3e07a5953b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__295fe58a681ab984dc2546312598637992b6ca33e1a92a1517c17f6b2a862ea5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a2b579f63a0fe6c4d8f0c02c758eaeed541a748ac9f80d3400600089e66d7d4f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c542da3731ce869f607b5110f6ff49391c4f9d962fc06853b10d3ddd3c5a2d11
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putLabelSelector")
    def put_label_selector(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b838fc9d820901c1ec5fe10d26b453b44f887842555ccb74dc742e7386497ef4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLabelSelector", [value]))

    @jsii.member(jsii_name="resetLabelSelector")
    def reset_label_selector(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabelSelector", []))

    @jsii.member(jsii_name="resetNamespaces")
    def reset_namespaces(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespaces", []))

    @builtins.property
    @jsii.member(jsii_name="labelSelector")
    def label_selector(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList,
            jsii.get(self, "labelSelector"),
        )

    @builtins.property
    @jsii.member(jsii_name="labelSelectorInput")
    def label_selector_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "labelSelectorInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="namespacesInput")
    def namespaces_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "namespacesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="topologyKeyInput")
    def topology_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "topologyKeyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="namespaces")
    def namespaces(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "namespaces"))

    @namespaces.setter
    def namespaces(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__17d5766887162741099e58178d165821cf34eb1d838e54b51803ff30c33d66a4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespaces", value)

    @builtins.property
    @jsii.member(jsii_name="topologyKey")
    def topology_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "topologyKey"))

    @topology_key.setter
    def topology_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e6dfba26c5aaadc1060bd22c21efc67ee03938e17c670c2ed6b891d55889665f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "topologyKey", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__37a87c7e899438ac6bd623e34287f50e88831d570d052c86203050d7819a3b20
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        :param required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c6777f3b9c456f7753539214519f5fb88955c1f319d1fc42adeb2f7f57cfb88
            )
            check_type(
                argname="argument preferred_during_scheduling_ignored_during_execution",
                value=preferred_during_scheduling_ignored_during_execution,
                expected_type=type_hints[
                    "preferred_during_scheduling_ignored_during_execution"
                ],
            )
            check_type(
                argname="argument required_during_scheduling_ignored_during_execution",
                value=required_during_scheduling_ignored_during_execution,
                expected_type=type_hints[
                    "required_during_scheduling_ignored_during_execution"
                ],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values[
                "preferred_during_scheduling_ignored_during_execution"
            ] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values[
                "required_during_scheduling_ignored_during_execution"
            ] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        """preferred_during_scheduling_ignored_during_execution block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#preferred_during_scheduling_ignored_during_execution DaemonSetV1#preferred_during_scheduling_ignored_during_execution}
        """
        result = self._values.get(
            "preferred_during_scheduling_ignored_during_execution"
        )
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        """required_during_scheduling_ignored_during_execution block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#required_during_scheduling_ignored_during_execution DaemonSetV1#required_during_scheduling_ignored_during_execution}
        """
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bc8f2afb9d584177fa02c7ebc93edec5fec13159582ef7976512f70a460cae4b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPreferredDuringSchedulingIgnoredDuringExecution")
    def put_preferred_during_scheduling_ignored_during_execution(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__75a3ed2d780683d3aef4f2f4598d1da4de7d6dc18a6dcc95961c3700ea310b7c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(
            None,
            jsii.invoke(
                self, "putPreferredDuringSchedulingIgnoredDuringExecution", [value]
            ),
        )

    @jsii.member(jsii_name="putRequiredDuringSchedulingIgnoredDuringExecution")
    def put_required_during_scheduling_ignored_during_execution(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aa28697668aef27546174527bb336f4780e24e2e336d93eccf802b1ad655d54d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(
            None,
            jsii.invoke(
                self, "putRequiredDuringSchedulingIgnoredDuringExecution", [value]
            ),
        )

    @jsii.member(jsii_name="resetPreferredDuringSchedulingIgnoredDuringExecution")
    def reset_preferred_during_scheduling_ignored_during_execution(self) -> None:
        return typing.cast(
            None,
            jsii.invoke(
                self, "resetPreferredDuringSchedulingIgnoredDuringExecution", []
            ),
        )

    @jsii.member(jsii_name="resetRequiredDuringSchedulingIgnoredDuringExecution")
    def reset_required_during_scheduling_ignored_during_execution(self) -> None:
        return typing.cast(
            None,
            jsii.invoke(
                self, "resetRequiredDuringSchedulingIgnoredDuringExecution", []
            ),
        )

    @builtins.property
    @jsii.member(jsii_name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
            jsii.get(self, "preferredDuringSchedulingIgnoredDuringExecution"),
        )

    @builtins.property
    @jsii.member(jsii_name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
            jsii.get(self, "requiredDuringSchedulingIgnoredDuringExecution"),
        )

    @builtins.property
    @jsii.member(jsii_name="preferredDuringSchedulingIgnoredDuringExecutionInput")
    def preferred_during_scheduling_ignored_during_execution_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            jsii.get(self, "preferredDuringSchedulingIgnoredDuringExecutionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="requiredDuringSchedulingIgnoredDuringExecutionInput")
    def required_during_scheduling_ignored_during_execution_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"
                    ],
                ]
            ],
            jsii.get(self, "requiredDuringSchedulingIgnoredDuringExecutionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d7b878f8fe9a306a9997ceb2e9846d6d36241da090dde26530d77b2f46f0d5c4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union[
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
            typing.Dict[builtins.str, typing.Any],
        ],
        weight: jsii.Number,
    ) -> None:
        """
        :param pod_affinity_term: pod_affinity_term block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_affinity_term DaemonSetV1#pod_affinity_term}
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#weight DaemonSetV1#weight}
        """
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
                **pod_affinity_term
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__202c1d8932c1173c227a8efd0835ac1e251e310c2790000acecd8382733d78ae
            )
            check_type(
                argname="argument pod_affinity_term",
                value=pod_affinity_term,
                expected_type=type_hints["pod_affinity_term"],
            )
            check_type(
                argname="argument weight",
                value=weight,
                expected_type=type_hints["weight"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        """pod_affinity_term block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_affinity_term DaemonSetV1#pod_affinity_term}
        """
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
            result,
        )

    @builtins.property
    def weight(self) -> jsii.Number:
        """weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#weight DaemonSetV1#weight}
        """
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb18a1e3b2b6c762d44b4fdf6e11a4f9c4fdb62006b4392f78bbc0a8c2185145
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__57e6c51e30929df22cb1e2b92c361003051e6ee47b5493dfe91930d39a90b882
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7ba80800e4afbfdbc2c7d84db49837428f8e02768047810f3f101f5efc38cd89
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__31b3e2d81b3f30ae5baf421b426220c11cdb1c4aed17bf5a76f3e1df72c37e44
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6307ac995dfe829707c2db8c8f2db99cf959b9111e97ee9d2910d1601b1f80a5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8d7ef20e8cd8e05f13ae6952e6890a03ccbd7835d0ad42593194abd86d44f406
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4338ea6194b00e7d65de6f9812b3faedc850777498eda2f699b8903268cae098
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putPodAffinityTerm")
    def put_pod_affinity_term(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param topology_key: empty topology key is interpreted by the scheduler as 'all topologies'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        :param label_selector: label_selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        :param namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        value = DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
            topology_key=topology_key,
            label_selector=label_selector,
            namespaces=namespaces,
        )

        return typing.cast(None, jsii.invoke(self, "putPodAffinityTerm", [value]))

    @builtins.property
    @jsii.member(jsii_name="podAffinityTerm")
    def pod_affinity_term(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference",
            jsii.get(self, "podAffinityTerm"),
        )

    @builtins.property
    @jsii.member(jsii_name="podAffinityTermInput")
    def pod_affinity_term_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm"
            ],
            jsii.get(self, "podAffinityTermInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="weightInput")
    def weight_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "weightInput"))

    @builtins.property
    @jsii.member(jsii_name="weight")
    def weight(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "weight"))

    @weight.setter
    def weight(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7d204b8b3ddd7fbaa72932d194a1b323a6cf9c83348e0b8c7f3da6f22f820cf8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "weight", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c3fa515dbeb12e890a794316a96905a5c63e96beabf972f42e734bf8aa54ed6f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param topology_key: empty topology key is interpreted by the scheduler as 'all topologies'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        :param label_selector: label_selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        :param namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c78ab39fb0ced54741582cbf8ba0d5fa175de95a77c15ad21ea244555962d33
            )
            check_type(
                argname="argument topology_key",
                value=topology_key,
                expected_type=type_hints["topology_key"],
            )
            check_type(
                argname="argument label_selector",
                value=label_selector,
                expected_type=type_hints["label_selector"],
            )
            check_type(
                argname="argument namespaces",
                value=namespaces,
                expected_type=type_hints["namespaces"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        """empty topology key is interpreted by the scheduler as 'all topologies'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        """
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
            ],
        ]
    ]:
        """label_selector block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        """
        result = self._values.get("label_selector")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        """namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        match_labels: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        :param match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__955ad37c6d7e6439fda9868fa9b130a5c2008384813ea6bc7cb66545a60e0eea
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
            check_type(
                argname="argument match_labels",
                value=match_labels,
                expected_type=type_hints["match_labels"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
            ],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """A map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        result = self._values.get("match_labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af62793ed72bf5b86b339f5883ccb7ef30ea6b9d132d298d02d60ccc11983189
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__279306b45dcddc5c28635641eb2180e29015c0003e322b34b6fe6d14347138b5
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4502d3ee93e7c735b06424ea5475b1469addd64640e70117651f2018df3bf47d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7050e0030e4f05f50b4ecac8d765e9f481a378ddd44fa7e55233faac8e69b9c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__87fa116accbaa6acf7bd4fff1daa1eaa295aca1c18580faa279e64ff183f5e74
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac5f07a66082855b15e3ff0092dac8c0fa401834340c99b594fab7bbbee28acc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: An array of string values. If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0ffd6346a365ce46e90fd226b37af73c8259d7a72555aca5a527fba9edffa36a
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """An array of string values.

        If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a8f1a5df501dc1ef26274a1d3e1775416526c1acb9aff35acfdcf5d383a0f47d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b0c4a86ff25cbe0e15078726a5f1f64a94db6a0de15d435c7cb950045b0c1ea3
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d18fd4c366a1ffc34c452214baeecab133b0e826d057cc4d317f1bf9493d57e3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7dfb83d68a00839ae61dc904c7eb1c50d717874d11528113888a8c9fa03b53be
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2737f4b1bb4e9fd10ce766783c5d9894b3725747f7ecb4102fdc234b2197d35
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b76bd930f7314dacdae789cb90931a01dd34f71b6c75e839bb17daf4ff8a7f87
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3dcbfda91df6e94d75d8f273a84bf4b42aab11ca0174ab1dfecd3a4fa62b4a45
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__66fabaf4866bf70650a56b388dff2ab8f7c0611c8e4a038b7752361d3d0ff517
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4cc0a20473e8c7b7d3ad2610032ba9c056f245558016250d805e51c5a1f56cb0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0ca3a70e7ba212ffd118f41b8f4d8f5f70290b3ea60e96aceafd9630cc04cb56
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f194f135b48ef850d185bd9d5118de130cbc828d1571188b86fdd3c80b0ce029
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3524447c655d499044e9669998414d5a0321ae68778234da65ad56247572cbd4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__45e5f69de422e2337c0d9642b1d86c022ce1ce0a238eea68c8e72c1a14e6161a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @jsii.member(jsii_name="resetMatchLabels")
    def reset_match_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchLabels", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabelsInput")
    def match_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "matchLabelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabels")
    def match_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "matchLabels")
        )

    @match_labels.setter
    def match_labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__996a40af0ed844ec43c0e7412784044c7d79ac152be0de4b8f4a8d7fa5566ea9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "matchLabels", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a49c9600d4cf899ee7cdcfd124fa759ff25bf9d9c8a6361bed927f11e755f418
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca44dd978ac223389a0fdb69e1fdf61785db27a71981073a461955cffe4ee405
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putLabelSelector")
    def put_label_selector(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__daee4b73f1923d56334b37f6930bac6aeded421313b280fa4b7d6bc2b6ac50fe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLabelSelector", [value]))

    @jsii.member(jsii_name="resetLabelSelector")
    def reset_label_selector(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabelSelector", []))

    @jsii.member(jsii_name="resetNamespaces")
    def reset_namespaces(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespaces", []))

    @builtins.property
    @jsii.member(jsii_name="labelSelector")
    def label_selector(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList,
            jsii.get(self, "labelSelector"),
        )

    @builtins.property
    @jsii.member(jsii_name="labelSelectorInput")
    def label_selector_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "labelSelectorInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="namespacesInput")
    def namespaces_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "namespacesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="topologyKeyInput")
    def topology_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "topologyKeyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="namespaces")
    def namespaces(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "namespaces"))

    @namespaces.setter
    def namespaces(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9255c85e601ca7a229fd201181af4c98e7c1bb49cc0bdaade37942233f0d7979
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespaces", value)

    @builtins.property
    @jsii.member(jsii_name="topologyKey")
    def topology_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "topologyKey"))

    @topology_key.setter
    def topology_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7a3eae7260a1bf47074d663c1afedadfd6bb764f3033db81bf1f9cb3901b385c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "topologyKey", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a3480a16363e12ed8059f947cc81db5f4e295c949bb3b835f6c8a197b43e77fc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param topology_key: empty topology key is interpreted by the scheduler as 'all topologies'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        :param label_selector: label_selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        :param namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__28ae3a989bac0fcf02e4e7214c33dbeeac97321c62e602b61b7911fef46adaae
            )
            check_type(
                argname="argument topology_key",
                value=topology_key,
                expected_type=type_hints["topology_key"],
            )
            check_type(
                argname="argument label_selector",
                value=label_selector,
                expected_type=type_hints["label_selector"],
            )
            check_type(
                argname="argument namespaces",
                value=namespaces,
                expected_type=type_hints["namespaces"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        """empty topology key is interpreted by the scheduler as 'all topologies'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        """
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
            ],
        ]
    ]:
        """label_selector block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        """
        result = self._values.get("label_selector")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        """namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespaces DaemonSetV1#namespaces}
        """
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        match_labels: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        :param match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1051589d2cf10812c58bd07f71deb5e850eabb1878d39fe5f672934177a05d8a
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
            check_type(
                argname="argument match_labels",
                value=match_labels,
                expected_type=type_hints["match_labels"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
            ],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """A map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        result = self._values.get("match_labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b67657810d1ebac73830012d327c46b4ab92da9a85eaa73914a59b71242d088
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__95d13cc517c9611cb59efe71b98ed3e73407892025e8b873b13b8945f33f25d9
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0a6eab0df4d93c6f3e2009eacb369df5a6d495feea9e7d92fbe6b2649d4a1069
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f78d2ecce548c2e5c766df42369f539460ba9a593e28f1b5c2e3dad66571ed09
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__453c7ae1f6f48ec8d61a36ede9b9a71bcf3e48ef74b4f1da9ca936b2c8861073
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f800581210f94200c1ccca754b8003b4b447463b0ad67b1b61cd7d88fee5723
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: An array of string values. If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__58dd45f5b04e197487d09653d901086f5a1e0835cfe827929e31b47a0284197a
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """An array of string values.

        If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7cbcb60eea602fa82eeb16cf33682d5eb81d807528c9acc4be4a402fb88e5488
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__34e480368893dfbab47f3275164ebd8be6ca4338cdf8f92b57f03ccf439ea135
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1981eaa0c28e90d95a9f8a66de2abc0c386abbadd5e38567cc7911f301787e9e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__36657ee9b373194e785596195c8da6a1a404dc4c55759fe644dba91cfc14db0a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2054135c343a3cbbed25157657d0a8bc2d3a93e7745ad1db84b8b123ed3f72c8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1274faed5135e78b39cd7160e1df2cb77cd8655041ab749382cf462d0b877db2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__100873b00f8fd38fd4a7371a4360a61ecc7dc41b6f6896e03270a88d1ba229f3
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c80c7a035c37dfd76f50768ddb04ab1d47d49219f3dbb0463fb9eff8a4a96942
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__644f225d13c08d8141c87d5705c8a23a9d68b3d5107d047d15066125c0a2da9e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c16b7db231912611ed79fc905879bd38edf70b0dca031a819e330b3e84be8af1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0d539e9c0c1a7356646c265575351037f4edb88936b876fc363c0c419e1c8946
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__94e1f6d67d9bb5d0b3f373dd866d8103ea31a8dc1fc913bbe39e7ecc98ceef21
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9133d0dc71ae07459f13fe5b92b3a7c04754bad0947b7b41e7966625250ac680
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @jsii.member(jsii_name="resetMatchLabels")
    def reset_match_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchLabels", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabelsInput")
    def match_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "matchLabelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabels")
    def match_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "matchLabels")
        )

    @match_labels.setter
    def match_labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c9551b380c68a15796078a65694bf977cabd50faebad4dafc65f5bde76d0d65
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "matchLabels", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__177bbabeeb4a3bd7856e4da46e5ab4969e6d2698d9bd49f6640f0f3e12786c8e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f4ebb4dc3b7c7728eb5471ec1fba9d90d934c599ee76bcfd10c06b24662819e1
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9a35a86f18d2b5ef90091153f28085ec68e845f5b1cd295e688d596361c52653
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5be18ee90520e4c7c8508a0083c75443bb011522fe4854524940317fbe8398ef
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__197bda5cc37cc66380a7e2b8f532c791def73f18b7b6bfe16b0fd73ed839ff8c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd855e201dc3791102b29234e7c3ad11dc5c0b3ee985f5169186dac857764f36
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8a8f0bd15cfc341a5367dc41bba4cc7e3c65c70e444a4279c22a9b115c258aed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__61106720c78944794b0b01e14486d154f307d2bfb1b069b8045a1e11152a06ba
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putLabelSelector")
    def put_label_selector(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb2962da240fb191dd674ca81ed4020128933cd96dbc0d5d995d603c042ae3e6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLabelSelector", [value]))

    @jsii.member(jsii_name="resetLabelSelector")
    def reset_label_selector(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabelSelector", []))

    @jsii.member(jsii_name="resetNamespaces")
    def reset_namespaces(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespaces", []))

    @builtins.property
    @jsii.member(jsii_name="labelSelector")
    def label_selector(
        self,
    ) -> DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList,
            jsii.get(self, "labelSelector"),
        )

    @builtins.property
    @jsii.member(jsii_name="labelSelectorInput")
    def label_selector_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "labelSelectorInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="namespacesInput")
    def namespaces_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "namespacesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="topologyKeyInput")
    def topology_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "topologyKeyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="namespaces")
    def namespaces(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "namespaces"))

    @namespaces.setter
    def namespaces(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__875925dc5640eb411f6039839b6d19d56ee93b9393b3d0ebf8dafa5f030a0f9f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespaces", value)

    @builtins.property
    @jsii.member(jsii_name="topologyKey")
    def topology_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "topologyKey"))

    @topology_key.setter
    def topology_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4e5763d1f135cae22a775b55ebb09d79614c8d14a8c73430404a6d7295976c64
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "topologyKey", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b484be5da3f2041902baed765858780778bd6be08142114efc6c7ae0d4ac773a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainer",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "args": "args",
        "command": "command",
        "env": "env",
        "env_from": "envFrom",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "lifecycle": "lifecycle",
        "liveness_probe": "livenessProbe",
        "port": "port",
        "readiness_probe": "readinessProbe",
        "resources": "resources",
        "security_context": "securityContext",
        "startup_probe": "startupProbe",
        "stdin": "stdin",
        "stdin_once": "stdinOnce",
        "termination_message_path": "terminationMessagePath",
        "termination_message_policy": "terminationMessagePolicy",
        "tty": "tty",
        "volume_mount": "volumeMount",
        "working_dir": "workingDir",
    },
)
class DaemonSetV1SpecTemplateSpecContainer:
    def __init__(
        self,
        *,
        name: builtins.str,
        args: typing.Optional[typing.Sequence[builtins.str]] = None,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerEnv",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        env_from: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerEnvFrom",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        lifecycle: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLifecycle",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        liveness_probe: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLivenessProbe",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        port: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerPort",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        readiness_probe: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerReadinessProbe",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        resources: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerResources",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        security_context: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContext",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        startup_probe: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerStartupProbe",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        stdin: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        stdin_once: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        termination_message_path: typing.Optional[builtins.str] = None,
        termination_message_policy: typing.Optional[builtins.str] = None,
        tty: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        volume_mount: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerVolumeMount",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#args DaemonSetV1#args}
        :param command: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env DaemonSetV1#env}
        :param env_from: env_from block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env_from DaemonSetV1#env_from}
        :param image: Docker image name. More info: http://kubernetes.io/docs/user-guide/images. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image DaemonSetV1#image}
        :param image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/images#updating-images Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image_pull_policy DaemonSetV1#image_pull_policy}
        :param lifecycle: lifecycle block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lifecycle DaemonSetV1#lifecycle}
        :param liveness_probe: liveness_probe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#liveness_probe DaemonSetV1#liveness_probe}
        :param port: port block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param readiness_probe: readiness_probe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#readiness_probe DaemonSetV1#readiness_probe}
        :param resources: resources block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resources DaemonSetV1#resources}
        :param security_context: security_context block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#security_context DaemonSetV1#security_context}
        :param startup_probe: startup_probe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#startup_probe DaemonSetV1#startup_probe}
        :param stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin DaemonSetV1#stdin}
        :param stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin_once DaemonSetV1#stdin_once}
        :param termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_path DaemonSetV1#termination_message_path}
        :param termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_policy DaemonSetV1#termination_message_policy}
        :param tty: Whether this container should allocate a TTY for itself. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tty DaemonSetV1#tty}
        :param volume_mount: volume_mount block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_mount DaemonSetV1#volume_mount}
        :param working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#working_dir DaemonSetV1#working_dir}
        """
        if isinstance(lifecycle, dict):
            lifecycle = DaemonSetV1SpecTemplateSpecContainerLifecycle(**lifecycle)
        if isinstance(liveness_probe, dict):
            liveness_probe = DaemonSetV1SpecTemplateSpecContainerLivenessProbe(
                **liveness_probe
            )
        if isinstance(readiness_probe, dict):
            readiness_probe = DaemonSetV1SpecTemplateSpecContainerReadinessProbe(
                **readiness_probe
            )
        if isinstance(resources, dict):
            resources = DaemonSetV1SpecTemplateSpecContainerResources(**resources)
        if isinstance(security_context, dict):
            security_context = DaemonSetV1SpecTemplateSpecContainerSecurityContext(
                **security_context
            )
        if isinstance(startup_probe, dict):
            startup_probe = DaemonSetV1SpecTemplateSpecContainerStartupProbe(
                **startup_probe
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7f1e23571d5dc78f757d058844a17f40820de79a9bb372c6c8e8ae2b59b577e1
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument args", value=args, expected_type=type_hints["args"]
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument env_from",
                value=env_from,
                expected_type=type_hints["env_from"],
            )
            check_type(
                argname="argument image", value=image, expected_type=type_hints["image"]
            )
            check_type(
                argname="argument image_pull_policy",
                value=image_pull_policy,
                expected_type=type_hints["image_pull_policy"],
            )
            check_type(
                argname="argument lifecycle",
                value=lifecycle,
                expected_type=type_hints["lifecycle"],
            )
            check_type(
                argname="argument liveness_probe",
                value=liveness_probe,
                expected_type=type_hints["liveness_probe"],
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument readiness_probe",
                value=readiness_probe,
                expected_type=type_hints["readiness_probe"],
            )
            check_type(
                argname="argument resources",
                value=resources,
                expected_type=type_hints["resources"],
            )
            check_type(
                argname="argument security_context",
                value=security_context,
                expected_type=type_hints["security_context"],
            )
            check_type(
                argname="argument startup_probe",
                value=startup_probe,
                expected_type=type_hints["startup_probe"],
            )
            check_type(
                argname="argument stdin", value=stdin, expected_type=type_hints["stdin"]
            )
            check_type(
                argname="argument stdin_once",
                value=stdin_once,
                expected_type=type_hints["stdin_once"],
            )
            check_type(
                argname="argument termination_message_path",
                value=termination_message_path,
                expected_type=type_hints["termination_message_path"],
            )
            check_type(
                argname="argument termination_message_policy",
                value=termination_message_policy,
                expected_type=type_hints["termination_message_policy"],
            )
            check_type(
                argname="argument tty", value=tty, expected_type=type_hints["tty"]
            )
            check_type(
                argname="argument volume_mount",
                value=volume_mount,
                expected_type=type_hints["volume_mount"],
            )
            check_type(
                argname="argument working_dir",
                value=working_dir,
                expected_type=type_hints["working_dir"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if args is not None:
            self._values["args"] = args
        if command is not None:
            self._values["command"] = command
        if env is not None:
            self._values["env"] = env
        if env_from is not None:
            self._values["env_from"] = env_from
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if liveness_probe is not None:
            self._values["liveness_probe"] = liveness_probe
        if port is not None:
            self._values["port"] = port
        if readiness_probe is not None:
            self._values["readiness_probe"] = readiness_probe
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if startup_probe is not None:
            self._values["startup_probe"] = startup_probe
        if stdin is not None:
            self._values["stdin"] = stdin
        if stdin_once is not None:
            self._values["stdin_once"] = stdin_once
        if termination_message_path is not None:
            self._values["termination_message_path"] = termination_message_path
        if termination_message_policy is not None:
            self._values["termination_message_policy"] = termination_message_policy
        if tty is not None:
            self._values["tty"] = tty
        if volume_mount is not None:
            self._values["volume_mount"] = volume_mount
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the container specified as a DNS_LABEL.

        Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def args(self) -> typing.Optional[typing.List[builtins.str]]:
        """Arguments to the entrypoint.

        The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#args DaemonSetV1#args}
        """
        result = self._values.get("args")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Entrypoint array.

        Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerEnv"],
        ]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env DaemonSetV1#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerEnv"],
                ]
            ],
            result,
        )

    @builtins.property
    def env_from(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerEnvFrom"],
        ]
    ]:
        """env_from block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env_from DaemonSetV1#env_from}
        """
        result = self._values.get("env_from")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerEnvFrom"],
                ]
            ],
            result,
        )

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        """Docker image name. More info: http://kubernetes.io/docs/user-guide/images.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image DaemonSetV1#image}
        """
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        """Image pull policy.

        One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/images#updating-images

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image_pull_policy DaemonSetV1#image_pull_policy}
        """
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lifecycle(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerLifecycle"]:
        """lifecycle block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lifecycle DaemonSetV1#lifecycle}
        """
        result = self._values.get("lifecycle")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerLifecycle"], result
        )

    @builtins.property
    def liveness_probe(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerLivenessProbe"]:
        """liveness_probe block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#liveness_probe DaemonSetV1#liveness_probe}
        """
        result = self._values.get("liveness_probe")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerLivenessProbe"], result
        )

    @builtins.property
    def port(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerPort"],
        ]
    ]:
        """port block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerPort"],
                ]
            ],
            result,
        )

    @builtins.property
    def readiness_probe(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerReadinessProbe"]:
        """readiness_probe block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#readiness_probe DaemonSetV1#readiness_probe}
        """
        result = self._values.get("readiness_probe")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerReadinessProbe"],
            result,
        )

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerResources"]:
        """resources block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resources DaemonSetV1#resources}
        """
        result = self._values.get("resources")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerResources"], result
        )

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerSecurityContext"]:
        """security_context block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#security_context DaemonSetV1#security_context}
        """
        result = self._values.get("security_context")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerSecurityContext"],
            result,
        )

    @builtins.property
    def startup_probe(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbe"]:
        """startup_probe block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#startup_probe DaemonSetV1#startup_probe}
        """
        result = self._values.get("startup_probe")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbe"], result
        )

    @builtins.property
    def stdin(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether this container should allocate a buffer for stdin in the container runtime.

        If this is not set, reads from stdin in the container will always result in EOF.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin DaemonSetV1#stdin}
        """
        result = self._values.get("stdin")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def stdin_once(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether the container runtime should close the stdin channel after it has been opened by a single attach.

        When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin_once DaemonSetV1#stdin_once}
        """
        result = self._values.get("stdin_once")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def termination_message_path(self) -> typing.Optional[builtins.str]:
        """Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.

        Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_path DaemonSetV1#termination_message_path}
        """
        result = self._values.get("termination_message_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination_message_policy(self) -> typing.Optional[builtins.str]:
        """Optional: Indicate how the termination message should be populated.

        File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_policy DaemonSetV1#termination_message_policy}
        """
        result = self._values.get("termination_message_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tty(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether this container should allocate a TTY for itself.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tty DaemonSetV1#tty}
        """
        result = self._values.get("tty")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def volume_mount(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerVolumeMount"],
        ]
    ]:
        """volume_mount block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_mount DaemonSetV1#volume_mount}
        """
        result = self._values.get("volume_mount")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerVolumeMount"],
                ]
            ],
            result,
        )

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        """Container's working directory.

        If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#working_dir DaemonSetV1#working_dir}
        """
        result = self._values.get("working_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnv",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value", "value_from": "valueFrom"},
)
class DaemonSetV1SpecTemplateSpecContainerEnv:
    def __init__(
        self,
        *,
        name: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_from: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFrom",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param name: Name of the environment variable. Must be a C_IDENTIFIER. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        :param value_from: value_from block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value_from DaemonSetV1#value_from}
        """
        if isinstance(value_from, dict):
            value_from = DaemonSetV1SpecTemplateSpecContainerEnvValueFrom(**value_from)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__317eeede47caf294e5a3f9d1e4fa90670c965f6361a583e09efde41a7f1fde70
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
            check_type(
                argname="argument value_from",
                value=value_from,
                expected_type=type_hints["value_from"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if value is not None:
            self._values["value"] = value
        if value_from is not None:
            self._values["value_from"] = value_from

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the environment variable. Must be a C_IDENTIFIER.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables.

        If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_from(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvValueFrom"]:
        """value_from block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value_from DaemonSetV1#value_from}
        """
        result = self._values.get("value_from")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvValueFrom"], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_ref": "configMapRef",
        "prefix": "prefix",
        "secret_ref": "secretRef",
    },
)
class DaemonSetV1SpecTemplateSpecContainerEnvFrom:
    def __init__(
        self,
        *,
        config_map_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        prefix: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param config_map_ref: config_map_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_ref DaemonSetV1#config_map_ref}
        :param prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#prefix DaemonSetV1#prefix}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        if isinstance(config_map_ref, dict):
            config_map_ref = DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef(
                **config_map_ref
            )
        if isinstance(secret_ref, dict):
            secret_ref = DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef(
                **secret_ref
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc2599c373376ebeecd86fc4011ca44be0f9b9e1ccf26417b98b48ff478466bc
            )
            check_type(
                argname="argument config_map_ref",
                value=config_map_ref,
                expected_type=type_hints["config_map_ref"],
            )
            check_type(
                argname="argument prefix",
                value=prefix,
                expected_type=type_hints["prefix"],
            )
            check_type(
                argname="argument secret_ref",
                value=secret_ref,
                expected_type=type_hints["secret_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map_ref is not None:
            self._values["config_map_ref"] = config_map_ref
        if prefix is not None:
            self._values["prefix"] = prefix
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def config_map_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef"]:
        """config_map_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_ref DaemonSetV1#config_map_ref}
        """
        result = self._values.get("config_map_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef"],
            result,
        )

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        """An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#prefix DaemonSetV1#prefix}
        """
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef"]:
        """secret_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        result = self._values.get("secret_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef"],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerEnvFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__124be3c899ccee8792872e7c7daf20653a8dae9c76dc401dc0edf51434e64e14
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the ConfigMap must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d81a60599a76e3ebad73ae3a99e6c11be486dbe3e08f0b9acf72c80c5dc738ff
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__01d91428f5970c6b605c197dfa5900eee4d84eda44be6bcf0691b459fb306454
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__16b6c4044156e53b20afff85d4562542405db8fc9404dc1c01d5d1ed88decc26
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a111ec82199b2a4d57a4f594999a0087fa2ce466f85d0e437886a11a5c769277
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerEnvFromList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvFromList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3cb1ecf0eb029f7952f3f3c392fe309f5bca542f71812a5640cd87296c5af2d5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerEnvFromOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__41f3edad3a11b4c51fd0384aa41f722ed6bb2b55a1058d1cba49f9a0d84eeab0
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerEnvFromOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__55a4cd2a625c11005a9ec7ce801b6595d73cca187bc66f988f118a06e069170d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4ce8a9962f21fe85fcf51177f2ebb7437683cc8701fd8a37e22606e2d8b20677
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8fa2a540363e9cc9a4bb69cdb57c97351b1d8c8c0c51ddbd04163ce91cd969e2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerEnvFrom],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerEnvFrom],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerEnvFrom],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8596f0eb410b2f25ad5547b19287ef9615c5b1fa6cc6e5064d736e634aa52044
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerEnvFromOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvFromOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cddb463caf56f11db93f51cee5e88da790880cfd7f4aaecaf54a34f8cfb2791c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putConfigMapRef")
    def put_config_map_ref(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef(
            name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putConfigMapRef", [value]))

    @jsii.member(jsii_name="putSecretRef")
    def put_secret_ref(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef(
            name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putSecretRef", [value]))

    @jsii.member(jsii_name="resetConfigMapRef")
    def reset_config_map_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigMapRef", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetSecretRef")
    def reset_secret_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretRef", []))

    @builtins.property
    @jsii.member(jsii_name="configMapRef")
    def config_map_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRefOutputReference,
            jsii.get(self, "configMapRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretRef")
    def secret_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRefOutputReference",
            jsii.get(self, "secretRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="configMapRefInput")
    def config_map_ref_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef],
            jsii.get(self, "configMapRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="secretRefInput")
    def secret_ref_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef"],
            jsii.get(self, "secretRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__db8bf7bd08f7bc826223717d31235a94e33a7c0ebacaf22ebc9f6038db45ed1a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "prefix", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerEnvFrom
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerEnvFrom,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerEnvFrom
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d77c68f17a8cc7f8009ad08bf005849484c703f6b08d37f884a350af5c5e58dc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__295a950884f2e013c07cff618862d04016f9a9a2f5afd478e6e3379b1cca6f36
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the Secret must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__831f7d23347db4b1cdb888aaa6513fbffb3a1c1bc512ec0d84901a16e9db6685
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__33420a507753fc086aac3243bf3ab242705f8b75257841ccbded04ead64502dc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2ec4b56c94a524494c35859d8adfef43dabb97588a6e3338990bb697931d4e52
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d1a3ca4b8671bd8a09b7a7d16ba1887d0354acf4b58d25f1d364394e498f4dbf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2158c05383f4c949c37197e454f3c83bcee8263f7e6fccdf5c0e7791392512fc
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f7eb6cb8c87c5fab93b03f47547ac1ff6b6178a6c9efe5a52068bf496ade63b
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerEnvOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2c04a75c389fd795f5d5b8876e93755c177bf031cd25ab7b1e4df1df7979a326
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b9a59d59890f2e7003b5711a8899f530734fdd005fec4b163cecf02440693f44
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__331a0e2e1a71aeb20dee17052301615a8af33a10d887ea5f8747a606ff3f4ccb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerEnv],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerEnv],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerEnv],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__030cf2a68ef3f8a81dc724f9d377dc9217d27b147d6f4b8baa04d52ffbf9f7bd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__938dfcc320da56173c597d742ac90706597b8bc6538fabf3fb46e8f846de33a8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putValueFrom")
    def put_value_from(
        self,
        *,
        config_map_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        resource_field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        secret_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param config_map_key_ref: config_map_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_key_ref DaemonSetV1#config_map_key_ref}
        :param field_ref: field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        :param resource_field_ref: resource_field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        :param secret_key_ref: secret_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_key_ref DaemonSetV1#secret_key_ref}
        """
        value = DaemonSetV1SpecTemplateSpecContainerEnvValueFrom(
            config_map_key_ref=config_map_key_ref,
            field_ref=field_ref,
            resource_field_ref=resource_field_ref,
            secret_key_ref=secret_key_ref,
        )

        return typing.cast(None, jsii.invoke(self, "putValueFrom", [value]))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @jsii.member(jsii_name="resetValueFrom")
    def reset_value_from(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValueFrom", []))

    @builtins.property
    @jsii.member(jsii_name="valueFrom")
    def value_from(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerEnvValueFromOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerEnvValueFromOutputReference",
            jsii.get(self, "valueFrom"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueFromInput")
    def value_from_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvValueFrom"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvValueFrom"],
            jsii.get(self, "valueFromInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2f85fd793705ba70959480c65e729c3e561cbd6316871dbbcd5ac2f754c68772
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c8748d2c2c8042b46e9deb1f5453c8c31e06dc880d2ccf21c3a89ab3954b8bb1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerEnv
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerEnv
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerEnv
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__148922255009adf20d12d6a417df686e4ac2ff3b20eea2ca4da6b7564996006b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_key_ref": "configMapKeyRef",
        "field_ref": "fieldRef",
        "resource_field_ref": "resourceFieldRef",
        "secret_key_ref": "secretKeyRef",
    },
)
class DaemonSetV1SpecTemplateSpecContainerEnvValueFrom:
    def __init__(
        self,
        *,
        config_map_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        resource_field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        secret_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param config_map_key_ref: config_map_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_key_ref DaemonSetV1#config_map_key_ref}
        :param field_ref: field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        :param resource_field_ref: resource_field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        :param secret_key_ref: secret_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_key_ref DaemonSetV1#secret_key_ref}
        """
        if isinstance(config_map_key_ref, dict):
            config_map_key_ref = (
                DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef(
                    **config_map_key_ref
                )
            )
        if isinstance(field_ref, dict):
            field_ref = DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef(
                **field_ref
            )
        if isinstance(resource_field_ref, dict):
            resource_field_ref = (
                DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef(
                    **resource_field_ref
                )
            )
        if isinstance(secret_key_ref, dict):
            secret_key_ref = (
                DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef(
                    **secret_key_ref
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__275ca5d11f1eedbd55c469b0081bc9a30b40f7c03789de7979bfedc65337e69f
            )
            check_type(
                argname="argument config_map_key_ref",
                value=config_map_key_ref,
                expected_type=type_hints["config_map_key_ref"],
            )
            check_type(
                argname="argument field_ref",
                value=field_ref,
                expected_type=type_hints["field_ref"],
            )
            check_type(
                argname="argument resource_field_ref",
                value=resource_field_ref,
                expected_type=type_hints["resource_field_ref"],
            )
            check_type(
                argname="argument secret_key_ref",
                value=secret_key_ref,
                expected_type=type_hints["secret_key_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map_key_ref is not None:
            self._values["config_map_key_ref"] = config_map_key_ref
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref
        if secret_key_ref is not None:
            self._values["secret_key_ref"] = secret_key_ref

    @builtins.property
    def config_map_key_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef"
    ]:
        """config_map_key_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_key_ref DaemonSetV1#config_map_key_ref}
        """
        result = self._values.get("config_map_key_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef"
            ],
            result,
        )

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef"]:
        """field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        """
        result = self._values.get("field_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef"],
            result,
        )

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef"
    ]:
        """resource_field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        """
        result = self._values.get("resource_field_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef"
            ],
            result,
        )

    @builtins.property
    def secret_key_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef"
    ]:
        """secret_key_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_key_ref DaemonSetV1#secret_key_ref}
        """
        result = self._values.get("secret_key_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerEnvValueFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2b4453660279294306ae9899d47e28c2a5167c27f2a6e0782b2b51c20342bfc1
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key to select.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the ConfigMap or its key must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e3c3692de2163a2fcc8d0f800a324df1d65695b182cb4a0ab218f8c02dcca0bf
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c651a607f8f331739bcfca39655c46a1a4f59c98c48e87f0bc13323b363193e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d5948e9a41cf9f2cd3a9870a0602a3e48acce3ed4ff12f972fa33a05338be5d6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6b2bda68efe9eead709f38e75db8751f7caa6839e1bb39b142c6145cb89fe077
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c51445799c65fe4e3cb143bf1d60af440da265d560ca674e17b1a28a5ee9c3e6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef",
    jsii_struct_bases=[],
    name_mapping={"api_version": "apiVersion", "field_path": "fieldPath"},
)
class DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8e16025ed1f4bf9b3e62f9564185ca0e99a4fe75ee469fbbb18db2f1dc34fca2
            )
            check_type(
                argname="argument api_version",
                value=api_version,
                expected_type=type_hints["api_version"],
            )
            check_type(
                argname="argument field_path",
                value=field_path,
                expected_type=type_hints["field_path"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if field_path is not None:
            self._values["field_path"] = field_path

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        """Version of the schema the FieldPath is written in terms of, defaults to "v1".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        """
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def field_path(self) -> typing.Optional[builtins.str]:
        """Path of the field to select in the specified API version.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        result = self._values.get("field_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c799bac0b8950fa1a2f9243bc293b54be3dae1d424f19b891f0ef92971490e2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetApiVersion")
    def reset_api_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiVersion", []))

    @jsii.member(jsii_name="resetFieldPath")
    def reset_field_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFieldPath", []))

    @builtins.property
    @jsii.member(jsii_name="apiVersionInput")
    def api_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "apiVersionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fieldPathInput")
    def field_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "fieldPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiVersion")
    def api_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiVersion"))

    @api_version.setter
    def api_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c1025af248b8629d2e9159f831be6cf887d1ff2e6e892802295f428415643352
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiVersion", value)

    @builtins.property
    @jsii.member(jsii_name="fieldPath")
    def field_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fieldPath"))

    @field_path.setter
    def field_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb1ae160f19b9ad4f2f266115b324abb1c5bd1d48002c06b07f91369bdd94c51
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fieldPath", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__93590e61ddfb3d8c9db53397a5c665ae0ae58a4d234cc0fcc1178df791470f01
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerEnvValueFromOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__662109395a3bbc06a4a4a7614cda307f2157a0072672ddfdf57d7e58e508eb62
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putConfigMapKeyRef")
    def put_config_map_key_ref(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef(
            key=key, name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putConfigMapKeyRef", [value]))

    @jsii.member(jsii_name="putFieldRef")
    def put_field_ref(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        value = DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef(
            api_version=api_version, field_path=field_path
        )

        return typing.cast(None, jsii.invoke(self, "putFieldRef", [value]))

    @jsii.member(jsii_name="putResourceFieldRef")
    def put_resource_field_ref(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        value = DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef(
            resource=resource, container_name=container_name, divisor=divisor
        )

        return typing.cast(None, jsii.invoke(self, "putResourceFieldRef", [value]))

    @jsii.member(jsii_name="putSecretKeyRef")
    def put_secret_key_ref(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key of the secret to select from. Must be a valid secret key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef(
            key=key, name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putSecretKeyRef", [value]))

    @jsii.member(jsii_name="resetConfigMapKeyRef")
    def reset_config_map_key_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigMapKeyRef", []))

    @jsii.member(jsii_name="resetFieldRef")
    def reset_field_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFieldRef", []))

    @jsii.member(jsii_name="resetResourceFieldRef")
    def reset_resource_field_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceFieldRef", []))

    @jsii.member(jsii_name="resetSecretKeyRef")
    def reset_secret_key_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretKeyRef", []))

    @builtins.property
    @jsii.member(jsii_name="configMapKeyRef")
    def config_map_key_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRefOutputReference,
            jsii.get(self, "configMapKeyRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="fieldRef")
    def field_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRefOutputReference,
            jsii.get(self, "fieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRef")
    def resource_field_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRefOutputReference",
            jsii.get(self, "resourceFieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretKeyRef")
    def secret_key_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRefOutputReference",
            jsii.get(self, "secretKeyRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="configMapKeyRefInput")
    def config_map_key_ref_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef
            ],
            jsii.get(self, "configMapKeyRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="fieldRefInput")
    def field_ref_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef],
            jsii.get(self, "fieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRefInput")
    def resource_field_ref_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef"
            ],
            jsii.get(self, "resourceFieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretKeyRefInput")
    def secret_key_ref_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef"
            ],
            jsii.get(self, "secretKeyRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFrom]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFrom],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFrom],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8be1ab2144027c3aad284fbc1978c59b0b4fb358e8496d62be742ea402b84b11
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f6cf030d1c5c9d7a62b4ca094a3b1ca34692263b20140353857065776ce6200
            )
            check_type(
                argname="argument resource",
                value=resource,
                expected_type=type_hints["resource"],
            )
            check_type(
                argname="argument container_name",
                value=container_name,
                expected_type=type_hints["container_name"],
            )
            check_type(
                argname="argument divisor",
                value=divisor,
                expected_type=type_hints["divisor"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        """Resource to select.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        """
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}."""
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}."""
        result = self._values.get("divisor")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f76ec169d4ee25655431739a25a94adbc2eb718cf2bd025543531b707728d860
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetContainerName")
    def reset_container_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerName", []))

    @jsii.member(jsii_name="resetDivisor")
    def reset_divisor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDivisor", []))

    @builtins.property
    @jsii.member(jsii_name="containerNameInput")
    def container_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "containerNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="divisorInput")
    def divisor_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "divisorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="resourceInput")
    def resource_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "resourceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="containerName")
    def container_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerName"))

    @container_name.setter
    def container_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a59b3217b773d7a277c9bf49a96012c320c066feae450acc52c526317ef9290f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "containerName", value)

    @builtins.property
    @jsii.member(jsii_name="divisor")
    def divisor(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "divisor"))

    @divisor.setter
    def divisor(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6ab1aad8bfa602765ecc898f40ddf47ad23ab76ffe8131394c5a07f6ccec679f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "divisor", value)

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resource"))

    @resource.setter
    def resource(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__59b4c33f8b8e0946f48d85d2ac98589b20af60d861c60c9ebe49919fd4fff7a2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "resource", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6738e8f5763e96fd868bbf8a881b5a4d45675fa698251a26f54813280663ab5b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key of the secret to select from. Must be a valid secret key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f5daadd9e696f07e4ca70f527be478598d7b7a0b22a6bb672d9e3648b56576e2
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key of the secret to select from. Must be a valid secret key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the Secret or its key must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9cb6bc6789454eb49be2ddbf724acb94375d75a4824dbddc668e360805289b95
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__66fd93d57fbf7d198b4e1dd55a747f7460cc0b8ffd06ec2f7902ddeaf0d2585e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bec3ea3cbd5b9ef7ae1782e2a071924b805640f6efa3f498959f683ab3675c74
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d8c39ae16c6e0792587f6a2586a1b63b74679248a8a85637f1051c1fb6760337
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7b7b80b24322f0b4124310efaa7c63f4b13947e070a8186005e611582553fd6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecycle",
    jsii_struct_bases=[],
    name_mapping={"post_start": "postStart", "pre_stop": "preStop"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecycle:
    def __init__(
        self,
        *,
        post_start: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        pre_stop: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param post_start: post_start block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#post_start DaemonSetV1#post_start}
        :param pre_stop: pre_stop block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pre_stop DaemonSetV1#pre_stop}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6ad1354116c7f039792eff80d33e1268cb6da40c7ac9430878790a0ca8fdda96
            )
            check_type(
                argname="argument post_start",
                value=post_start,
                expected_type=type_hints["post_start"],
            )
            check_type(
                argname="argument pre_stop",
                value=pre_stop,
                expected_type=type_hints["pre_stop"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if post_start is not None:
            self._values["post_start"] = post_start
        if pre_stop is not None:
            self._values["pre_stop"] = pre_stop

    @builtins.property
    def post_start(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart"],
        ]
    ]:
        """post_start block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#post_start DaemonSetV1#post_start}
        """
        result = self._values.get("post_start")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def pre_stop(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop"],
        ]
    ]:
        """pre_stop block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pre_stop DaemonSetV1#pre_stop}
        """
        result = self._values.get("pre_stop")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop"],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerLifecycle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerLifecycleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecycleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__70675043a63c8d8c371635782652436284fdc0c641ecf980cc9eebd8a6e0b590
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPostStart")
    def put_post_start(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0e423abb8cdc581c3322a2c6c114f85582bffd25f9cc6e8bb0970a59b3086c90
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putPostStart", [value]))

    @jsii.member(jsii_name="putPreStop")
    def put_pre_stop(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4529cbd2903fc43235874d0463e2772cd923b692c112b6c41d86b51793283c7b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putPreStop", [value]))

    @jsii.member(jsii_name="resetPostStart")
    def reset_post_start(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPostStart", []))

    @jsii.member(jsii_name="resetPreStop")
    def reset_pre_stop(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreStop", []))

    @builtins.property
    @jsii.member(jsii_name="postStart")
    def post_start(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartList",
            jsii.get(self, "postStart"),
        )

    @builtins.property
    @jsii.member(jsii_name="preStop")
    def pre_stop(self) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopList",
            jsii.get(self, "preStop"),
        )

    @builtins.property
    @jsii.member(jsii_name="postStartInput")
    def post_start_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart"
                    ],
                ]
            ],
            jsii.get(self, "postStartInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="preStopInput")
    def pre_stop_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop"],
                ]
            ],
            jsii.get(self, "preStopInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecycle]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecycle],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecycle],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8515d8ffc73816dc0cf73414efc0445c19329574aff952e72678ca72dc6bceba
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__61e70e375b24bf441756d1d91c411216953c366e3725eb1d9b29194f4527966f
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec"
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet"
    ]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet"
            ],
            result,
        )

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket"
            ],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4385d70c70a556e1671a333e4619e244364d043f9d1cec9b2a26a5ce709035af
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__486c0ed6099f2501586535b7036f9c6ec74a37028a63c81ee354b4749a7255c4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d8246f446e01ec7d628c462deb0743846e06b0f2160f94f2245acc5210ba793b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ead5942707e4545620f27592c43ef3b794c64420e7625f34afbfb147ac45a941
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8e358d049e5571afb6ef97f89cebc6b88db92e87c5bebaa2df2ec604e2bbd47d
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2663f3a8c572296ae29638573cde50912e9fc5dbafc2cedd8765eef4ffd1e7fe
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__917efeb0cd194fbd7e3e262b03b63d3d4922f5222e6c6c681a9450858b5de69c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bedbae2236caed4c8e78c283c51d63a65ea167e7615605d9bf886654e2acb1a0
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8a4532ec46a6c0fd2b130fa69cac000263a5949d438ed5ff099c3639f16c47a7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4604b684cd9bcd6cb26830475f80a9adafca0bbf451ee319656bab559f56cf4a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1010855027c1d716c3c825f54753688215b5315a441a5e2cc87b898c96658676
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9e7c3e4ca407ff31d7a485462db50eb24e7de99cf0b3bfd9830e33d9b081b2e1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97932ffdf65e791cd834b332b20b6892f4735f33a078d1a2e4d937355f6f56ba
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc31b99b5c4ce90f15c3eaa3312151b50a0956b583573968fadf426a96141122
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac821fec7d4a475109acf99a0629139f5c7d43cf89f6fbfa2d30d35adf29f97b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__07e4f95abe119a0d3b18ed6799107b906a028f61f7cfeeca058345cfb6a0cb52
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__686914d053e47831f5829a90c2f6c5d48956678589083e36ae257f741c62005b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e693563e18e9e82361df9953bee0497367bcc4311a30a899b67f5740c2f66b34
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0ae6ce3e011923a57341a8355d7376936ea7d4368d6486e08c40029fdd45f77
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1938bc1bfa25f83e16ce4e23d84c3c81f12f1071654e04b3914b8e1a7e64d95c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__02ad808017f20683810fdc58b45dc5af57cf59cbd583c03259da2ef054ef70f9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f9fee8eb2abbbaffccf034ad6d4e7ed7f4c545eb7e2484e14bc8fe54c39f95c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1dbe27bcd107d318a378f7e444eaafb10c6d6f0b2c6a7c86e9f6e46ad3af4259
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4bea5f8023268f3b2f5efd38bc8ce6f2d5f01191bc77cc6500470a99a7aa2cbf
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__def3e03056769d9550040aeb71dfb0cda36f851f1936adbc11270362c88bbaf3
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ea20dc11e98fbd27e560547695c9fc1473fa1de1c053a8738fbffe2b6c4e25e0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dfefc4ba89d4789bb804be425292528684aca6a90879f0e72ef52571e1e962be
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2909158d81998b76ef10b6cf69553f17ea7a7a5cf805a03b3a53287f79038bf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__042360cf993ad5750d0a9655f9a94e6c78835ac2b484d35f4e352c8bcabbd092
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a8c14a5242b87fbaff2c24d8586c11e410323997d7b5da2f6c383d988590439c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec(
            command=command
        )

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__26a28c517cf6abe20402a0c7acdc02f1c1d29430448dcfcd5449c7b9f7aac8d3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet
            ],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d49dade93422dd00ae1a59964402371fbdb16404bf09fa6b24fddda235e1bf7e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c8b002e24223580645afaf370f927ccd648cc748a6e3390b711a880bd5762e0
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5c04207fbfa3e9af14890f544c0231f5349a1c6c1cf1be24e5aa1a9249fcec03
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> (
        "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketOutputReference"
    ):
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8fa9abb5bccead026437a47bd0b0f214dc999f54b922ee3daec1123fa3b6efdd
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__31a456c981c71d73e228405310e1a88bc5d4c0af6bdb57089c8023f510995803
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d2aa078b5cd2f63f244553c1eba837e6d4192a72179b800b033082bc4f03d26a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__835197e8006c5f7ce9bc6689efbbfbb70c6a9c421b7430bfa9e7aec49d887b41
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b1c990b77410c46c2dc670c54994474df4648743063f25f221f435bcc991e499
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__928cf40c1fce2ce8a6517d3bf253f21269d010da94b4c9816281abbfe009bb96
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__78d515b3caeb3dd9b972a9cd1872a1c310fc959c92b48017051becb55f1f1410
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5f59c2d78cceff45e8d864a2e76910d2da4f69e299f89088654ae3dd02e286e5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__507cbfbe1820c3f332878ca546154a5070bbc1c7d144b429813f0563509fb5f4
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec"],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet"]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet"
            ],
            result,
        )

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket"
            ],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__558fe00b8c0de2030787e0b9a1a517a23fa83f33c584fd1d41d67c55ce4db7d9
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2ffc0225a1c9d0ba9c69ff1f6bbc2bfff10b9885a7923108c657dbc6481bb635
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1117b9abc8a17c97d2e650870b98cc28e990c746b49b95e153dcc3ceccafad73
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e25ac151185095632e8001fdd5b79cfd0624ea1be43ee94cbda22fc5bb30451c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8612c8c4b570e13649bc750e497ddc02833ec71bc1f4fec1230ff8a14994857d
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cd366bca4342dbf98bc846c4997931c042a57de4a954cac0f859564b41045ca5
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1aba151892b8f325ecd51d5584c2d748cb69d1f1c66bdf4f83c469936324b1de
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__26786e3f76f37fb65ac443a5cc8fbac2cd05882866ea384380e77cbedbcf00ed
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__67b232d53ad5f32371397963e264661f828319494de1a5f7d627086cf784cd46
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fc60cd9ff724a5185caf3e242a6ed07ee4d458a80908841ae17ae375d1903ad1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__110b6aa4465f5189433d2a1e95cbaf12f07086a7f0cb5b45049bc8c59ac5379a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7aab91da869f3cfc508f2cef394c4173be8121d51ec107682646d27d2da94ae5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3eda652fc2986e42f0f918dc1c65fc9a93c2900534ca942e7d613300c2e8dac0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d9ec9ee2b7170b28a1dcc37155a6f2724c0a5ce0a59288d8b552c7c9efab0a62
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca36cf45d58e67c93f81cd478aeac467f3eba108bf766eddc07b76e1323f3e36
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dce5e53c8b69c0179e39304ef3474b90e5d9169bd6f4b6ca2da2fbf095d97c6f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__154150826539d5de9a63303285b66c10cd830828d9f48c7501fcb57ea4414376
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b8d1c6834cf0aac1459243fdd433bced141666893a136a1cb1c1580825ba809f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15403ece7b7dcc6ec66d22b22f32c6f964498324cdff8411f46d363bac5a64cc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b5c1a1a3086b6a6ff97beceb6d546eeb2516db2feaf6dd9c8c8524bf3b04c1ae
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e0249fe6f6adbfd39e0598e6174c309275f611e08511f92780d0cc2a041c61ae
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__04af64c37e4fc9e1b63beb27966a4092c286380ac279bc456a399709d72883e6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6131b951afc118c1502f5061c6c3d749b779e5012dfbb150ff7cdbb407b11b4a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__243597c9056dcd0a7caf1d9b1b6b83a0fcc6f31ef619e3f09ccad415964fa564
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e77c62659fb08dc8b6b3abcbd668fcec30eb859c086227a1e92c54499de5a137
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__657aacd2a6ceae495117abbdc9fc4afaf371dbf0e9411a2e963f577a73f2eb4f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a2548d5850ae7323a42eedb50a3fc5e3c1d0ac7e93044f0842ff7ee8e00ceb94
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba81a8779d5746e5ed2a6524afccea6d62cf8533031099caccba6f11fc997a72
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0efacaad67a101ec9371634621c2376acf3186012bc7c1a82a0510c9fd257c79
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f4284b5a59dd6bcfd52cee622c2f1fc9bc84f6d717f5a87863c8a74a19b3df6c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec(
            command=command
        )

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__20f2c025baa5296bba7b3a7e09a60c7465a81c64517b1d3fbe3c103876bab676
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet
            ],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b03b8d135e57bf67371b318983af357f1d7e4f3680ef109c91e3a53a16811c7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__73fc11a5c05fcee349b186e243050946ae9b0887a612a86ff40efa8563f209f9
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fe3a7a5bfa4ec9c2c8b1a3651d536233468273d18c9b74308c7c316ccd4b3aa4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__936dd1290170ee1a59bfc22f3ec35e784b81a2d6d933a2e5c78e82cef3dd3a3b
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8adc8778073e3f5db5863f43bfae69765d816470a2309c4e085448b69b658586
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dcc36e8f9eeaf14ea38a9dd92fd26d1f4018e56915d6a682179a933bc0633d3c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__470e0d4b814d1fd028ae758a34e47b4db4acdbdf16615885ee5da94076ea885a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__50056b35d2d1f74ca603b53789943a20dbebd3831e58d78b329934675486cabb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a649fa84437024fb050145312f1af3d888e8c85e6b5a8a2d7d659addafd7edd1
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__015ebca9a2b2b1bac8f82418d89c3712390c0fabbd852b54e34ced4fda86c0a1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2d41076a348a622ce480256771b87d7ec0aa807da35b202bcec151eb2603397
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b306404787adb025335a8d228e115bbb5a53ecb8a554f96f6026d69c8e653c94
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cb0db4d7c469ccc5df221fe203f4248e1462ad7a5ce64d1bc1d7406148b1ef74
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e51fa0fafe6fa9111c1e27beb4f6b11de555db10dc0bd0dbc6737108c25da83b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__294db7de8fe698a109b2ffa00fe8f404a9a997b4cc0019572f51c9646d830684
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f6350433424ec80844bee682c5f1eec1f09f356451dd5c5af645dcf9fa79980f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainer],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainer],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainer],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__79da1e0e71981e2a656f023b6a201246454f50b131f51e8d64e3e88761a27fd1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "grpc": "grpc",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class DaemonSetV1SpecTemplateSpecContainerLivenessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dc7249cff440f505e95b4f2a5561ff2065ad9c15b40c9ffa95754c6aa64df005
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument failure_threshold",
                value=failure_threshold,
                expected_type=type_hints["failure_threshold"],
            )
            check_type(
                argname="argument grpc", value=grpc, expected_type=type_hints["grpc"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument initial_delay_seconds",
                value=initial_delay_seconds,
                expected_type=type_hints["initial_delay_seconds"],
            )
            check_type(
                argname="argument period_seconds",
                value=period_seconds,
                expected_type=type_hints["period_seconds"],
            )
            check_type(
                argname="argument success_threshold",
                value=success_threshold,
                expected_type=type_hints["success_threshold"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
            check_type(
                argname="argument timeout_seconds",
                value=timeout_seconds,
                expected_type=type_hints["timeout_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if grpc is not None:
            self._values["grpc"] = grpc
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec"],
            result,
        )

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive failures for the probe to be considered failed after having succeeded.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        """
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def grpc(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc"],
        ]
    ]:
        """grpc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        """
        result = self._values.get("grpc")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet"]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet"],
            result,
        )

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        """
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        """How often (in seconds) to perform the probe.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        """
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive successes for the probe to be considered successful after having failed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        """
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket"],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerLivenessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0be1a654f75f13325fdaa5f16d1db10731298e2e3b28acca568458212861e97b
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__576db149aa482042ec14bd5b4533e72b3f63704b28f841de8a9d00f985b3badf
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ae024c2912524f59610fc3a31d4bf6722576962bf72ea309439f50d62324ff1e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__51cb74cd7d530dc0ec87102aaa660951be6b29d9efbd5e03a7a705bda630e55a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "service": "service"},
)
class DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc:
    def __init__(
        self,
        *,
        port: jsii.Number,
        service: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param port: Number of the port to access on the container. Number must be in the range 1 to 65535. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__23c5a6f69ddc2d9cf0b046b635ccf6ffc6db62a3a1caa6339750827c8a8bc138
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument service",
                value=service,
                expected_type=type_hints["service"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }
        if service is not None:
            self._values["service"] = service

    @builtins.property
    def port(self) -> jsii.Number:
        """Number of the port to access on the container. Number must be in the range 1 to 65535.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def service(self) -> typing.Optional[builtins.str]:
        """Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        result = self._values.get("service")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__42f17f2239c1fc69262684363c50dfd1179c37460f9f71dbf05a8244c46b958d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__728165761d7a53b41c244567b276c62493dcb804a615cc430663be9aa198733a
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a0b7550a5ecbda41dd219e760fc61413f1757835fcdeb81d5f89ae0070760360
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7103e57b91a20eff307cdc74c1ce569bf4c68f64e20eb0b525886c8aac4bb060
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c421adf73c3e6e0d6f244a7ae5b28ec247e1ff27f92307698b8634cb0ffa4ba7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f737125a9a0b8aa18578f1e18a1d78e1f605661d912b97544fd226b6ff154f08
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c25ac3b62faba601f4d5ccf61ebc1a38521ec3ede242b82998d3228e40af016b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "serviceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__589802c073a4225695b750c1d2d59dfa94c92c8fd5eb76662fa3dccc2d369b28
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "service"))

    @service.setter
    def service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__96b752e699b8f8f9efefcea4d65fefc0e1e6e84eb56d5e938d9682b69f9d677e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "service", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2d5383fefc50a045d8951c70a0d83ab44ea832dd85ffc63b2d969434d3d59d5f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b09d70f7ce3e3234347c41fd7a8c6d6cecd53500ebd9666a08a6ba5f95256c09
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__17fa4e6ab61981d004afc9c5c54366c9e99ac23ac7a4381b9058579d62244107
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2ac188db8f13976d89dcb432855a9c5247dfe5fd55e553babf3a2f07fa029a14
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dbd1b833681e40d3126facf0e035779cc132e1c50b67febf058352f728ddfe8e
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8e2507fad11cd8ab14dad2ac2fffcf0fc746079de7ea9d11aa3386ec40353da7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__272196b00415dd3194dfe712536d47f5fb1a7d8544ea94788f7fa7ea24022027
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bbecf5ce49763969c246018ac15d9f87248e890fe4114a467d66b2be058c02af
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2836542dfe65ec7d691716163b900d8095a3c1d54669250bb5d8a59a8423f110
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__34331321b8cef98ed64fe7295b118ce3bb4d609cb63bb4daf70674126799ff98
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f35913ffea21e7ec6df38ed92036a55a78e272c2bc76af8317a8e44974e80b64
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c1bb355cab160540585c83799fee7e6aab1da50221e0b976c4b5f78b76513075
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a59709e75fe3098d177c0ed9895e2bc43901522affea0c1c4717872b1a35b856
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__28858bac9bb87f48d537711a70ee73d8d7a74a04bc7a24f4dfc38252c8025df4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__09d0061816afd77aca178f21ea19b470488a0b8c3ada646663ba155ab2075012
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c0515f6e1918c673fd8dffe959d5e6f53f464b3936f69b28485a718484d4b1ee
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c19aabd43a1960382fd0b8e2b586aacb961ada7548a18de4f829f9be2c5e3ea3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a447f33c6cb546b6e77b53e03c96bef1261e372123781c5113d10b5919995a98
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0c9c0c54427c37c6ad076d558bf78416c9a2bc45dbe28012bd439e7dd27e12cb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d169e16a9d9321f48d35761a4a2429a2a22ba3559fea021dad1f54ca2be5da72
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__01d9d24743acc86ee530c45c55da9e34fb4e4184007ee8e2047cf4f33d9480fc
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec(command=command)

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putGrpc")
    def put_grpc(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__137d78e44b3e483c04fb3014f2eed8b06473c5674297a479d2b176d69c5f5e39
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putGrpc", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d3ccd9c6516f85ec27cff72b76d9c438596c7758f927c3e74d08bed6f5f18775
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetGrpc")
    def reset_grpc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGrpc", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLivenessProbeExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="grpc")
    def grpc(self) -> DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcList,
            jsii.get(self, "grpc"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="grpcInput")
    def grpc_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc],
                ]
            ],
            jsii.get(self, "grpcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__490b66aac58bc9ea1ee447af1dcf8e1d0e931f38c1809f5f9ad1f9213b097413
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "failureThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__70185ada5f430a700454cb82de654979fad806c2418fd74dc64a510587548942
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "initialDelaySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a99ae6ce44c5f67bfe61cbe29ce4dad0cc2e11219dbb833d1381e13aaad20e53
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "periodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0991eb4023d930f6e85003be1e03178f6c8ec0f72a2d18900520a6e492d3dd3d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "successThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2604ec37c5cf765db49f0321f5a19b20e5984f19477df03f934f1b32f9d5a8e3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "timeoutSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbe],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbe],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__136a58f8b00c763cf04cfddfef75065e029a39d87f56ae53865515eb21c85046
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f48518be4a4e11e46b2900e71bbfafd1fe10d491a95869fa6362d94204003421
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__263a28ec3135ff5b50b95b21575f135e593e2487f19c7f5a282e18cf35e610f5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5f97bea58e22a3323137a7624ece3086e1036e0efb8d4fecb1e11fd8de6066f7
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7914deccb804727ee9589a44ac7e8a0dc4bbd879dc4d2b665ef95c63a6b42991
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__78c2178cbeeb038ad7dfb37987bb794c898508f50d37019943bafb46ac7cd639
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__96586c4b2304db10c212120c648f0ba96182fc4fff9cb557468802518fcd65c7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__150af953f02aa933535fe977882c691c8671c913a287bca9d43213c58b313e29
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a09230202b1ee41763d289925aaf390634512660fc5bb4dea51dd24cbb682cad
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__89db535aae1d13cb6a418335560a252e018a464571b50d19fe99358cade9088d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ea5a8b4eaa1d26078394f37753af1aa6df51111d5b83cd85e342b08e7da161e4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__27b30c9a03231611caaab277fdeaba4f803f52e23ccf265d55eabb906dba61cc
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerEnv,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__37eadce319e6787e2f3385376af58acac5e4bfcc1ee79d9267cb6593f80cd628
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putEnvFrom")
    def put_env_from(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerEnvFrom,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1615c18efdceaa247d84aa616a7a4b7cc206cf7e05b0838ba1bdfe0538ce6f6c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnvFrom", [value]))

    @jsii.member(jsii_name="putLifecycle")
    def put_lifecycle(
        self,
        *,
        post_start: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        pre_stop: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param post_start: post_start block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#post_start DaemonSetV1#post_start}
        :param pre_stop: pre_stop block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pre_stop DaemonSetV1#pre_stop}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLifecycle(
            post_start=post_start, pre_stop=pre_stop
        )

        return typing.cast(None, jsii.invoke(self, "putLifecycle", [value]))

    @jsii.member(jsii_name="putLivenessProbe")
    def put_liveness_probe(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        value = DaemonSetV1SpecTemplateSpecContainerLivenessProbe(
            exec=exec,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putLivenessProbe", [value]))

    @jsii.member(jsii_name="putPort")
    def put_port(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerPort",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aff4a832b50ba68fa8ab1b75df50eca8cb5eeaa904c2fa895c120507499e439b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putPort", [value]))

    @jsii.member(jsii_name="putReadinessProbe")
    def put_readiness_probe(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        value = DaemonSetV1SpecTemplateSpecContainerReadinessProbe(
            exec=exec,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putReadinessProbe", [value]))

    @jsii.member(jsii_name="putResources")
    def put_resources(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        """
        :param limits: Describes the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#limits DaemonSetV1#limits}
        :param requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#requests DaemonSetV1#requests}
        """
        value = DaemonSetV1SpecTemplateSpecContainerResources(
            limits=limits, requests=requests
        )

        return typing.cast(None, jsii.invoke(self, "putResources", [value]))

    @jsii.member(jsii_name="putSecurityContext")
    def put_security_context(
        self,
        *,
        allow_privilege_escalation: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        capabilities: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        privileged: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        read_only_root_filesystem: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_group: typing.Optional[builtins.str] = None,
        run_as_non_root: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_user: typing.Optional[builtins.str] = None,
        seccomp_profile: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        se_linux_options: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#allow_privilege_escalation DaemonSetV1#allow_privilege_escalation}
        :param capabilities: capabilities block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#capabilities DaemonSetV1#capabilities}
        :param privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#privileged DaemonSetV1#privileged}
        :param read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only_root_filesystem DaemonSetV1#read_only_root_filesystem}
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        :param seccomp_profile: seccomp_profile block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        :param se_linux_options: se_linux_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        """
        value = DaemonSetV1SpecTemplateSpecContainerSecurityContext(
            allow_privilege_escalation=allow_privilege_escalation,
            capabilities=capabilities,
            privileged=privileged,
            read_only_root_filesystem=read_only_root_filesystem,
            run_as_group=run_as_group,
            run_as_non_root=run_as_non_root,
            run_as_user=run_as_user,
            seccomp_profile=seccomp_profile,
            se_linux_options=se_linux_options,
        )

        return typing.cast(None, jsii.invoke(self, "putSecurityContext", [value]))

    @jsii.member(jsii_name="putStartupProbe")
    def put_startup_probe(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerStartupProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        value = DaemonSetV1SpecTemplateSpecContainerStartupProbe(
            exec=exec,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putStartupProbe", [value]))

    @jsii.member(jsii_name="putVolumeMount")
    def put_volume_mount(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerVolumeMount",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__22693631977df2961de293fb25e7852f3eac308ede51beb42022533f15d981c4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putVolumeMount", [value]))

    @jsii.member(jsii_name="resetArgs")
    def reset_args(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetArgs", []))

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvFrom")
    def reset_env_from(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvFrom", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetImagePullPolicy")
    def reset_image_pull_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagePullPolicy", []))

    @jsii.member(jsii_name="resetLifecycle")
    def reset_lifecycle(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLifecycle", []))

    @jsii.member(jsii_name="resetLivenessProbe")
    def reset_liveness_probe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLivenessProbe", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetReadinessProbe")
    def reset_readiness_probe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadinessProbe", []))

    @jsii.member(jsii_name="resetResources")
    def reset_resources(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResources", []))

    @jsii.member(jsii_name="resetSecurityContext")
    def reset_security_context(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecurityContext", []))

    @jsii.member(jsii_name="resetStartupProbe")
    def reset_startup_probe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStartupProbe", []))

    @jsii.member(jsii_name="resetStdin")
    def reset_stdin(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStdin", []))

    @jsii.member(jsii_name="resetStdinOnce")
    def reset_stdin_once(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStdinOnce", []))

    @jsii.member(jsii_name="resetTerminationMessagePath")
    def reset_termination_message_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTerminationMessagePath", []))

    @jsii.member(jsii_name="resetTerminationMessagePolicy")
    def reset_termination_message_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTerminationMessagePolicy", []))

    @jsii.member(jsii_name="resetTty")
    def reset_tty(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTty", []))

    @jsii.member(jsii_name="resetVolumeMount")
    def reset_volume_mount(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVolumeMount", []))

    @jsii.member(jsii_name="resetWorkingDir")
    def reset_working_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorkingDir", []))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> DaemonSetV1SpecTemplateSpecContainerEnvList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerEnvList, jsii.get(self, "env")
        )

    @builtins.property
    @jsii.member(jsii_name="envFrom")
    def env_from(self) -> DaemonSetV1SpecTemplateSpecContainerEnvFromList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerEnvFromList, jsii.get(self, "envFrom")
        )

    @builtins.property
    @jsii.member(jsii_name="lifecycle")
    def lifecycle(self) -> DaemonSetV1SpecTemplateSpecContainerLifecycleOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLifecycleOutputReference,
            jsii.get(self, "lifecycle"),
        )

    @builtins.property
    @jsii.member(jsii_name="livenessProbe")
    def liveness_probe(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerLivenessProbeOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeOutputReference,
            jsii.get(self, "livenessProbe"),
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> "DaemonSetV1SpecTemplateSpecContainerPortList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerPortList", jsii.get(self, "port")
        )

    @builtins.property
    @jsii.member(jsii_name="readinessProbe")
    def readiness_probe(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerReadinessProbeOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeOutputReference",
            jsii.get(self, "readinessProbe"),
        )

    @builtins.property
    @jsii.member(jsii_name="resources")
    def resources(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerResourcesOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerResourcesOutputReference",
            jsii.get(self, "resources"),
        )

    @builtins.property
    @jsii.member(jsii_name="securityContext")
    def security_context(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerSecurityContextOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerSecurityContextOutputReference",
            jsii.get(self, "securityContext"),
        )

    @builtins.property
    @jsii.member(jsii_name="startupProbe")
    def startup_probe(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerStartupProbeOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeOutputReference",
            jsii.get(self, "startupProbe"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeMount")
    def volume_mount(self) -> "DaemonSetV1SpecTemplateSpecContainerVolumeMountList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerVolumeMountList",
            jsii.get(self, "volumeMount"),
        )

    @builtins.property
    @jsii.member(jsii_name="argsInput")
    def args_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "argsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envFromInput")
    def env_from_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerEnvFrom],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerEnvFrom],
                ]
            ],
            jsii.get(self, "envFromInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerEnv],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerEnv],
                ]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageInput"))

    @builtins.property
    @jsii.member(jsii_name="imagePullPolicyInput")
    def image_pull_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "imagePullPolicyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="lifecycleInput")
    def lifecycle_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecycle]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecycle],
            jsii.get(self, "lifecycleInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="livenessProbeInput")
    def liveness_probe_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbe],
            jsii.get(self, "livenessProbeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerPort"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerPort"],
                ]
            ],
            jsii.get(self, "portInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="readinessProbeInput")
    def readiness_probe_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerReadinessProbe"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerReadinessProbe"],
            jsii.get(self, "readinessProbeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourcesInput")
    def resources_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerResources"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerResources"],
            jsii.get(self, "resourcesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="securityContextInput")
    def security_context_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerSecurityContext"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerSecurityContext"],
            jsii.get(self, "securityContextInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="startupProbeInput")
    def startup_probe_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbe"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbe"],
            jsii.get(self, "startupProbeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="stdinInput")
    def stdin_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "stdinInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="stdinOnceInput")
    def stdin_once_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "stdinOnceInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePathInput")
    def termination_message_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "terminationMessagePathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePolicyInput")
    def termination_message_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str],
            jsii.get(self, "terminationMessagePolicyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="ttyInput")
    def tty_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "ttyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeMountInput")
    def volume_mount_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerVolumeMount"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerVolumeMount"],
                ]
            ],
            jsii.get(self, "volumeMountInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="workingDirInput")
    def working_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "workingDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="args")
    def args(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "args"))

    @args.setter
    def args(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e1d06865c21333b41920008d919efa4b90749e6eee73a8ee8d0d9c9a8cd302db
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "args", value)

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4d5a61d4952794dc4a0ffe8cfc3c375926a745dd68e321ef73d3a3aeddbbff45
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "image"))

    @image.setter
    def image(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7910347bac72c0f7a1db302d6cea376e1410e8109ddee06ca947c205f1a04dda
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "image", value)

    @builtins.property
    @jsii.member(jsii_name="imagePullPolicy")
    def image_pull_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagePullPolicy"))

    @image_pull_policy.setter
    def image_pull_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6e27de6cb3cd9c3147802cae7fbbd77091dbb02e6204c6f29b5717382135ac3b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "imagePullPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5c7b2bf693784e8a2135424d5d21195de1f323671eebef73a42300839edf96a0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="stdin")
    def stdin(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "stdin"),
        )

    @stdin.setter
    def stdin(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__57552a5e0b81d607a5e139a7929b8f3a21589189bc023d7d3952ca25474dbe4f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "stdin", value)

    @builtins.property
    @jsii.member(jsii_name="stdinOnce")
    def stdin_once(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "stdinOnce"),
        )

    @stdin_once.setter
    def stdin_once(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d583ebfed958d72469295618c7f4bbcc49ef7857513a5033b289207f245648c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "stdinOnce", value)

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePath")
    def termination_message_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "terminationMessagePath"))

    @termination_message_path.setter
    def termination_message_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__76219ebe9c99c0596f6514b1e473a7d3f7d47c78b071ca12d6237eb7496f3203
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terminationMessagePath", value)

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePolicy")
    def termination_message_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "terminationMessagePolicy"))

    @termination_message_policy.setter
    def termination_message_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__86260db9ca11ce40ae76842f871602796f5dea3a176a808554608c31dbdb40f2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terminationMessagePolicy", value)

    @builtins.property
    @jsii.member(jsii_name="tty")
    def tty(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "tty"),
        )

    @tty.setter
    def tty(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3acd08403567e6bd4db13686b36c3ee44f55ed23e394e0141c3bfa94a2ade70e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "tty", value)

    @builtins.property
    @jsii.member(jsii_name="workingDir")
    def working_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "workingDir"))

    @working_dir.setter
    def working_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2c729df33c7eb6da6369865fb590ea3d227e58e9f22482cab4d917356928e4fd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "workingDir", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainer]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainer
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainer
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9fcb2ad6e681ed26feebe0a0b401795e15a90609c4bbafd474fa29bdc89eff49
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerPort",
    jsii_struct_bases=[],
    name_mapping={
        "container_port": "containerPort",
        "host_ip": "hostIp",
        "host_port": "hostPort",
        "name": "name",
        "protocol": "protocol",
    },
)
class DaemonSetV1SpecTemplateSpecContainerPort:
    def __init__(
        self,
        *,
        container_port: jsii.Number,
        host_ip: typing.Optional[builtins.str] = None,
        host_port: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        protocol: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_port DaemonSetV1#container_port}
        :param host_ip: What host IP to bind the external port to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_ip DaemonSetV1#host_ip}
        :param host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_port DaemonSetV1#host_port}
        :param name: If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#protocol DaemonSetV1#protocol}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__616ffc0874da60785dbf0860a6253d320403a8222cdcabe4481f6b41406309ff
            )
            check_type(
                argname="argument container_port",
                value=container_port,
                expected_type=type_hints["container_port"],
            )
            check_type(
                argname="argument host_ip",
                value=host_ip,
                expected_type=type_hints["host_ip"],
            )
            check_type(
                argname="argument host_port",
                value=host_port,
                expected_type=type_hints["host_port"],
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument protocol",
                value=protocol,
                expected_type=type_hints["protocol"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_port": container_port,
        }
        if host_ip is not None:
            self._values["host_ip"] = host_ip
        if host_port is not None:
            self._values["host_port"] = host_port
        if name is not None:
            self._values["name"] = name
        if protocol is not None:
            self._values["protocol"] = protocol

    @builtins.property
    def container_port(self) -> jsii.Number:
        """Number of port to expose on the pod's IP address.

        This must be a valid port number, 0 < x < 65536.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_port DaemonSetV1#container_port}
        """
        result = self._values.get("container_port")
        assert result is not None, "Required property 'container_port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def host_ip(self) -> typing.Optional[builtins.str]:
        """What host IP to bind the external port to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_ip DaemonSetV1#host_ip}
        """
        result = self._values.get("host_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_port(self) -> typing.Optional[jsii.Number]:
        """Number of port to expose on the host.

        If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_port DaemonSetV1#host_port}
        """
        result = self._values.get("host_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """If specified, this must be an IANA_SVC_NAME and unique within the pod.

        Each named port in a pod must have a unique name. Name for the port that can be referred to by services

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def protocol(self) -> typing.Optional[builtins.str]:
        """Protocol for port. Must be UDP or TCP. Defaults to "TCP".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#protocol DaemonSetV1#protocol}
        """
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerPort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerPortList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerPortList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c05b3b4406723b8984967d621d954991ee409351276779c40473a95899400ab0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerPortOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d949de365b639cede158fc4018c358dc890de9250cffec59d4a51c598f1bd261
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerPortOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__927be62e459bda8a8046f0fc0be8f787228c07f356f567bdce6cdb3455660fe0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e2100d953393027e8f67217c9ec93e5a7bf831ff9f8ae958adc7149addfdceaf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__faf7d0fb1a1553bb6f9c38b3aecee00f29d90c61510ba5da872ddb1d934e845f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerPort],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerPort],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerPort],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__441363f0af91427212c7d9ffd1fe3695bc1b3996dd1a5c6f591de759c2c57936
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerPortOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerPortOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9ea9ca6f23ae4d761a1fa828fbb65251126e774b7457eb054b922b77eaa80837
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetHostIp")
    def reset_host_ip(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostIp", []))

    @jsii.member(jsii_name="resetHostPort")
    def reset_host_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostPort", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetProtocol")
    def reset_protocol(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProtocol", []))

    @builtins.property
    @jsii.member(jsii_name="containerPortInput")
    def container_port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "containerPortInput")
        )

    @builtins.property
    @jsii.member(jsii_name="hostIpInput")
    def host_ip_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostIpInput"))

    @builtins.property
    @jsii.member(jsii_name="hostPortInput")
    def host_port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "hostPortInput")
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="protocolInput")
    def protocol_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "protocolInput")
        )

    @builtins.property
    @jsii.member(jsii_name="containerPort")
    def container_port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "containerPort"))

    @container_port.setter
    def container_port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c8910e90a60c3377cbf8163c8cfc4d36a47e4bbbc96de9b640933d549e516159
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "containerPort", value)

    @builtins.property
    @jsii.member(jsii_name="hostIp")
    def host_ip(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "hostIp"))

    @host_ip.setter
    def host_ip(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c58d70e40270628ccb81bb2a3e621ab1e3f510cc2481f348a01c953341cb6fd6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostIp", value)

    @builtins.property
    @jsii.member(jsii_name="hostPort")
    def host_port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "hostPort"))

    @host_port.setter
    def host_port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b4136b974ccec7ebcc5b2c39f2fc342e4e053199ec783834d256d7b455e3b9ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostPort", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f85d9e8acce4f44fb0fcaabd00032ef05f8b01b5077a507a1e36c14c7bc8c1f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="protocol")
    def protocol(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "protocol"))

    @protocol.setter
    def protocol(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4ddee2f9e8d400793666455976575e9f309f819bf4ab8071f1809a7af2a8f7f9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "protocol", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerPort
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerPort,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerPort
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__22bdf9500ecdf36fa4ce50e7cb22d7a3da8f74b63c0cde92656e1b366779257c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "grpc": "grpc",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class DaemonSetV1SpecTemplateSpecContainerReadinessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2d3d42d563017ca60a8f08f580575709deab6b84c23da8aa9d3d360d9edc0f4f
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument failure_threshold",
                value=failure_threshold,
                expected_type=type_hints["failure_threshold"],
            )
            check_type(
                argname="argument grpc", value=grpc, expected_type=type_hints["grpc"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument initial_delay_seconds",
                value=initial_delay_seconds,
                expected_type=type_hints["initial_delay_seconds"],
            )
            check_type(
                argname="argument period_seconds",
                value=period_seconds,
                expected_type=type_hints["period_seconds"],
            )
            check_type(
                argname="argument success_threshold",
                value=success_threshold,
                expected_type=type_hints["success_threshold"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
            check_type(
                argname="argument timeout_seconds",
                value=timeout_seconds,
                expected_type=type_hints["timeout_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if grpc is not None:
            self._values["grpc"] = grpc
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec"],
            result,
        )

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive failures for the probe to be considered failed after having succeeded.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        """
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def grpc(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc"],
        ]
    ]:
        """grpc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        """
        result = self._values.get("grpc")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet"]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet"
            ],
            result,
        )

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        """
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        """How often (in seconds) to perform the probe.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        """
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive successes for the probe to be considered successful after having failed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        """
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket"],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerReadinessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9d18186967a9876bb2fba0b8547990b877e2a3ef2abf7bffc7a0344be483880f
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15f4f1fac7783eeb01fc288b82199d76662ac0e480ccbb62abe83571e5256a98
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__79197d1db1085bce8daa43326121541b88c60a0d4e399279051c7851b32f8224
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5f75166b018f040a7a949747b54e97b5498d4e96484fd9e8d8cd9b40af31261f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "service": "service"},
)
class DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc:
    def __init__(
        self,
        *,
        port: jsii.Number,
        service: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param port: Number of the port to access on the container. Number must be in the range 1 to 65535. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__78bf26c4e4e38f4d520074519ea750f5a1e88bab65c839947d34ad636f89cff5
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument service",
                value=service,
                expected_type=type_hints["service"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }
        if service is not None:
            self._values["service"] = service

    @builtins.property
    def port(self) -> jsii.Number:
        """Number of the port to access on the container. Number must be in the range 1 to 65535.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def service(self) -> typing.Optional[builtins.str]:
        """Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        result = self._values.get("service")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf1253b59f5108bb2855d8a3aa635ba13598c3c38665cd70a4211c9849648555
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__849e0238b8343a0836fa366f0061f4edf61ffdf43159403efcdc6ddb5eddb2e6
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6a97b9e98385d42c6433fda16dd62daf12a92589b37639441028a3bc8cb13bd9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c4ecd47bc04925cd665343e6ad82e00dfc36d0afb3da4262cff2cdb400ab51c7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f506dcb8f45b91bf639f29e366edd2cb288991a573098a9b853492079f22dbdd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af2e058c46ea2adc009a23f8c6b853a589f4ae31b5e762be74d5d06e3b700591
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__efc3ca4f9cedc4dcffe341b957f26c9ba2148bee61cc6aa8162e4e5a36f9ca2e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "serviceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1d1ffba3cde575a9179d02de724574e5f6cf2dfd0efb5bbe76ee4696437363a9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "service"))

    @service.setter
    def service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b33088ab52809818076c4d292225b6acbdb8e0f6a825fb3d3ce490608d5837ad
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "service", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7e723182809765e7b7f0a3ce80f785e3dfb7626ee08c10f9a1a957e69a7bf34
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e4ee96931964abd7a6c8d2a462b3a04dd4c8f34f12cd4c8abdc075bba1f53c67
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8665fc78695243731b12a35456fa3c017ad6677c595992c5622c38d469d72910
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__11bd6f80e8131a8a9e625cfb3ad199a50288368cd6ea8e853ee52123baf3901c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2a8dfcba5daf52655a8843fc34332e446db5bf92883c2f9c5b9468191bb03638
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__96e243eb4aa85dee6062c2aa586b4bc58f9d4b942b55515493c7722ddabef192
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2dcaf742dc565c2d2da25f9af7fe6d1141ac75df352cff3b1220f8703a734eec
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2dc441089811b938b8c8f942e98f0edb48c1fcda635291e5ef8bd2f588a3a96a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2e1bb72921854295bf42e11640bedd45171bdef7fa187cc7359a439622c3845
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f6c93b38e51738a8bf281f40c048fc8e9796048ef88e3b7a45fce85e44632381
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__798eaf7261cf40c2c1075a0ed5bb896b9acc4fdda7ad52ad04d342040739a69a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__87ac7fd1b857778a580753d272330f33e13f4ab26ed4fd683ec2a94126689942
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__19d56bb922e3f8e7f3caaee96160989f5e100acc38c8c26a9608c735eb0b8233
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4fbed2e912dc379101f9b2304743096127d149f931bce2777bdebc2b16a7a874
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dde656cf4db19e729e91a21015082ba11196c59bbd5c65061917743e53acb18c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1423e125d8d59651f3c02c17bf1d49396ec6e798d99ad58d225fb50c1ed48099
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__00023d1f3fef03fbc6160982c67515ad2505b44b739b1c2dad68dc7acfe06579
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__49625c15aae1cc598932cbffc5dd1f8193067cad6927cfd289a8f2cee9f14747
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d8f9d5815be3e60a6d2495a4644e8ee0c8daadab098ce742922b31237938b365
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d3a4fe6290020a880f774893dd7e9b1b830a648d391a1ec5daaa083cbfbda7fe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2cee60d3427a16eb3523b5502398f7758d55017f458dbf2d773bb1fc7901192d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec(command=command)

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putGrpc")
    def put_grpc(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__26d7d39ebdc0cc899bd09c0d5d95d8a6a8610945c9a79f00aec48cdbf8f62f81
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putGrpc", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dba8d41c960c88c772bfe5993815d99d08057397dc4b966fb8d3f62c7f475481
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetGrpc")
    def reset_grpc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGrpc", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerReadinessProbeExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="grpc")
    def grpc(self) -> DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcList,
            jsii.get(self, "grpc"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="grpcInput")
    def grpc_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc],
                ]
            ],
            jsii.get(self, "grpcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c54e1850dbcf39e057cd0efa8975c81da6f2e52486f739303ca4464abee366ea
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "failureThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e525b7169b5b67449c5f78aa784798f9ef444034e33d5213c144e3ebe127fee6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "initialDelaySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c713a63b2ac1b2f41596969dca1c13f526a73fbd86384b27491c4e609902223e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "periodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2fd83046a06c989ad5dd2ce93d4cbbe0e76600ba29c34735e358b6767d1da41b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "successThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c08ac90645cc57d35a15436d9b4acb7906bd5a297c8d7206452b9df4e8c2e431
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "timeoutSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbe],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbe],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__29d783e5ff084d665b42fc4e92ba051c4a865f7e58205a09b2190ddaecac8e16
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56a02d2d7d8368d2c64c643dd0c80d2de7c695b76ca364ad67a1145336fb55a8
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1c4a839b30637248ede25dafdd7abc4aad8e4b35fe826881dcfda0321cb6a369
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2c9c539b7ee00b5a8543b0769d51444ea35bc017c8d3882d9a0854eba307519
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e40040f3558ad34a9cc67c96b0728f6afddeb4b6b9080de05944890a82956b76
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c349f64fbb5f018998961349560429519f4f02bb45417651b1e225ee6dac6f9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c96d52bd585a269502c485c68a2a13f64732c8db58931b458e250c6d253c5d07
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f3d6dc59a3a23628c979635b9ec680a608629221a6b074fb1b0150c986404b72
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c36395078d585a9805f7840d3b13093c9048eb7eecc14d9c41e8794714c93a7c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2c58e23676d81ce4e0acab59591dda631ae3889f61dea22d8052eb7a1ba1c2fd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__927eaffbafb4125b14c805677619fbafd12cff10f87978903cf4a7b5eb0f4dd6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class DaemonSetV1SpecTemplateSpecContainerResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        """
        :param limits: Describes the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#limits DaemonSetV1#limits}
        :param requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#requests DaemonSetV1#requests}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dfd99ad4fd05cbc63937bbc7ac54db5d194e86c73b4d37896c47c607d91a1b0d
            )
            check_type(
                argname="argument limits",
                value=limits,
                expected_type=type_hints["limits"],
            )
            check_type(
                argname="argument requests",
                value=requests,
                expected_type=type_hints["requests"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Describes the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#limits DaemonSetV1#limits}
        """
        result = self._values.get("limits")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def requests(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Requests describes the minimum amount of compute resources required.

        If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#requests DaemonSetV1#requests}
        """
        result = self._values.get("requests")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerResourcesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerResourcesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cbd8d91a08dd5efeff9f78cf2a7dbfb3c2885cf2e0c3d2e5b435f1b3123787f0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLimits")
    def reset_limits(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLimits", []))

    @jsii.member(jsii_name="resetRequests")
    def reset_requests(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequests", []))

    @builtins.property
    @jsii.member(jsii_name="limitsInput")
    def limits_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "limitsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="requestsInput")
    def requests_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "requestsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="limits")
    def limits(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "limits")
        )

    @limits.setter
    def limits(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__24f261bce5a5fde89278c3d980cd6bc16a8891a2cd3149b8c5e1e22d992d77d7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "limits", value)

    @builtins.property
    @jsii.member(jsii_name="requests")
    def requests(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "requests")
        )

    @requests.setter
    def requests(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__32e0e7a3e5839021458ffa8f5317504af76a4be6c33df698f347fa3c24766aa1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "requests", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerResources]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerResources],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerResources],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f77ad9f5e7dc7ab8015617819291b9dd23c4ddc1b6dc4ed799d9093ec7c59b2b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "allow_privilege_escalation": "allowPrivilegeEscalation",
        "capabilities": "capabilities",
        "privileged": "privileged",
        "read_only_root_filesystem": "readOnlyRootFilesystem",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
    },
)
class DaemonSetV1SpecTemplateSpecContainerSecurityContext:
    def __init__(
        self,
        *,
        allow_privilege_escalation: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        capabilities: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        privileged: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        read_only_root_filesystem: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_group: typing.Optional[builtins.str] = None,
        run_as_non_root: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_user: typing.Optional[builtins.str] = None,
        seccomp_profile: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        se_linux_options: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#allow_privilege_escalation DaemonSetV1#allow_privilege_escalation}
        :param capabilities: capabilities block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#capabilities DaemonSetV1#capabilities}
        :param privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#privileged DaemonSetV1#privileged}
        :param read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only_root_filesystem DaemonSetV1#read_only_root_filesystem}
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        :param seccomp_profile: seccomp_profile block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        :param se_linux_options: se_linux_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        """
        if isinstance(capabilities, dict):
            capabilities = (
                DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities(
                    **capabilities
                )
            )
        if isinstance(seccomp_profile, dict):
            seccomp_profile = (
                DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile(
                    **seccomp_profile
                )
            )
        if isinstance(se_linux_options, dict):
            se_linux_options = (
                DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions(
                    **se_linux_options
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__518185f360f2df4d4d87b4faa9c74dfe282c5249a68582547c46689720554f60
            )
            check_type(
                argname="argument allow_privilege_escalation",
                value=allow_privilege_escalation,
                expected_type=type_hints["allow_privilege_escalation"],
            )
            check_type(
                argname="argument capabilities",
                value=capabilities,
                expected_type=type_hints["capabilities"],
            )
            check_type(
                argname="argument privileged",
                value=privileged,
                expected_type=type_hints["privileged"],
            )
            check_type(
                argname="argument read_only_root_filesystem",
                value=read_only_root_filesystem,
                expected_type=type_hints["read_only_root_filesystem"],
            )
            check_type(
                argname="argument run_as_group",
                value=run_as_group,
                expected_type=type_hints["run_as_group"],
            )
            check_type(
                argname="argument run_as_non_root",
                value=run_as_non_root,
                expected_type=type_hints["run_as_non_root"],
            )
            check_type(
                argname="argument run_as_user",
                value=run_as_user,
                expected_type=type_hints["run_as_user"],
            )
            check_type(
                argname="argument seccomp_profile",
                value=seccomp_profile,
                expected_type=type_hints["seccomp_profile"],
            )
            check_type(
                argname="argument se_linux_options",
                value=se_linux_options,
                expected_type=type_hints["se_linux_options"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_privilege_escalation is not None:
            self._values["allow_privilege_escalation"] = allow_privilege_escalation
        if capabilities is not None:
            self._values["capabilities"] = capabilities
        if privileged is not None:
            self._values["privileged"] = privileged
        if read_only_root_filesystem is not None:
            self._values["read_only_root_filesystem"] = read_only_root_filesystem
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options

    @builtins.property
    def allow_privilege_escalation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process.

        This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#allow_privilege_escalation DaemonSetV1#allow_privilege_escalation}
        """
        result = self._values.get("allow_privilege_escalation")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def capabilities(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities"
    ]:
        """capabilities block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#capabilities DaemonSetV1#capabilities}
        """
        result = self._values.get("capabilities")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities"
            ],
            result,
        )

    @builtins.property
    def privileged(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Run container in privileged mode.

        Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#privileged DaemonSetV1#privileged}
        """
        result = self._values.get("privileged")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def read_only_root_filesystem(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether this container has a read-only root filesystem. Default is false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only_root_filesystem DaemonSetV1#read_only_root_filesystem}
        """
        result = self._values.get("read_only_root_filesystem")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def run_as_group(self) -> typing.Optional[builtins.str]:
        """The GID to run the entrypoint of the container process.

        Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        """
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_non_root(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Indicates that the container must run as a non-root user.

        If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        """
        result = self._values.get("run_as_non_root")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def run_as_user(self) -> typing.Optional[builtins.str]:
        """The UID to run the entrypoint of the container process.

        Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        """
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile"
    ]:
        """seccomp_profile block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        """
        result = self._values.get("seccomp_profile")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile"
            ],
            result,
        )

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions"
    ]:
        """se_linux_options block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        """
        result = self._values.get("se_linux_options")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities",
    jsii_struct_bases=[],
    name_mapping={"add": "add", "drop": "drop"},
)
class DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities:
    def __init__(
        self,
        *,
        add: typing.Optional[typing.Sequence[builtins.str]] = None,
        drop: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param add: Added capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#add DaemonSetV1#add}
        :param drop: Removed capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#drop DaemonSetV1#drop}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a693ed89ece9d42b91ef90d7983927ecfad4bf9f532fbdd682d832c7b78bc6f6
            )
            check_type(
                argname="argument add", value=add, expected_type=type_hints["add"]
            )
            check_type(
                argname="argument drop", value=drop, expected_type=type_hints["drop"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if add is not None:
            self._values["add"] = add
        if drop is not None:
            self._values["drop"] = drop

    @builtins.property
    def add(self) -> typing.Optional[typing.List[builtins.str]]:
        """Added capabilities.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#add DaemonSetV1#add}
        """
        result = self._values.get("add")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def drop(self) -> typing.Optional[typing.List[builtins.str]]:
        """Removed capabilities.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#drop DaemonSetV1#drop}
        """
        result = self._values.get("drop")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilitiesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilitiesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2d891034991f2de2f6a401f6c49cd22f05c44b4c1107e414ec72d7384ef28f8f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAdd")
    def reset_add(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdd", []))

    @jsii.member(jsii_name="resetDrop")
    def reset_drop(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDrop", []))

    @builtins.property
    @jsii.member(jsii_name="addInput")
    def add_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "addInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dropInput")
    def drop_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "dropInput")
        )

    @builtins.property
    @jsii.member(jsii_name="add")
    def add(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "add"))

    @add.setter
    def add(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7f85c006b1e678ac9c90651a68dad15cf8b4eb3aac425207284d2e4051490f6c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "add", value)

    @builtins.property
    @jsii.member(jsii_name="drop")
    def drop(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "drop"))

    @drop.setter
    def drop(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd884d8ea0b9335314a688157814d0c976c16c44273656bc4f2f9b2ce1ad722d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "drop", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__611f499edb62944e16735bd43c9cb020b99d562d4843329c6139efbfca43664a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerSecurityContextOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContextOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac11491d3ef80f3985208a62b6b4890247f7c6b7ee0d631a7e0f09f4b6d12dd9
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCapabilities")
    def put_capabilities(
        self,
        *,
        add: typing.Optional[typing.Sequence[builtins.str]] = None,
        drop: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param add: Added capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#add DaemonSetV1#add}
        :param drop: Removed capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#drop DaemonSetV1#drop}
        """
        value = DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities(
            add=add, drop=drop
        )

        return typing.cast(None, jsii.invoke(self, "putCapabilities", [value]))

    @jsii.member(jsii_name="putSeccompProfile")
    def put_seccomp_profile(
        self,
        *,
        localhost_profile: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        :param type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        value = DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile(
            localhost_profile=localhost_profile, type=type
        )

        return typing.cast(None, jsii.invoke(self, "putSeccompProfile", [value]))

    @jsii.member(jsii_name="putSeLinuxOptions")
    def put_se_linux_options(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param level: Level is SELinux level label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        :param role: Role is a SELinux role label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        :param type: Type is a SELinux type label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        :param user: User is a SELinux user label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        value = DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions(
            level=level, role=role, type=type, user=user
        )

        return typing.cast(None, jsii.invoke(self, "putSeLinuxOptions", [value]))

    @jsii.member(jsii_name="resetAllowPrivilegeEscalation")
    def reset_allow_privilege_escalation(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowPrivilegeEscalation", []))

    @jsii.member(jsii_name="resetCapabilities")
    def reset_capabilities(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCapabilities", []))

    @jsii.member(jsii_name="resetPrivileged")
    def reset_privileged(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivileged", []))

    @jsii.member(jsii_name="resetReadOnlyRootFilesystem")
    def reset_read_only_root_filesystem(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnlyRootFilesystem", []))

    @jsii.member(jsii_name="resetRunAsGroup")
    def reset_run_as_group(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsGroup", []))

    @jsii.member(jsii_name="resetRunAsNonRoot")
    def reset_run_as_non_root(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsNonRoot", []))

    @jsii.member(jsii_name="resetRunAsUser")
    def reset_run_as_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsUser", []))

    @jsii.member(jsii_name="resetSeccompProfile")
    def reset_seccomp_profile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSeccompProfile", []))

    @jsii.member(jsii_name="resetSeLinuxOptions")
    def reset_se_linux_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSeLinuxOptions", []))

    @builtins.property
    @jsii.member(jsii_name="capabilities")
    def capabilities(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilitiesOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilitiesOutputReference,
            jsii.get(self, "capabilities"),
        )

    @builtins.property
    @jsii.member(jsii_name="seccompProfile")
    def seccomp_profile(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfileOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfileOutputReference",
            jsii.get(self, "seccompProfile"),
        )

    @builtins.property
    @jsii.member(jsii_name="seLinuxOptions")
    def se_linux_options(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptionsOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptionsOutputReference",
            jsii.get(self, "seLinuxOptions"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowPrivilegeEscalationInput")
    def allow_privilege_escalation_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "allowPrivilegeEscalationInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="capabilitiesInput")
    def capabilities_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities
            ],
            jsii.get(self, "capabilitiesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="privilegedInput")
    def privileged_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "privilegedInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="readOnlyRootFilesystemInput")
    def read_only_root_filesystem_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyRootFilesystemInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="runAsGroupInput")
    def run_as_group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runAsGroupInput")
        )

    @builtins.property
    @jsii.member(jsii_name="runAsNonRootInput")
    def run_as_non_root_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "runAsNonRootInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="runAsUserInput")
    def run_as_user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runAsUserInput")
        )

    @builtins.property
    @jsii.member(jsii_name="seccompProfileInput")
    def seccomp_profile_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile"
            ],
            jsii.get(self, "seccompProfileInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="seLinuxOptionsInput")
    def se_linux_options_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions"
            ],
            jsii.get(self, "seLinuxOptionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowPrivilegeEscalation")
    def allow_privilege_escalation(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "allowPrivilegeEscalation"),
        )

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c8dd46d44d4f6529c58433d8c5968ff2336f0fe044664f2ebafcc83566493f1e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowPrivilegeEscalation", value)

    @builtins.property
    @jsii.member(jsii_name="privileged")
    def privileged(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "privileged"),
        )

    @privileged.setter
    def privileged(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__14088fba1cb299a966a0bbaa60d314cd87c382b11e5ee32b03e12207a2f9b540
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "privileged", value)

    @builtins.property
    @jsii.member(jsii_name="readOnlyRootFilesystem")
    def read_only_root_filesystem(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnlyRootFilesystem"),
        )

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__42eadb80283d2a19c12a078239288fa63dbd20aad0675e3aa59af4df4adb850d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnlyRootFilesystem", value)

    @builtins.property
    @jsii.member(jsii_name="runAsGroup")
    def run_as_group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runAsGroup"))

    @run_as_group.setter
    def run_as_group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b04ead63ec1b9d7a0d568a9a0e31ca6e6d438c33a2a4c05ffd1ba15e6466ca40
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsGroup", value)

    @builtins.property
    @jsii.member(jsii_name="runAsNonRoot")
    def run_as_non_root(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "runAsNonRoot"),
        )

    @run_as_non_root.setter
    def run_as_non_root(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b810a087cf6c9cdc42102e5d4dd93da057db2299ecb2287c3b925e5a6c204363
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsNonRoot", value)

    @builtins.property
    @jsii.member(jsii_name="runAsUser")
    def run_as_user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runAsUser"))

    @run_as_user.setter
    def run_as_user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0fcaeed301fbd05961f63fb6baabe83cc393e7542bdcfa2d6861103e45a9c37e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsUser", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerSecurityContext]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerSecurityContext],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerSecurityContext],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c5442683767d802fb5147165dd29d1ab1099c00ddeb404fde6993b060cb6bf65
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param level: Level is SELinux level label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        :param role: Role is a SELinux role label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        :param type: Type is a SELinux type label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        :param user: User is a SELinux user label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f4c253f664ce8ddc354293a6c733421008f4e4eab66b4cecb7ac3efcffaf6ab
            )
            check_type(
                argname="argument level", value=level, expected_type=type_hints["level"]
            )
            check_type(
                argname="argument role", value=role, expected_type=type_hints["role"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument user", value=user, expected_type=type_hints["user"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        """Level is SELinux level label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        """
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        """Role is a SELinux role label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        """
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type is a SELinux type label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        """User is a SELinux user label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5e78c4581e0fa27127f0c0cde779f650221463360166f538b46231a5bcd1565
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLevel")
    def reset_level(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLevel", []))

    @jsii.member(jsii_name="resetRole")
    def reset_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRole", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="levelInput")
    def level_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "levelInput"))

    @builtins.property
    @jsii.member(jsii_name="roleInput")
    def role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "roleInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="level")
    def level(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "level"))

    @level.setter
    def level(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8c010e4b50f23e5d897382ceba9030de5525ab1215b8b790848e9bb272dbcee3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "level", value)

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "role"))

    @role.setter
    def role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__afc536205fbb00260694d0e1d80610090c44e9c24b9859e1f6bd15092ba07d7c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "role", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c4f7b9d48f521b8e467af5c790b0faf026668bcca53c400e11640fb4f4326fc6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__76ba1b287dee30ee6b41253afa6f6098162c6ccecfb3372cc4b58d7686c7cac9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "user", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__222583675e51f77795f4d3aae943364147b109fbc7dee080d41e65c8fe55e77c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"localhost_profile": "localhostProfile", "type": "type"},
)
class DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        localhost_profile: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        :param type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__66331473248079ebebcfe9384471daa8e4b4dc82ddbca06fcf826092fe3a3f81
            )
            check_type(
                argname="argument localhost_profile",
                value=localhost_profile,
                expected_type=type_hints["localhost_profile"],
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        """Localhost Profile indicates a profile defined in a file on the node should be used.

        The profile must be preconfigured on the node to work.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        """
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfileOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfileOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cb51ea27753f7d213fc1bc0a9fbda167a8b6e4a3eb45f7b596055f30aaf5eb4d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLocalhostProfile")
    def reset_localhost_profile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalhostProfile", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="localhostProfileInput")
    def localhost_profile_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "localhostProfileInput")
        )

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="localhostProfile")
    def localhost_profile(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "localhostProfile"))

    @localhost_profile.setter
    def localhost_profile(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dda97c8576fcbfa48b30a0ecc27dafca813145de1f345fc20f8959296520ed73
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "localhostProfile", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__972f32f7f0332ecea1aefa6beb9e25522987bb40640299ac3b577538c85ea05a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5a56ba71d9088b792b314dbb985793ea6f4c2d80306f63d84d35690693cbe90
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "grpc": "grpc",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class DaemonSetV1SpecTemplateSpecContainerStartupProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerStartupProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecContainerStartupProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0686c76df69356a06aaf59523caa0889c94331bb47b8c2923bfd3772c7bb5003
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument failure_threshold",
                value=failure_threshold,
                expected_type=type_hints["failure_threshold"],
            )
            check_type(
                argname="argument grpc", value=grpc, expected_type=type_hints["grpc"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument initial_delay_seconds",
                value=initial_delay_seconds,
                expected_type=type_hints["initial_delay_seconds"],
            )
            check_type(
                argname="argument period_seconds",
                value=period_seconds,
                expected_type=type_hints["period_seconds"],
            )
            check_type(
                argname="argument success_threshold",
                value=success_threshold,
                expected_type=type_hints["success_threshold"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
            check_type(
                argname="argument timeout_seconds",
                value=timeout_seconds,
                expected_type=type_hints["timeout_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if grpc is not None:
            self._values["grpc"] = grpc
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbeExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbeExec"],
            result,
        )

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive failures for the probe to be considered failed after having succeeded.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        """
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def grpc(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc"],
        ]
    ]:
        """grpc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        """
        result = self._values.get("grpc")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc"],
                ]
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet"]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet"],
            result,
        )

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        """
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        """How often (in seconds) to perform the probe.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        """
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive successes for the probe to be considered successful after having failed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        """
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket"],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerStartupProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecContainerStartupProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d370aaee037d1330656f7e1f77ae74a4f4f6942a9aa2c884f65205e6e843e6bb
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerStartupProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerStartupProbeExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08172d40d6a61984a3c0cb4bf5e0fdac83d0e16aa33a14bfe15df050ae00f3c0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b4295bd2061841f932ce9fe13bde728c495524df6ce4710fc7e24256ea60f1c8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeExec],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b8d3638af6b9e77a8e7585ff9d7ee6f45be1de83f78063bed0b8787e34f5af7f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "service": "service"},
)
class DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc:
    def __init__(
        self,
        *,
        port: jsii.Number,
        service: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param port: Number of the port to access on the container. Number must be in the range 1 to 65535. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__102ab253974859980ab7c9101fe1c6e219d409fe709255cfd69414d742221da6
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument service",
                value=service,
                expected_type=type_hints["service"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }
        if service is not None:
            self._values["service"] = service

    @builtins.property
    def port(self) -> jsii.Number:
        """Number of the port to access on the container. Number must be in the range 1 to 65535.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def service(self) -> typing.Optional[builtins.str]:
        """Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        result = self._values.get("service")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2259673f5569f679719de458bc705f3d92fb5ee976b8074d83f1b1710f98da19
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__679e4e308fceb8554a99840bf020d097f94634c4665d75f53686840fcc79596f
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6888ab33ab78061dd2a7004d4a7c870facf22b284a3288d9fe8ae7d41ea5159c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9872ea2713577634e25fbb6c3ef1974b709ae1d9277752eaf9eb3d0b031f9961
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3cb135e11077c90e706b588f055556e61926661d1d3aef50eb2aa4805a908790
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2017bd2ede0db7526c58f2b1e4abb41de3c27fce99be3948a7262302afe61a90
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dfef34e5850489bdcf69ed4ee02c3e3c87e26bfaa4bf8ca76494aef26f58d0aa
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "serviceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ee859a0a7f80a4a334df8f2f7b839dc059e8df8a234802423eeac613ac07000
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "service"))

    @service.setter
    def service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08c966cf164b46f33c74fa4746d89f42e107ee7841fb6d4346a0a80b86f49a5f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "service", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__41becfedc60cfdea669bf0aa0cdb3aff1281d29bd8aadc872baa52de73ffaf50
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ab2b1406d56b53995db79185fe31fdc10e77102c899db8fe78d77dfcc0e8fb08
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__35eedb8c19b9986bdff1b50896fce6bdc2d1a5f32c927c50f168170289194482
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__809a9d909d6d90b49928bdef40be7979c86a302c355e7d3a1e454d5b9031d838
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9e26f64e6b97e2193317ec691bd5dae42388054e3a8e27f4807f62f3367813a6
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8aec937317e201496f152eaadce664370f52eec2275bdc9286c6f0be55692c41
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__41afa6f052496ea4657868b95d8ef51712175bb72f799d547213fffff37cbeaa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__49c1b70c437352bfde61a24055cefeca0dd207eee180d04b6f7ca4e3994dd051
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6db51481ccd749a5a08e619acfe114d413826aedb8914c0b2977ec5d9a30f901
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f06ab158af086cacff0f9a17a1098e138557780d2f93a40950e1e2c020a9c19c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0d84e7a2ed4d88a0ac42f9897c1d9e99639ee760f063cc12110fd4fef0bc2f1d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8dd2a7ce307a39cf4e9065b2bd4522a8db1513563e505ba6d8d6815764873514
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1c4f141f5f54ab9aa4d9064bc4f8364124d7a7baef439f978f48fc462cca0a82
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__60a9fa0e1370e317382fefadc157e169dbdf92356ca630817019eef083423790
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__01a98f4072c9e12cdf29e5e75badf8b4a403684e84abe20f08065fc4d59329e6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a8b087383d0f8efa177a693378bb849fc7e09b0bc10e1ec1169a7b831c2d71a2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3535c377924c0fa4b557559369aeccf1659846e8fc0435344e8eae8c69adf7cf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2b21d21335dd3d2231a3c3c9fe2339e2a5a7c3e5ca70aff2400e83ed978c5de
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c6a0c15d812a9e4c795ac69bdccf7da70e8c47968cd7d90d9b5305af9b9bdaf8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb1d7c10cca684845ce834f21ed550f539d2a9f0f9e9de7fdf4710aef202f82f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerStartupProbeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__719d6d1a567f58275bca9fd84a29a40fa2a811309ea050f3a36dc8cd2549b5a5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecContainerStartupProbeExec(command=command)

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putGrpc")
    def put_grpc(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4956b7af80570296dc4cf609c5065834788d528d2ed12813f94aebdf3824dfb8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putGrpc", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e6fec0c6fe2c6f9cbad91550f5a47ba74066633c349737202c00f9e69dc67f25
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetGrpc")
    def reset_grpc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGrpc", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerStartupProbeExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerStartupProbeExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="grpc")
    def grpc(self) -> DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcList,
            jsii.get(self, "grpc"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="grpcInput")
    def grpc_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc],
                ]
            ],
            jsii.get(self, "grpcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__462dc7b51f867a6b03e48a0dda6f32c4fe45dfd4350656451155038a36ea80ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "failureThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47f17ab1dfd1d026392cac698dfd312083843f78da483fe9936d1894eecdf5a0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "initialDelaySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__26ad2b8134268152d879e217f0bc347ef1a31a429572532d35ea25b8186a7677
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "periodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f50777ba38cb874e32ef0491ef82305ac6b828769a7454998b2b399fab934ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "successThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ce1de9616cc23078d41788fc4861ca34002c4698c4fae2c57ec6616fb0583ba8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "timeoutSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbe],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbe],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5b70d5da7a7d64cdaa5aa62d205e674ade422236611d1dbdff0440c1c9cf7e5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ed90d1f248cb6929bf719bd1725dd6ef126dc5cfc7d47f8e79458064948798c1
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__55d18e77e480039b7ddb6aac4c5eb5b22b0c806247a3d07e5060860e2fb7fb4c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3e2e931671b2918aab50718c9e05c1906bc7fad81080364d73e54c0d95887aae
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9bca25a795a332419e34fde310313acbf2a97872d2317531bd6ea3545932d85d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__71bd74024f4fd12f0ed0a4c541ea24f774d8a2d56b2b84a2fac3d54685c9e508
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0c9582bf774501191c38e5584b28171153cc00f352829f4c01aea6d2b71f638c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac63ad4047c280993169946f2ca4b7c72a4c332de1da9bc10e517fccc4d030c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__35ee1a5ea9d3929074ed6ed8151cc002d49ba67e8ba8ed84b1264b58631f9d5d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fe45e74455d88bba4ee71c9c97c8b1c508200e48d4ebff45f065f18edb41176b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__808cfa80a7d87168d5c5f111750b18a21d64378aff44743fca4392e01b69ebe2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerVolumeMount",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "name": "name",
        "mount_propagation": "mountPropagation",
        "read_only": "readOnly",
        "sub_path": "subPath",
    },
)
class DaemonSetV1SpecTemplateSpecContainerVolumeMount:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        name: builtins.str,
        mount_propagation: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        sub_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param mount_path: Path within the container at which the volume should be mounted. Must not contain ':'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_path DaemonSetV1#mount_path}
        :param name: This must match the Name of a Volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_propagation DaemonSetV1#mount_propagation}
        :param read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sub_path DaemonSetV1#sub_path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bb9130d2175eae4ad951a9f597d0c1680d69f8f74ce48029150818080a7275a5
            )
            check_type(
                argname="argument mount_path",
                value=mount_path,
                expected_type=type_hints["mount_path"],
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument mount_propagation",
                value=mount_propagation,
                expected_type=type_hints["mount_propagation"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument sub_path",
                value=sub_path,
                expected_type=type_hints["sub_path"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mount_path": mount_path,
            "name": name,
        }
        if mount_propagation is not None:
            self._values["mount_propagation"] = mount_propagation
        if read_only is not None:
            self._values["read_only"] = read_only
        if sub_path is not None:
            self._values["sub_path"] = sub_path

    @builtins.property
    def mount_path(self) -> builtins.str:
        """Path within the container at which the volume should be mounted. Must not contain ':'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_path DaemonSetV1#mount_path}
        """
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        """This must match the Name of a Volume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mount_propagation(self) -> typing.Optional[builtins.str]:
        """Mount propagation mode.

        mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_propagation DaemonSetV1#mount_propagation}
        """
        result = self._values.get("mount_propagation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def sub_path(self) -> typing.Optional[builtins.str]:
        """Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sub_path DaemonSetV1#sub_path}
        """
        result = self._values.get("sub_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecContainerVolumeMount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecContainerVolumeMountList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerVolumeMountList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__df77ed64da9928593b60a560fcbcc86ded67e65f2e90205bfb81a808ff3dca8c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecContainerVolumeMountOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8eb47705ed424f64d9ea9b6121cd523f51e128a39c1b94c579072946c4936400
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecContainerVolumeMountOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a3a710f9726deb7d34399d0bfec45a1ad12481542f715a0a6156f90cc6f133ec
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__765a9a7e19133326f8197dda0c63a11a36b9d86cdbeaf61489359426e9250bc0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__27bc8d19ac46619e5efdfc1ba81b3d67f8cffa147bf318ca9b8df8de281cb493
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerVolumeMount],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainerVolumeMount],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecContainerVolumeMount],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__389a8cac35203e79781b49fbafdc4f0e477ba05ef1d461a51b6c0301c69d364e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecContainerVolumeMountOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecContainerVolumeMountOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0111aac91c4177be35759907d4432c9dfeabb404c9026ac4d681fd3292d4bbd
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetMountPropagation")
    def reset_mount_propagation(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMountPropagation", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetSubPath")
    def reset_sub_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubPath", []))

    @builtins.property
    @jsii.member(jsii_name="mountPathInput")
    def mount_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "mountPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="mountPropagationInput")
    def mount_propagation_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "mountPropagationInput")
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="subPathInput")
    def sub_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "subPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="mountPath")
    def mount_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mountPath"))

    @mount_path.setter
    def mount_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d652daa13b9753654fb14f27beff3998f7157b31c4c16b9bf3b3af20e53e276c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mountPath", value)

    @builtins.property
    @jsii.member(jsii_name="mountPropagation")
    def mount_propagation(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mountPropagation"))

    @mount_propagation.setter
    def mount_propagation(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b8592796208384b3833ca2bd0c5ee4f4e27e8500aaf2cad8d8647b3c31d81f2e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mountPropagation", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7087fe46b63179b450f48872836b9def0e0fadd46284d05a10c8ff0da04fe766
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bc8f21446c614a30587b1452bc6129f5d987f7bc43bce6a5588701731a351efe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="subPath")
    def sub_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subPath"))

    @sub_path.setter
    def sub_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1de2d55bf2deee5e8351c4516543a9504b39fdd58607563b2b02d41fc5053fa3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "subPath", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerVolumeMount
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecContainerVolumeMount,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecContainerVolumeMount,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__081c160e791bc51a39c7085461f4f96641de2dc098ec41732b8f296de9f8710f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecDnsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "nameservers": "nameservers",
        "option": "option",
        "searches": "searches",
    },
)
class DaemonSetV1SpecTemplateSpecDnsConfig:
    def __init__(
        self,
        *,
        nameservers: typing.Optional[typing.Sequence[builtins.str]] = None,
        option: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecDnsConfigOption",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        searches: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param nameservers: A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#nameservers DaemonSetV1#nameservers}
        :param option: option block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#option DaemonSetV1#option}
        :param searches: A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#searches DaemonSetV1#searches}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2a082483dd52eadc6d84dc114466bc8a89748570fc786e6c14bf4916894ca99
            )
            check_type(
                argname="argument nameservers",
                value=nameservers,
                expected_type=type_hints["nameservers"],
            )
            check_type(
                argname="argument option",
                value=option,
                expected_type=type_hints["option"],
            )
            check_type(
                argname="argument searches",
                value=searches,
                expected_type=type_hints["searches"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if nameservers is not None:
            self._values["nameservers"] = nameservers
        if option is not None:
            self._values["option"] = option
        if searches is not None:
            self._values["searches"] = searches

    @builtins.property
    def nameservers(self) -> typing.Optional[typing.List[builtins.str]]:
        """A list of DNS name server IP addresses.

        This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#nameservers DaemonSetV1#nameservers}
        """
        result = self._values.get("nameservers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def option(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecDnsConfigOption"],
        ]
    ]:
        """option block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#option DaemonSetV1#option}
        """
        result = self._values.get("option")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecDnsConfigOption"],
                ]
            ],
            result,
        )

    @builtins.property
    def searches(self) -> typing.Optional[typing.List[builtins.str]]:
        """A list of DNS search domains for host-name lookup.

        This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#searches DaemonSetV1#searches}
        """
        result = self._values.get("searches")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecDnsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecDnsConfigOption",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecDnsConfigOption:
    def __init__(
        self,
        *,
        name: builtins.str,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the option. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: Value of the option. Optional: Defaults to empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0761b9a1737c02d281a04abe1665c2f1dbd1eced3a95fd48a279461332ce3054
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the option.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """Value of the option. Optional: Defaults to empty.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecDnsConfigOption(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecDnsConfigOptionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecDnsConfigOptionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5dd64d48e9eb871d3f32391eeaeef97879232c764b0b101b388021809b9d7789
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecDnsConfigOptionOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ecd9825258cd5881f8eeaaf2083d6de1de9df20f3e830dc1e5440ee05bb91fad
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecDnsConfigOptionOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d97bfa53e6c0b92be3ffa3238d302a8625562fd1ace1e0186a4c868a68870684
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2de9d9bd1f9d9dc22abf0377929562893257456a552f6aabdd3cc0780bbde1e7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dea6aff9140b93bcddbe6448e07c61bc8fccf7fda7538f91d790041113f9eede
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecDnsConfigOption],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecDnsConfigOption],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecDnsConfigOption],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__10bc89f60c780d3b8073ad0ed7f4f54e597cf441f7e78487d402446542ab7c37
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecDnsConfigOptionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecDnsConfigOptionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__84ce3480537ae7c99f82cc069f9bedb59110d99e3200d6957bb424127021f263
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__54e73f402dd652b0c9016dad7f4c0b3340708a2762772701cdc8adb841548e65
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b68ebf2ffc216b3704072180eeb57b795951d418423bf913fd048cf307083c46
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecDnsConfigOption
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecDnsConfigOption,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecDnsConfigOption
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9ff272b8874e9d3822624caef2ef307d3af0119cb89ec37b96de8b3c4406ff61
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecDnsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecDnsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b5d1690b8957d6502a2705c5e2d6d154a64e02f894ba03be7747381fac9c4274
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putOption")
    def put_option(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecDnsConfigOption,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ed5311a45a7b3390752b1f6648a8e776b5962805a90966e4169ed01c61d2da7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putOption", [value]))

    @jsii.member(jsii_name="resetNameservers")
    def reset_nameservers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNameservers", []))

    @jsii.member(jsii_name="resetOption")
    def reset_option(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOption", []))

    @jsii.member(jsii_name="resetSearches")
    def reset_searches(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSearches", []))

    @builtins.property
    @jsii.member(jsii_name="option")
    def option(self) -> DaemonSetV1SpecTemplateSpecDnsConfigOptionList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecDnsConfigOptionList, jsii.get(self, "option")
        )

    @builtins.property
    @jsii.member(jsii_name="nameserversInput")
    def nameservers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "nameserversInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="optionInput")
    def option_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecDnsConfigOption],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecDnsConfigOption],
                ]
            ],
            jsii.get(self, "optionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="searchesInput")
    def searches_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "searchesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="nameservers")
    def nameservers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "nameservers"))

    @nameservers.setter
    def nameservers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__60ab48f47f49a3ea10ca630876b290eab77625655564ba483fbc3783dc503dc0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "nameservers", value)

    @builtins.property
    @jsii.member(jsii_name="searches")
    def searches(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "searches"))

    @searches.setter
    def searches(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3cac81acc4a94eef13cdb3475e48a47e453cf5f9e097d37f0abc876f54796207
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "searches", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecDnsConfig]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecDnsConfig],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecDnsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__82a54405b6f6bbfd5bf0d5bf082fc6a126d5dc0577902fa1f3e0861110da664e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecHostAliases",
    jsii_struct_bases=[],
    name_mapping={"hostnames": "hostnames", "ip": "ip"},
)
class DaemonSetV1SpecTemplateSpecHostAliases:
    def __init__(
        self,
        *,
        hostnames: typing.Sequence[builtins.str],
        ip: builtins.str,
    ) -> None:
        """
        :param hostnames: Hostnames for the IP address. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#hostnames DaemonSetV1#hostnames}
        :param ip: IP address of the host file entry. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#ip DaemonSetV1#ip}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__980b2ee925b2159ce34ea93f5171e660e2c11c0325c04ff771d5c24014c96011
            )
            check_type(
                argname="argument hostnames",
                value=hostnames,
                expected_type=type_hints["hostnames"],
            )
            check_type(argname="argument ip", value=ip, expected_type=type_hints["ip"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "hostnames": hostnames,
            "ip": ip,
        }

    @builtins.property
    def hostnames(self) -> typing.List[builtins.str]:
        """Hostnames for the IP address.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#hostnames DaemonSetV1#hostnames}
        """
        result = self._values.get("hostnames")
        assert result is not None, "Required property 'hostnames' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def ip(self) -> builtins.str:
        """IP address of the host file entry.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#ip DaemonSetV1#ip}
        """
        result = self._values.get("ip")
        assert result is not None, "Required property 'ip' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecHostAliases(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecHostAliasesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecHostAliasesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a83a918810e07df831463752019794c043a0809ff932bdf31caa0790215ae5d2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecHostAliasesOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__efede7d0c401debfd27fb713dcad788e77ddea6939e19c60127ca8f29f18f0f7
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecHostAliasesOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a7b16be4e663b6143c3798cbf81405f2591fa1a891c49249c9d5a82bafaa78d1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__956f429970c6472ed4181c9732870666c2d55d18f9af529b66f80a245c8ff888
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__81d703b04b5b6e6a98d362e0e9f88f6139b00c27cee2acd0357eeba8c780f984
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecHostAliases],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecHostAliases],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecHostAliases],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6b6a2ccd528d7a9c5d0755cb1f3bba90e2a661acda4d3e4c6f22a45dd4c5d60a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecHostAliasesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecHostAliasesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__05a7352e6a4c64e768ff4af74ebd9f1a381c52e81eaaf598e8439ce8dede35b8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="hostnamesInput")
    def hostnames_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "hostnamesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="ipInput")
    def ip_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipInput"))

    @builtins.property
    @jsii.member(jsii_name="hostnames")
    def hostnames(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "hostnames"))

    @hostnames.setter
    def hostnames(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__234592446332326921339e6019575e435b5c54c73fdf9310f1489d20d00e3a9e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostnames", value)

    @builtins.property
    @jsii.member(jsii_name="ip")
    def ip(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "ip"))

    @ip.setter
    def ip(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__eafcd32bc455aeaca37b82c5043ebc85e00f1c107da788aa9c4db24f3e65a6a3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "ip", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecHostAliases
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecHostAliases
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecHostAliases
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7315cbe4601e6792c93b3be6212d31efbfc7bd0c11ccc00fa782c1bb835bb1c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecImagePullSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class DaemonSetV1SpecTemplateSpecImagePullSecrets:
    def __init__(self, *, name: builtins.str) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d8db5261f58d05ce8ea51f98d1ec6096a50b05c7b0d94bb7d5b244331d8c09a7
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecImagePullSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecImagePullSecretsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecImagePullSecretsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e1596b5603430a9d803ba292c528cb4386bcb3b70c5177935b613ed698e11242
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecImagePullSecretsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb3071bfed5b9d8b34b0834c03fa1ef5201523a4fb1d0ad9d00e92a0e14065be
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecImagePullSecretsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__14fc0bff5c9fbcf3f51a5c53e7f257eb07e32d8408e70dda7a8c7674ec5b6725
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__98c8b7d81bc70b2e84f2bfcec8657d3696c8a466a9ac1e5d07cf91d9b4065d08
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0b3659faf8e4aa4011d99d76d1b3c5b59b53ecbd681a18b9c9c35357727e173c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecImagePullSecrets],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecImagePullSecrets],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecImagePullSecrets],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8e940aae8094a9390c72856e7f2cb9cc8d625a248ae28412937e8acc2b27f472
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecImagePullSecretsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecImagePullSecretsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__10427b4873fbe92c3863485e42f9a2bd575319f84583df53c1c5808530de9b4e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c10752078b55cd5fb103a7b14936a1590ac09055ce80ae62e6334ed95d72aed6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecImagePullSecrets
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecImagePullSecrets,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecImagePullSecrets
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__31a9adbfc30a87d6a4a8a5d8559879b1b8938ce5f1f7ea5e71732b48acb51156
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainer",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "args": "args",
        "command": "command",
        "env": "env",
        "env_from": "envFrom",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "lifecycle": "lifecycle",
        "liveness_probe": "livenessProbe",
        "port": "port",
        "readiness_probe": "readinessProbe",
        "resources": "resources",
        "security_context": "securityContext",
        "startup_probe": "startupProbe",
        "stdin": "stdin",
        "stdin_once": "stdinOnce",
        "termination_message_path": "terminationMessagePath",
        "termination_message_policy": "terminationMessagePolicy",
        "tty": "tty",
        "volume_mount": "volumeMount",
        "working_dir": "workingDir",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainer:
    def __init__(
        self,
        *,
        name: builtins.str,
        args: typing.Optional[typing.Sequence[builtins.str]] = None,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerEnv",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        env_from: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerEnvFrom",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        lifecycle: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecycle",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        liveness_probe: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        port: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerPort",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        readiness_probe: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        resources: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerResources",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        security_context: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContext",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        startup_probe: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbe",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        stdin: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        stdin_once: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        termination_message_path: typing.Optional[builtins.str] = None,
        termination_message_policy: typing.Optional[builtins.str] = None,
        tty: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        volume_mount: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerVolumeMount",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#args DaemonSetV1#args}
        :param command: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env DaemonSetV1#env}
        :param env_from: env_from block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env_from DaemonSetV1#env_from}
        :param image: Docker image name. More info: http://kubernetes.io/docs/user-guide/images. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image DaemonSetV1#image}
        :param image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/images#updating-images Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image_pull_policy DaemonSetV1#image_pull_policy}
        :param lifecycle: lifecycle block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lifecycle DaemonSetV1#lifecycle}
        :param liveness_probe: liveness_probe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#liveness_probe DaemonSetV1#liveness_probe}
        :param port: port block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param readiness_probe: readiness_probe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#readiness_probe DaemonSetV1#readiness_probe}
        :param resources: resources block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resources DaemonSetV1#resources}
        :param security_context: security_context block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#security_context DaemonSetV1#security_context}
        :param startup_probe: startup_probe block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#startup_probe DaemonSetV1#startup_probe}
        :param stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin DaemonSetV1#stdin}
        :param stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin_once DaemonSetV1#stdin_once}
        :param termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_path DaemonSetV1#termination_message_path}
        :param termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_policy DaemonSetV1#termination_message_policy}
        :param tty: Whether this container should allocate a TTY for itself. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tty DaemonSetV1#tty}
        :param volume_mount: volume_mount block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_mount DaemonSetV1#volume_mount}
        :param working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#working_dir DaemonSetV1#working_dir}
        """
        if isinstance(lifecycle, dict):
            lifecycle = DaemonSetV1SpecTemplateSpecInitContainerLifecycle(**lifecycle)
        if isinstance(liveness_probe, dict):
            liveness_probe = DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe(
                **liveness_probe
            )
        if isinstance(readiness_probe, dict):
            readiness_probe = DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe(
                **readiness_probe
            )
        if isinstance(resources, dict):
            resources = DaemonSetV1SpecTemplateSpecInitContainerResources(**resources)
        if isinstance(security_context, dict):
            security_context = DaemonSetV1SpecTemplateSpecInitContainerSecurityContext(
                **security_context
            )
        if isinstance(startup_probe, dict):
            startup_probe = DaemonSetV1SpecTemplateSpecInitContainerStartupProbe(
                **startup_probe
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2b2a41f233e80a9d598e66e8b8fdfa97247ea2dfa29f42dbec16dfaf07aa710
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument args", value=args, expected_type=type_hints["args"]
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument env_from",
                value=env_from,
                expected_type=type_hints["env_from"],
            )
            check_type(
                argname="argument image", value=image, expected_type=type_hints["image"]
            )
            check_type(
                argname="argument image_pull_policy",
                value=image_pull_policy,
                expected_type=type_hints["image_pull_policy"],
            )
            check_type(
                argname="argument lifecycle",
                value=lifecycle,
                expected_type=type_hints["lifecycle"],
            )
            check_type(
                argname="argument liveness_probe",
                value=liveness_probe,
                expected_type=type_hints["liveness_probe"],
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument readiness_probe",
                value=readiness_probe,
                expected_type=type_hints["readiness_probe"],
            )
            check_type(
                argname="argument resources",
                value=resources,
                expected_type=type_hints["resources"],
            )
            check_type(
                argname="argument security_context",
                value=security_context,
                expected_type=type_hints["security_context"],
            )
            check_type(
                argname="argument startup_probe",
                value=startup_probe,
                expected_type=type_hints["startup_probe"],
            )
            check_type(
                argname="argument stdin", value=stdin, expected_type=type_hints["stdin"]
            )
            check_type(
                argname="argument stdin_once",
                value=stdin_once,
                expected_type=type_hints["stdin_once"],
            )
            check_type(
                argname="argument termination_message_path",
                value=termination_message_path,
                expected_type=type_hints["termination_message_path"],
            )
            check_type(
                argname="argument termination_message_policy",
                value=termination_message_policy,
                expected_type=type_hints["termination_message_policy"],
            )
            check_type(
                argname="argument tty", value=tty, expected_type=type_hints["tty"]
            )
            check_type(
                argname="argument volume_mount",
                value=volume_mount,
                expected_type=type_hints["volume_mount"],
            )
            check_type(
                argname="argument working_dir",
                value=working_dir,
                expected_type=type_hints["working_dir"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if args is not None:
            self._values["args"] = args
        if command is not None:
            self._values["command"] = command
        if env is not None:
            self._values["env"] = env
        if env_from is not None:
            self._values["env_from"] = env_from
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if liveness_probe is not None:
            self._values["liveness_probe"] = liveness_probe
        if port is not None:
            self._values["port"] = port
        if readiness_probe is not None:
            self._values["readiness_probe"] = readiness_probe
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if startup_probe is not None:
            self._values["startup_probe"] = startup_probe
        if stdin is not None:
            self._values["stdin"] = stdin
        if stdin_once is not None:
            self._values["stdin_once"] = stdin_once
        if termination_message_path is not None:
            self._values["termination_message_path"] = termination_message_path
        if termination_message_policy is not None:
            self._values["termination_message_policy"] = termination_message_policy
        if tty is not None:
            self._values["tty"] = tty
        if volume_mount is not None:
            self._values["volume_mount"] = volume_mount
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the container specified as a DNS_LABEL.

        Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def args(self) -> typing.Optional[typing.List[builtins.str]]:
        """Arguments to the entrypoint.

        The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#args DaemonSetV1#args}
        """
        result = self._values.get("args")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Entrypoint array.

        Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/containers#containers-and-commands

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerEnv"],
        ]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env DaemonSetV1#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecInitContainerEnv"],
                ]
            ],
            result,
        )

    @builtins.property
    def env_from(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerEnvFrom"],
        ]
    ]:
        """env_from block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#env_from DaemonSetV1#env_from}
        """
        result = self._values.get("env_from")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecInitContainerEnvFrom"],
                ]
            ],
            result,
        )

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        """Docker image name. More info: http://kubernetes.io/docs/user-guide/images.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image DaemonSetV1#image}
        """
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        """Image pull policy.

        One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/images#updating-images

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#image_pull_policy DaemonSetV1#image_pull_policy}
        """
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lifecycle(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerLifecycle"]:
        """lifecycle block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lifecycle DaemonSetV1#lifecycle}
        """
        result = self._values.get("lifecycle")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerLifecycle"], result
        )

    @builtins.property
    def liveness_probe(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe"]:
        """liveness_probe block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#liveness_probe DaemonSetV1#liveness_probe}
        """
        result = self._values.get("liveness_probe")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe"],
            result,
        )

    @builtins.property
    def port(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerPort"],
        ]
    ]:
        """port block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecInitContainerPort"],
                ]
            ],
            result,
        )

    @builtins.property
    def readiness_probe(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe"]:
        """readiness_probe block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#readiness_probe DaemonSetV1#readiness_probe}
        """
        result = self._values.get("readiness_probe")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe"],
            result,
        )

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerResources"]:
        """resources block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resources DaemonSetV1#resources}
        """
        result = self._values.get("resources")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerResources"], result
        )

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerSecurityContext"]:
        """security_context block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#security_context DaemonSetV1#security_context}
        """
        result = self._values.get("security_context")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerSecurityContext"],
            result,
        )

    @builtins.property
    def startup_probe(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerStartupProbe"]:
        """startup_probe block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#startup_probe DaemonSetV1#startup_probe}
        """
        result = self._values.get("startup_probe")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerStartupProbe"],
            result,
        )

    @builtins.property
    def stdin(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether this container should allocate a buffer for stdin in the container runtime.

        If this is not set, reads from stdin in the container will always result in EOF.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin DaemonSetV1#stdin}
        """
        result = self._values.get("stdin")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def stdin_once(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether the container runtime should close the stdin channel after it has been opened by a single attach.

        When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#stdin_once DaemonSetV1#stdin_once}
        """
        result = self._values.get("stdin_once")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def termination_message_path(self) -> typing.Optional[builtins.str]:
        """Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.

        Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_path DaemonSetV1#termination_message_path}
        """
        result = self._values.get("termination_message_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination_message_policy(self) -> typing.Optional[builtins.str]:
        """Optional: Indicate how the termination message should be populated.

        File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#termination_message_policy DaemonSetV1#termination_message_policy}
        """
        result = self._values.get("termination_message_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tty(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether this container should allocate a TTY for itself.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tty DaemonSetV1#tty}
        """
        result = self._values.get("tty")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def volume_mount(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerVolumeMount"],
        ]
    ]:
        """volume_mount block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_mount DaemonSetV1#volume_mount}
        """
        result = self._values.get("volume_mount")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecInitContainerVolumeMount"],
                ]
            ],
            result,
        )

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        """Container's working directory.

        If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#working_dir DaemonSetV1#working_dir}
        """
        result = self._values.get("working_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnv",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value", "value_from": "valueFrom"},
)
class DaemonSetV1SpecTemplateSpecInitContainerEnv:
    def __init__(
        self,
        *,
        name: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_from: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param name: Name of the environment variable. Must be a C_IDENTIFIER. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        :param value_from: value_from block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value_from DaemonSetV1#value_from}
        """
        if isinstance(value_from, dict):
            value_from = DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom(
                **value_from
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a7179179f420ebce527f54da187da3e397ead8a41eb4d82321e9c96dbd4cb13e
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
            check_type(
                argname="argument value_from",
                value=value_from,
                expected_type=type_hints["value_from"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if value is not None:
            self._values["value"] = value
        if value_from is not None:
            self._values["value_from"] = value_from

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the environment variable. Must be a C_IDENTIFIER.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables.

        If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_from(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom"]:
        """value_from block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value_from DaemonSetV1#value_from}
        """
        result = self._values.get("value_from")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom"],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_ref": "configMapRef",
        "prefix": "prefix",
        "secret_ref": "secretRef",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvFrom:
    def __init__(
        self,
        *,
        config_map_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        prefix: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param config_map_ref: config_map_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_ref DaemonSetV1#config_map_ref}
        :param prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#prefix DaemonSetV1#prefix}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        if isinstance(config_map_ref, dict):
            config_map_ref = (
                DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef(
                    **config_map_ref
                )
            )
        if isinstance(secret_ref, dict):
            secret_ref = DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef(
                **secret_ref
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bfa795e62cb3b381316fda2404583ec895a8a80c45ce907b6c6c9b0e29d94f3d
            )
            check_type(
                argname="argument config_map_ref",
                value=config_map_ref,
                expected_type=type_hints["config_map_ref"],
            )
            check_type(
                argname="argument prefix",
                value=prefix,
                expected_type=type_hints["prefix"],
            )
            check_type(
                argname="argument secret_ref",
                value=secret_ref,
                expected_type=type_hints["secret_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map_ref is not None:
            self._values["config_map_ref"] = config_map_ref
        if prefix is not None:
            self._values["prefix"] = prefix
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def config_map_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef"]:
        """config_map_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_ref DaemonSetV1#config_map_ref}
        """
        result = self._values.get("config_map_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef"
            ],
            result,
        )

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        """An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#prefix DaemonSetV1#prefix}
        """
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef"]:
        """secret_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        result = self._values.get("secret_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef"],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerEnvFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a4192759429e150eaddea7952b2e4b47cee782a71544b181aea315a0ea0146d
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the ConfigMap must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__feed35e87f0ea794698ba78927fc230d830a1579c33b39c266bbc6ea290c4f7a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f0512f93a9943b4f5f3f56f429f5b8b59595975a66fddfd587c1532a0c9699a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__754eb4ba82832077cce6f150cedc882aae833bc8e257fd840c786aeee3f7172e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85e424dc410be4c0f5f374c5d97d9cc00268144734b92fce301e94147bb546bd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerEnvFromList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvFromList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e77ba9b33fa100e886f0fadcb735d75205d3448f8763899484dcd3197a4e8cf9
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerEnvFromOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e2f863f228bf9f13d55cd52dc8d8ccc818a827ede88116be3f3784ee8eb53e25
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerEnvFromOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__60433d39fc6b5634defec69f46054e96137736474f84fece933044abbe8f1f1c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f04c699dda204ce2c885fe409f6725b3837dab5dbc95f4598ea80456eab43611
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6df76f8e93c7c94bc8946a977ecf5c152317c5d6e416405ac5771b1229414a22
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnvFrom],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnvFrom],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnvFrom],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cd8fbb20f1f17dd4dda9b5c243fc5c7fb9f19564986057a4619b42aa0d4753ac
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerEnvFromOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvFromOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c88a2a38588a9726e8b6bdf8d42f7a72117007ff2836bdd91f5bfd52275511f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putConfigMapRef")
    def put_config_map_ref(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef(
            name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putConfigMapRef", [value]))

    @jsii.member(jsii_name="putSecretRef")
    def put_secret_ref(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef(
            name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putSecretRef", [value]))

    @jsii.member(jsii_name="resetConfigMapRef")
    def reset_config_map_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigMapRef", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetSecretRef")
    def reset_secret_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretRef", []))

    @builtins.property
    @jsii.member(jsii_name="configMapRef")
    def config_map_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRefOutputReference,
            jsii.get(self, "configMapRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretRef")
    def secret_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRefOutputReference",
            jsii.get(self, "secretRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="configMapRefInput")
    def config_map_ref_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef
            ],
            jsii.get(self, "configMapRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="secretRefInput")
    def secret_ref_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef"],
            jsii.get(self, "secretRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__abba38168f93b9e83efe3781967d2c0b2b6d184d37e7e27e0f975b22b3497ece
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "prefix", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainerEnvFrom
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerEnvFrom,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerEnvFrom,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4540f2224158c98cc3fd80f35ab549235c69ce58c6509a502296d3bc461fa0ff
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fd5e71cf85db640cafe50d9f62ed7c5979b768685d9b94ad63557e236859398e
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the Secret must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca92a17266f31d0f97bba21a535e2a55bc99a858ccd3944dab7a01ef9db1f66c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f36ffdbb8362f0a13c9f02b710014bb327775d3baabc92b165e2d8edb8dfb54a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2e0c3d7ccbf623917fc5e3deba0b15f1b1c8dcb4fdaec4e99ad43057d5c63778
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56e85fb1cdc890cb7647a835459929096c13914695f13bd966fbc71ad5483c74
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7d3acc3058bde3b7a7180ac977afc571ae2b49e65708af0700e810f1372df1cc
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fff76ebeb69614cd34fbc6327c4f7ca8013bccf64607071b0cde51252f648ef8
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerEnvOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bc65fcec264127b0f5c89f73a67cceb85d1a364f827f92b20f6bd6dc4c2ee22c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3235e2a808b86086d6296757a533b272e94766b6c7d29aaa777b9c6c94abb9dd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__626cc1b05282d33d7f93d3ef37df4f8668bce2f5ab5c919c27f7224df01f2230
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnv],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnv],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnv],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__07cb110ca8a43939f63fcef4cbbf6a5bd0d2594921343802dfe574e8faea51b7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8242c0f786a70f39b5982cac6de56707c47008139eae498c0c45e9fd28251b91
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putValueFrom")
    def put_value_from(
        self,
        *,
        config_map_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        resource_field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        secret_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param config_map_key_ref: config_map_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_key_ref DaemonSetV1#config_map_key_ref}
        :param field_ref: field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        :param resource_field_ref: resource_field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        :param secret_key_ref: secret_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_key_ref DaemonSetV1#secret_key_ref}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom(
            config_map_key_ref=config_map_key_ref,
            field_ref=field_ref,
            resource_field_ref=resource_field_ref,
            secret_key_ref=secret_key_ref,
        )

        return typing.cast(None, jsii.invoke(self, "putValueFrom", [value]))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @jsii.member(jsii_name="resetValueFrom")
    def reset_value_from(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValueFrom", []))

    @builtins.property
    @jsii.member(jsii_name="valueFrom")
    def value_from(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromOutputReference",
            jsii.get(self, "valueFrom"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueFromInput")
    def value_from_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom"],
            jsii.get(self, "valueFromInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8725c5238ebd978e7b8bb3890cc3412d077b1f9ccaa93d96d325e5c912e9fa91
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1026242be2536362059bf20b14ef4f4540f9fdce5f1d8def2a69580e4f8da1a9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainerEnv
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerEnv,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainerEnv
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__71b1d6829f20796c07b4715ab5a380f1d203c96c59f3145c6a3e59c86e35202a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_key_ref": "configMapKeyRef",
        "field_ref": "fieldRef",
        "resource_field_ref": "resourceFieldRef",
        "secret_key_ref": "secretKeyRef",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom:
    def __init__(
        self,
        *,
        config_map_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        resource_field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        secret_key_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param config_map_key_ref: config_map_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_key_ref DaemonSetV1#config_map_key_ref}
        :param field_ref: field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        :param resource_field_ref: resource_field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        :param secret_key_ref: secret_key_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_key_ref DaemonSetV1#secret_key_ref}
        """
        if isinstance(config_map_key_ref, dict):
            config_map_key_ref = (
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef(
                    **config_map_key_ref
                )
            )
        if isinstance(field_ref, dict):
            field_ref = DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef(
                **field_ref
            )
        if isinstance(resource_field_ref, dict):
            resource_field_ref = (
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef(
                    **resource_field_ref
                )
            )
        if isinstance(secret_key_ref, dict):
            secret_key_ref = (
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef(
                    **secret_key_ref
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__815073e145edb2f36ba63d7ffa3b4bdb0362c40d3910eede4b7d14fa7a2e2064
            )
            check_type(
                argname="argument config_map_key_ref",
                value=config_map_key_ref,
                expected_type=type_hints["config_map_key_ref"],
            )
            check_type(
                argname="argument field_ref",
                value=field_ref,
                expected_type=type_hints["field_ref"],
            )
            check_type(
                argname="argument resource_field_ref",
                value=resource_field_ref,
                expected_type=type_hints["resource_field_ref"],
            )
            check_type(
                argname="argument secret_key_ref",
                value=secret_key_ref,
                expected_type=type_hints["secret_key_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map_key_ref is not None:
            self._values["config_map_key_ref"] = config_map_key_ref
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref
        if secret_key_ref is not None:
            self._values["secret_key_ref"] = secret_key_ref

    @builtins.property
    def config_map_key_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef"
    ]:
        """config_map_key_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map_key_ref DaemonSetV1#config_map_key_ref}
        """
        result = self._values.get("config_map_key_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef"
            ],
            result,
        )

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef"
    ]:
        """field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        """
        result = self._values.get("field_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef"
            ],
            result,
        )

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef"
    ]:
        """resource_field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        """
        result = self._values.get("resource_field_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef"
            ],
            result,
        )

    @builtins.property
    def secret_key_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef"
    ]:
        """secret_key_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_key_ref DaemonSetV1#secret_key_ref}
        """
        result = self._values.get("secret_key_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__851aeb83325004e6a711f860ee32f3e039abfd9f0fd3fc6288f9ed0af2c47a4d
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key to select.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the ConfigMap or its key must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9a4768322f02b24c583ccdf0190f97e6b06719636c6ba4e38724b648d97bea31
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__43a5a04f8538b432e3a702b3b6a093fe3617d72d1eebe6b11c50ec09c71d0491
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a83a235a17f0d403b298f8f5ab50e9ced23f6e4e5fc192d7fcce1df7da586a2d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__854f2730e90c874bb9d97897c231e062573fd79e69b73487912a482570cb8bd5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__623759b2201e138f0a7da8f1a237790c475b9c21955b66acfe97d4a2aada589e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef",
    jsii_struct_bases=[],
    name_mapping={"api_version": "apiVersion", "field_path": "fieldPath"},
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d85d651bfe9bdc3c92e9d1853ddba98fe13bc2a51b180ebd34905b9c18cfefeb
            )
            check_type(
                argname="argument api_version",
                value=api_version,
                expected_type=type_hints["api_version"],
            )
            check_type(
                argname="argument field_path",
                value=field_path,
                expected_type=type_hints["field_path"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if field_path is not None:
            self._values["field_path"] = field_path

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        """Version of the schema the FieldPath is written in terms of, defaults to "v1".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        """
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def field_path(self) -> typing.Optional[builtins.str]:
        """Path of the field to select in the specified API version.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        result = self._values.get("field_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__49cf700f1abc5542a8b03ad8a7ecf987559c286f8aafbfac524f778ed83cefd8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetApiVersion")
    def reset_api_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiVersion", []))

    @jsii.member(jsii_name="resetFieldPath")
    def reset_field_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFieldPath", []))

    @builtins.property
    @jsii.member(jsii_name="apiVersionInput")
    def api_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "apiVersionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fieldPathInput")
    def field_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "fieldPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiVersion")
    def api_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiVersion"))

    @api_version.setter
    def api_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__92b93249d22d2597f62d2303cd9b6a98d61be2de11f679522c89710830d32a8e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiVersion", value)

    @builtins.property
    @jsii.member(jsii_name="fieldPath")
    def field_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fieldPath"))

    @field_path.setter
    def field_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__42945c17e4cd2837def7a5abd6a7102f6919fd73c0c63ad0cd590b08ddfe49c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fieldPath", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c2777d6dba36b0ebeb891c531dfd6b379588f783e516306a1838f7570fce52f3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a3a02523e9af29f897846a740b8f26f6f71a2dc7374b298ab2faa4c665b0da52
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putConfigMapKeyRef")
    def put_config_map_key_ref(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the ConfigMap or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef(
            key=key, name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putConfigMapKeyRef", [value]))

    @jsii.member(jsii_name="putFieldRef")
    def put_field_ref(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef(
            api_version=api_version, field_path=field_path
        )

        return typing.cast(None, jsii.invoke(self, "putFieldRef", [value]))

    @jsii.member(jsii_name="putResourceFieldRef")
    def put_resource_field_ref(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef(
            resource=resource, container_name=container_name, divisor=divisor
        )

        return typing.cast(None, jsii.invoke(self, "putResourceFieldRef", [value]))

    @jsii.member(jsii_name="putSecretKeyRef")
    def put_secret_key_ref(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key of the secret to select from. Must be a valid secret key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef(
            key=key, name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putSecretKeyRef", [value]))

    @jsii.member(jsii_name="resetConfigMapKeyRef")
    def reset_config_map_key_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigMapKeyRef", []))

    @jsii.member(jsii_name="resetFieldRef")
    def reset_field_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFieldRef", []))

    @jsii.member(jsii_name="resetResourceFieldRef")
    def reset_resource_field_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceFieldRef", []))

    @jsii.member(jsii_name="resetSecretKeyRef")
    def reset_secret_key_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretKeyRef", []))

    @builtins.property
    @jsii.member(jsii_name="configMapKeyRef")
    def config_map_key_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefOutputReference,
            jsii.get(self, "configMapKeyRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="fieldRef")
    def field_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRefOutputReference,
            jsii.get(self, "fieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRef")
    def resource_field_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRefOutputReference",
            jsii.get(self, "resourceFieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretKeyRef")
    def secret_key_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRefOutputReference",
            jsii.get(self, "secretKeyRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="configMapKeyRefInput")
    def config_map_key_ref_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef
            ],
            jsii.get(self, "configMapKeyRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="fieldRefInput")
    def field_ref_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef
            ],
            jsii.get(self, "fieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRefInput")
    def resource_field_ref_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef"
            ],
            jsii.get(self, "resourceFieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretKeyRefInput")
    def secret_key_ref_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef"
            ],
            jsii.get(self, "secretKeyRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__30066a807c79019cc62bdcb73e56e1865fc65836bdde8c607e4272c07513810c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__21deac683881dedca573caaf092cfb24d3ebdc3f7d8f519c1ebe8a07d3683c8f
            )
            check_type(
                argname="argument resource",
                value=resource,
                expected_type=type_hints["resource"],
            )
            check_type(
                argname="argument container_name",
                value=container_name,
                expected_type=type_hints["container_name"],
            )
            check_type(
                argname="argument divisor",
                value=divisor,
                expected_type=type_hints["divisor"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        """Resource to select.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        """
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}."""
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}."""
        result = self._values.get("divisor")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fe1b32d1b30de2f948486c72c9ccde7af455ea2ca137cf38404b6e5aafacfa8d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetContainerName")
    def reset_container_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerName", []))

    @jsii.member(jsii_name="resetDivisor")
    def reset_divisor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDivisor", []))

    @builtins.property
    @jsii.member(jsii_name="containerNameInput")
    def container_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "containerNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="divisorInput")
    def divisor_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "divisorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="resourceInput")
    def resource_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "resourceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="containerName")
    def container_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerName"))

    @container_name.setter
    def container_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__09faa7e6ffd7dd2bfeeec18c0aec3af8457557975600af831b9e509b7a8e0a2b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "containerName", value)

    @builtins.property
    @jsii.member(jsii_name="divisor")
    def divisor(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "divisor"))

    @divisor.setter
    def divisor(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0460edbfaf26db4267e05d62d3eafaa48d06bce32c35feae1c3e4816da140c4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "divisor", value)

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resource"))

    @resource.setter
    def resource(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0def6816539344111162a5d9b15dcd79f35c9811b50e18fbe4e08a1474dbd211
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "resource", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b941fdcd4c964e029d68e897d44b2d1d0c2961b21ca6c86f74228cce3ec80ab8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param key: The key of the secret to select from. Must be a valid secret key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Specify whether the Secret or its key must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d6b251fb60015a450297feb4aaba4b64d2ba59968e18b386c3f3fb144349066c
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key of the secret to select from. Must be a valid secret key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Specify whether the Secret or its key must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cee26406bf55db3c444617774e6a4ed15d1958a050efe7eefa917ce7a562450f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d19735776bda5e5df2d8599d216dbe4089729b609784bd30dff044c3d9a62fc8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__93a3e0b709afb5ec4d4863a918244290485024bbfc43e43c874043cf797ecf85
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e7333970abf15ef5ab7a82dd6500184bebbc02d865fdc7f148797bd6971be3e5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9136ffb8dde37b21da5d3a101dbd9b69654075d8c7ce03baf9152107484c84f4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecycle",
    jsii_struct_bases=[],
    name_mapping={"post_start": "postStart", "pre_stop": "preStop"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecycle:
    def __init__(
        self,
        *,
        post_start: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        pre_stop: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param post_start: post_start block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#post_start DaemonSetV1#post_start}
        :param pre_stop: pre_stop block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pre_stop DaemonSetV1#pre_stop}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c8581cc53d8b4f2f9854dc25fa24037aaddb02f4c8045b3e0cc2c16e9538b7d
            )
            check_type(
                argname="argument post_start",
                value=post_start,
                expected_type=type_hints["post_start"],
            )
            check_type(
                argname="argument pre_stop",
                value=pre_stop,
                expected_type=type_hints["pre_stop"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if post_start is not None:
            self._values["post_start"] = post_start
        if pre_stop is not None:
            self._values["pre_stop"] = pre_stop

    @builtins.property
    def post_start(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart"],
        ]
    ]:
        """post_start block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#post_start DaemonSetV1#post_start}
        """
        result = self._values.get("post_start")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def pre_stop(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop"],
        ]
    ]:
        """pre_stop block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pre_stop DaemonSetV1#pre_stop}
        """
        result = self._values.get("pre_stop")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerLifecycle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecInitContainerLifecycleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecycleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c9f56fcdeba9a5084bfbcec56adf5ee107a2d8f32aed5ebcec03aa6659a3e539
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPostStart")
    def put_post_start(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9f51b44b9015ab8933df76101b10c4353c45b1f1f2a8626395c247fc49f69fd5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putPostStart", [value]))

    @jsii.member(jsii_name="putPreStop")
    def put_pre_stop(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9a80aa2c913a03acc2a31da3b2806db1b6f6089db7a086c07643fbb25c22c37d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putPreStop", [value]))

    @jsii.member(jsii_name="resetPostStart")
    def reset_post_start(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPostStart", []))

    @jsii.member(jsii_name="resetPreStop")
    def reset_pre_stop(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreStop", []))

    @builtins.property
    @jsii.member(jsii_name="postStart")
    def post_start(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartList",
            jsii.get(self, "postStart"),
        )

    @builtins.property
    @jsii.member(jsii_name="preStop")
    def pre_stop(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopList",
            jsii.get(self, "preStop"),
        )

    @builtins.property
    @jsii.member(jsii_name="postStartInput")
    def post_start_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart"
                    ],
                ]
            ],
            jsii.get(self, "postStartInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="preStopInput")
    def pre_stop_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop"
                    ],
                ]
            ],
            jsii.get(self, "preStopInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecycle]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecycle],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecycle],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__87576a03f310c15e18e7809497d006a6ba9508ad836d5b215297455da35fad19
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec(
                **exec
            )
        if isinstance(http_get, dict):
            http_get = (
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet(
                    **http_get
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca012f3a14ae2451bacc9ca4a4903a43c1ea3e08913a24b1a3b6d814391aab80
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec"
    ]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec"
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet"
    ]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet"
            ],
            result,
        )

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket"
            ],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__027c8a8be5f03b135db5b54c1b257398ab4c906e026a64cb58e22b50f153d41a
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__de3a79e49b3b1c127da016fb4273cfe41ed30a52e13e1e0b3b59ca3451fcf3c0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fcaa2576b766f444a448884e47327e35d3550516edb0c83108a5f576fbee5e62
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b7af6eb32ca4349391f0e76d86a906232dda0c7460233130af53809559be1a8f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__604cb5618d07046ef78dba4974e5071df7bf2f5cdf11ff55806c057e4ac8d311
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85638a0f7a2889ecfdcc52ca577ff92e7e395c0a6e4b9ad3522dc0f4f350d027
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9f3b3f35e454d7bb06a2764b64a9f64e2dd16013c44e4b14a1cf3984285414e6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b72b1a715d32033afc236934dab97c04fe75da879a1e3cc506c6da3e30f93de
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b022ed822b96ce08ddf8f75dc235c2aa56929fd3c3d604e6d8ca07303542247f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d6df7d25afcf8c16ccd024695a78ee98edc14bcbb9e6c09f5b839517fe2e06d7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f694166ecf21b51bac1836a1a1a661fc20526542a2345d3c3c5722606ff592ae
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b5ac1deced68ad122ecb39297465cd8556b45c5808c29ea6073c94604a9745ca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a91cd2a55e37415b5bd73387a290a3b329747cdf0b1c651b8454a7aa060372b0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aada35cfc0c8a1ce025040b99671056e29fba08808f552ca561afa418be4a03c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7946dfa2e83f5fa070efa112e59650bcaa3f3150b592cad755f088d310af884e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__430934791023faf4744b922a4172d256c13a7444a6643bfa880d08aed5d73c7c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5f2e711140fbce27f43e0b75dfffa9d308c087f3a180d3811a79bf507b2c0d32
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__11c7517835228c54c5e4c8797044adb938b478f8869fea5e49a7b04f82a4ed98
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> (
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderList
    ):
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d844bf9a610b783335658d25b4f901c19363a40ded026a8409c89adf115c5c95
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9a5d651179dc2a25f370e7940e4e91995171fba448c4405568890a8c21531e3d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__31b88c91e87e1c980bee17ee3e97144faa463fa18a22cd76865a945ee1bff2d4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08874e6a18f1dfc7b29a6916743acedb0886c5f9db5f8469a51c310a55754ff1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__751282e397bad8568c336187ac520ad209a14ea8ebed3cd8ae2918444b210aa8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c5de61f3c114d9b698a960ff728515400162813b9dcd467b0f6926e53b902c1
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__405010d38bb57d3da565e1fc65095e7c79cf8caa45ef59628d249663535c1957
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__36a58914be0a309c155b0f88a0a15ca2d2d16d898b15ad31a4aa23cff994a328
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__730fd0e57d708cd43ae813dbca2521b0d63a7f38c30ebd2e09d0ec7350cd6223
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__644a2ac8087893276748f4c77293ce1608ac802b013b0c1fbac6f4a65cff6cdd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dbdfab0fbcb5dcfaaec4307706c0a4adcb874b29f395cc520f55fff76713ba86
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c0959e242534f2481337ab367af2c6e6efc3de2d3326646f008cf4f2b7e29ab4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec(
            command=command
        )

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2f2e9281824f819ddeed60b3d72a2ffca98a68e6467eb6100108a5ea8382ca0f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> (
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetOutputReference
    ):
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec
            ],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet
            ],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__636a5a0638a904978d598768b359e26430b1b5c3c1564f313109c54dd74fcb20
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd1ab3a78718d6e367809c389df0fd5d8ab1244b5b76af6f72c9ab9a589f1e53
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__936151da3bc74078da43b41b243c01260d8ebfac321a56316277dba88e4e1a0a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__41932a71e89441cad0af001e9121b393c15fbc589e1c8516aa5b0a17ea296148
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3ff5dd8e84d7fa534583dbbf0729d9780968546c318f69699aae4eeb420992c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c7810c2aa38305cd55c63135abbfac4e20faaec1627152c881995c042351df9b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b9919d00ebf2923ecdc948897961ce0790b1691e55cb2a8eee006e884ae665c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__61bd3ca0d595931f8c4fec50d3612bd491498b012dcf235aea7e29788bec3492
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a130293d53a8f61e746d50fa482629e2b45c9cde7c49f6dc64cfd8a6ff2b0b7b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f4b68ae21c7884bfd582e5eb487ff9c65e4924eab59dba780e2c09b16c5de376
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__210d15285c1d9e915b2c761e37547db74177b75916e9a4c874060b86a98fe898
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c7a6a4cf01bfa746f1d5fce3c4627319c00e2c1f9d049d187df1a872fe2c82f2
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec"
    ]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec"
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet"
    ]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet"
            ],
            result,
        )

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket"
            ],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3e05f309a17ee425d2da0990e10fffd5fe88dc6eb69129b7c5c229f6e1d68a1e
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e5821bf15edfb69ba83872c568b6b975c52fb4d90e87d55ee9bea6a31aeb7329
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d5599e8da8f43a1abbb6f7ac64c3a64132d651de12e18e35b44c059134afbb38
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__06b23318f1c401206ab7254289e6ef1df140fbb4454429ff492107e481ba4b8a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__68643bbfeb9a867d3e9e80607acf4c38d68a53c0866b50f703f9b58eb83ff308
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__690a2d9aba065d972aacf5b9efa3ae022d27639f39d39653cb012f0416fdb922
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56bce99f8a917b57e3aef35e3332b8a40e65e3f38e1915fcc20902e6bb0fd2b5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9117a26f77dc049f6196c2e03c3031b859002326aa9e45a7b76f94eac3d32134
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c81d78743dcd881ded8b77a649b8351af84639e1b25d70196d7e750154e32a2a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1365baefeb82c9c2d7082a35a28eb49422101d19a87af27cc67b764d70bfd86f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f19e6148b620ea88961923749af220f4f79b0b93ed0fd1372c2976e725be7715
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7591eb5927e879e0be1e9c9be1dc83a399ec146d24b61b142d34167afb7cef8c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cbd3a2b2d3a90c8aa9370abb4447e6f95e6ca36d8bf4fe029339502665bbccfe
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__987e599936585bc57eb5562ef21fbf7714833e83b6ffe5724dd16e4d17a403c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e759446242b3ed53e52c1c8d4376c3da6b2d45be6955a74781d07cf0be9b8c92
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba7c3a74e074d4a828afb4a60d51f972053a0245706ed7de3f11b0ff615c5c3f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2538d346fde778392e1486601b81dfbd605d837bc59d64effaaf220ac9655567
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ebca07d31bbc88bb6346d85a1ffea169bf6fd50039de175b195bc3e5a9a41e5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7adf8a3d8167a83df725712089621e704df8f0430043f0510686d8a5cd9c61a5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6fb1867af6cecb2bcfeeec63c56bd1fbb6126e1d8c91111d517d8e2fe269b9ce
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__89616624acd45b43ae4360fb76f463fd1665dce2c7d6bf2ac05404164d86c81a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac2d527c657a3262492f52ab7df052279129e1dc945f6687fe5a716f3e4a33c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd3878fd3e0f1fa4581edb2785af1722915fa95b800dc8ddcc8da1edf2da0898
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__854cac80f8c3403cf09c56c60e628590400adc3df5221a666d60a08ed5bdeaa8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08cf2ac9ca0219e2964078dbd2e471d561e362a8e4059a3c4605a3eb395bd943
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__55e6422de1bd15fe3e593f83a1b18bb557ae556a36d8689e7c85bb1bb8880835
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97ce0e8de32712795195fe9b66c391e7fd1168a47ac47e3e1890363f9952d601
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__46cc91d4b1fef7581d5940930dd6441c132779b2f40f3824071e0d36b7b87b10
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bcfe277e86049a9eff6af5441b861045a927baba73f27e141cf72fac0d6ca8b3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__02edb612285733ca1e5bcd950a1f378a845d69fd5bdd10f18e8726941f8ffc14
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec(
            command=command
        )

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e1da2cdb15b7bf6d674e46da1f9339462705bf9de521559a7da9101887fc4b46
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec
            ],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet
            ],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__80d1977187a2e3ee7e256cb6074c2f4de8803a850dd7d5d850198eb72989937a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3aff8c08a4071e29d9f5cbddeecfde02ae6f1fdc5d911a644fd0d121a010103f
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__58ee2b8359e099874a4e7ee31ab8f5d64a73ab425e91d527e244619d07b01806
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c2e637687dae7cf433aefb9d130f86742777b0fe8e1dcac5ac670b213368df1f
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4758fe952bc7e72e20837e08cd885750336c8d3cc324b0f8a1e64c4a672454e3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__db58a5e1f75e6d2920637c3c8eb101663595b03a0218372648d366f284375df9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc747b9cea53be313f00f9b4ac9fc6a4ccf20e640700baf4df502651ceebb58f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf16c1be46cd59c038f66edb4ba7542f9f44ae56a4c42d7cba4a962b4256d75c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0a46babefdea67c67063e23908cc88e94e56e237b2fcc115463153453c31ca74
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bf0744255d47f5ff8fdc3a184fd54a82c32157d81c36d1270ed5c66a247ff246
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c3e753ce67e5ec1f8769d4b14cf055efa45255c1fe838b269af5fd35b2ad3b2f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3b7ef341bdf751013f3d1934595ebef7a01ef9560411530d2a88440bfd7ac8cd
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f5ff6716a1648e4b58c9a70b991ea523ac7003c527b9f1c4c68360973bcd85f
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__da4fa82536beddb08b25f5bb8620a95f1610a2e54d23b579c81088e295a2b5f0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08cc2febb52c96bd1d1bd965bc596441b21b29ca4c154956499428243b4fbcaa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f299a2c2ad9bc74d1adf0b12df497572d649fca93e5a447c53777a3c6395dc20
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainer],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainer],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainer],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__858e6465a8e7b878ebea8361c3f3903d34a4f86533ed8fe70c39e6ceade85c1c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "grpc": "grpc",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e7e57ad2b1f5b9b1cad00f2444cf1b0ca2973a0381123078a7e90f7159df9331
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument failure_threshold",
                value=failure_threshold,
                expected_type=type_hints["failure_threshold"],
            )
            check_type(
                argname="argument grpc", value=grpc, expected_type=type_hints["grpc"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument initial_delay_seconds",
                value=initial_delay_seconds,
                expected_type=type_hints["initial_delay_seconds"],
            )
            check_type(
                argname="argument period_seconds",
                value=period_seconds,
                expected_type=type_hints["period_seconds"],
            )
            check_type(
                argname="argument success_threshold",
                value=success_threshold,
                expected_type=type_hints["success_threshold"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
            check_type(
                argname="argument timeout_seconds",
                value=timeout_seconds,
                expected_type=type_hints["timeout_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if grpc is not None:
            self._values["grpc"] = grpc
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec"
            ],
            result,
        )

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive failures for the probe to be considered failed after having succeeded.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        """
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def grpc(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc"],
        ]
    ]:
        """grpc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        """
        result = self._values.get("grpc")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet"
    ]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet"
            ],
            result,
        )

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        """
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        """How often (in seconds) to perform the probe.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        """
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive successes for the probe to be considered successful after having failed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        """
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket"
            ],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2d7fd4d7c0dfbe0c90b354a956567e17ae7485054a52c74a025cb244ebf75692
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1aee2f8285a6d9b6aaf17423644d4b67b398f62a5e8697e6b55de4693333ae92
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0900a9e3262fcb1ab8f35d28da88bf74c104722cac27fe04190caa6ce85f7d1c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fafd6ecd9e9449f5b40dd469bec62a376b8e63fb01a3a0077d408d35b9dd7450
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "service": "service"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc:
    def __init__(
        self,
        *,
        port: jsii.Number,
        service: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param port: Number of the port to access on the container. Number must be in the range 1 to 65535. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c4d91b8352e3cf77a76b490cabf20616b63539dbe23bdfbf33b6d32857a32258
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument service",
                value=service,
                expected_type=type_hints["service"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }
        if service is not None:
            self._values["service"] = service

    @builtins.property
    def port(self) -> jsii.Number:
        """Number of the port to access on the container. Number must be in the range 1 to 65535.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def service(self) -> typing.Optional[builtins.str]:
        """Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        result = self._values.get("service")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5a53903458f7419a1dbf4ffed3f8bc6df0edc42c2ae1afb460068ecc457bbb4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__313d47a4fe56a0198ace22d2974ff6a90523e3a8e3542257fdb30b72e5d4cc8f
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__07d919e27d1f76c5a46631a762d2ed1e3030fc7bda1aa0e3e9dbf567c58ca32e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b7bffa88890dc0d9bedf859c99a293fdbd2a5cc91c46c7b5fb7a40d1e70039f5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d4d44fe080a4e301543d17b5fb5301873e6886434c620c648f8664bace10c3de
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__587ebb8df0fe0b702742d8b70e44ecc49325470c615ac7bf80728c813325a131
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a24245e1d83a431c0c3effa6b0f14e5b03b9a0deadceba3419bbb128f71036b8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "serviceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c50b65f855b858e787b80b2bd4992926ecd3f24494b76f02d2dc72fc4485161
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "service"))

    @service.setter
    def service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2ba6ad89f4c4e7c461b419f6aaf657dd4c19058f7a3c47f6043dfbadb3154341
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "service", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1e97e148ba3f486933a8e18ea8f1cbda2fe301f915d0bad7300a14b976c0df67
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d12bedea2baa0be20c282b0d4fb11fb9589d53721a5534f7f09851b1f13c597c
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4e3046107eff97325078fcd2220553be8e044290ef061aad62806f073a06fbcd
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__90ac009a2435f1542201b23acb8929bb95e49d9cc8c9456944ac0447ca1d5791
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8106d21ae6752daba5fc4cc5eeaa42125086f6206efe183bb0b3e8d9059f0d91
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf6dda14374afe46c5369105b45425886cfc835f3ba423471e5cb5a82bb4540e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5dba40eb0dc0293127290dc4314e906f1102151f13ebc08eacffbb93421d8cad
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3a1b2b0c455044fe36425c117bfc167688f66349842580a02a1c4c5c78a72415
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4e9a173d588bd4b08969f248cb314a8a5afaa0005499b20f41e9fff935593ea7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b48130e147405f577b4dbbd11bffd7a7151528af0d66edad796bd9dacdb95502
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f67e82e45333f1cce21f9c615c01c03add62edb36f42baf979b831630bdf7cd6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d5a5567ecc9a39d7469e055f3b6e49e8603d1368c35b4d2147e058fd3b0342ef
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a7fa0904c93cb2a094eb0b8a10ee1b802b6ea74b9a9311e74b2c04ee8a59e96
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d6b3936387146c414380873bcd765bd119bda62f9aa1ac7e31eefb629102f89c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__592cdd3f076ffa44ab670e9f0e508b0572f8fc38358b4cdf0f98503242ef03d1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__eda55fe149fdc36a8d16ca38b216abe68d97a0205ebb6d93feccdb9f26f4986d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a04724a8d6b59a66284e8aa130eb806d75d9714f78bda81b05d598fc3f92d910
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8f25cce749883806ac8a5a19959d1d958ccc5c851f7f6c2762862d52d08f5cc7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d05885ea50fa270bf8281c49de29bbcf2c4a8a5d2a17ee415bab930307fb2ebe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9a5a6da788790779782f73f84ef17aa5aeaeab9ed23a250e37a4686aa394eb1a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e7c89b5593bf35d13957c07a88e5e8185fd55be46d834cde9cda228838f28926
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec(
            command=command
        )

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putGrpc")
    def put_grpc(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f5d7b8618a96e51c5f8f2eeb1155618c8424e7415265383bd6c6399f70aebaa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putGrpc", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d6921b75c6af87054694087148af68024c29442b52d6d85dc8c5d60c836a49a7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetGrpc")
    def reset_grpc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGrpc", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="grpc")
    def grpc(self) -> DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcList,
            jsii.get(self, "grpc"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="grpcInput")
    def grpc_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc
                    ],
                ]
            ],
            jsii.get(self, "grpcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet
            ],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ec9e2d10c41472acdfa07451eb4ac2f579d1f89cdcff6c134c3a19d3065ee087
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "failureThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__026097f2a170fdb9c7272661f2684764da3cb7b6b57d2c0d3afc484584bdb16f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "initialDelaySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3d6d4726c4e2190d0f246b415c0410bccf2798e1cb16990f240c7b23c9ac6d67
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "periodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5c2042d05788a5cf06de47cc6b25fd31787a6ea6e9457f9aab9fdb750c01a099
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "successThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__54db74dabf3f9b3f34060d24a6ff408e257b98ef35d995cc6a46f94eb1002665
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "timeoutSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3d5e3b4c7026b9ccd1109d4244fab748c68ef7be61d5d82052dd33d415e53ca7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__986631bcb6ff17f4565da34446c02a39ce4c101bcde57feb2a3624758e08d311
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__69f9f5a084f54d49f6d428924e187aacbac0e251c71815902b8566b7fe2dfef6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> (
        "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketOutputReference"
    ):
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ce82b80473572f75403bdcd2610e3ab7af1cafed674a47af4f8460082b65614e
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__53ca3d513b27fbc9987f4811a14cbdef9c5b3452612dd2a62ab865d1604e3bf8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4500479777e007f013efb553508ca2e8a38f7218b0e254404e4d1136daf9e482
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__993bea385fd4b1890e37c3b3e06e6020924a38046e4e155268cbab59e3b66548
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ce6234414467d841f3f790cbb3399b5793605cb0cfbdb5aefd0be0ea42f52cfe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__40ee5e87a1eb35a375be5e8adaec7b90d56366e78232e39ab9e0cc45af0da694
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fdfd8fdf1d7603a46c8034e51581bddb28f1d483b1966b373d792bffdc4e874c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba94039e0e4bc86030c78a996ccf528103c2777942409b4a4de475f326e7562a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__854cf7aa98897d296f2373e491aab6e9a3c60db4081cba2a4ec409936c438557
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerEnv,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__07d7857081b540f58c5f58850d2bc8486a889fa5ce71d47c83b1691b6db3850e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putEnvFrom")
    def put_env_from(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerEnvFrom,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1b59b35ee7673b257416643b22fe3950a64166eff4e2962c4b847915fc1ec36a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnvFrom", [value]))

    @jsii.member(jsii_name="putLifecycle")
    def put_lifecycle(
        self,
        *,
        post_start: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        pre_stop: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param post_start: post_start block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#post_start DaemonSetV1#post_start}
        :param pre_stop: pre_stop block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pre_stop DaemonSetV1#pre_stop}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLifecycle(
            post_start=post_start, pre_stop=pre_stop
        )

        return typing.cast(None, jsii.invoke(self, "putLifecycle", [value]))

    @jsii.member(jsii_name="putLivenessProbe")
    def put_liveness_probe(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe(
            exec=exec,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putLivenessProbe", [value]))

    @jsii.member(jsii_name="putPort")
    def put_port(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerPort",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__61e01d2188cf5ebaeb5f2a2f7355561894659ba72fd708a3e851082dc7521dbf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putPort", [value]))

    @jsii.member(jsii_name="putReadinessProbe")
    def put_readiness_probe(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe(
            exec=exec,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putReadinessProbe", [value]))

    @jsii.member(jsii_name="putResources")
    def put_resources(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        """
        :param limits: Describes the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#limits DaemonSetV1#limits}
        :param requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#requests DaemonSetV1#requests}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerResources(
            limits=limits, requests=requests
        )

        return typing.cast(None, jsii.invoke(self, "putResources", [value]))

    @jsii.member(jsii_name="putSecurityContext")
    def put_security_context(
        self,
        *,
        allow_privilege_escalation: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        capabilities: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        privileged: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        read_only_root_filesystem: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_group: typing.Optional[builtins.str] = None,
        run_as_non_root: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_user: typing.Optional[builtins.str] = None,
        seccomp_profile: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        se_linux_options: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#allow_privilege_escalation DaemonSetV1#allow_privilege_escalation}
        :param capabilities: capabilities block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#capabilities DaemonSetV1#capabilities}
        :param privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#privileged DaemonSetV1#privileged}
        :param read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only_root_filesystem DaemonSetV1#read_only_root_filesystem}
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        :param seccomp_profile: seccomp_profile block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        :param se_linux_options: se_linux_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerSecurityContext(
            allow_privilege_escalation=allow_privilege_escalation,
            capabilities=capabilities,
            privileged=privileged,
            read_only_root_filesystem=read_only_root_filesystem,
            run_as_group=run_as_group,
            run_as_non_root=run_as_non_root,
            run_as_user=run_as_user,
            seccomp_profile=seccomp_profile,
            se_linux_options=se_linux_options,
        )

        return typing.cast(None, jsii.invoke(self, "putSecurityContext", [value]))

    @jsii.member(jsii_name="putStartupProbe")
    def put_startup_probe(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerStartupProbe(
            exec=exec,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putStartupProbe", [value]))

    @jsii.member(jsii_name="putVolumeMount")
    def put_volume_mount(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerVolumeMount",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fd509c1fcf68507634825e9fe7f7fb28bcb45333ebfc1914d6a8dad66abbe979
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putVolumeMount", [value]))

    @jsii.member(jsii_name="resetArgs")
    def reset_args(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetArgs", []))

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvFrom")
    def reset_env_from(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvFrom", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetImagePullPolicy")
    def reset_image_pull_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagePullPolicy", []))

    @jsii.member(jsii_name="resetLifecycle")
    def reset_lifecycle(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLifecycle", []))

    @jsii.member(jsii_name="resetLivenessProbe")
    def reset_liveness_probe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLivenessProbe", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetReadinessProbe")
    def reset_readiness_probe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadinessProbe", []))

    @jsii.member(jsii_name="resetResources")
    def reset_resources(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResources", []))

    @jsii.member(jsii_name="resetSecurityContext")
    def reset_security_context(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecurityContext", []))

    @jsii.member(jsii_name="resetStartupProbe")
    def reset_startup_probe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStartupProbe", []))

    @jsii.member(jsii_name="resetStdin")
    def reset_stdin(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStdin", []))

    @jsii.member(jsii_name="resetStdinOnce")
    def reset_stdin_once(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStdinOnce", []))

    @jsii.member(jsii_name="resetTerminationMessagePath")
    def reset_termination_message_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTerminationMessagePath", []))

    @jsii.member(jsii_name="resetTerminationMessagePolicy")
    def reset_termination_message_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTerminationMessagePolicy", []))

    @jsii.member(jsii_name="resetTty")
    def reset_tty(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTty", []))

    @jsii.member(jsii_name="resetVolumeMount")
    def reset_volume_mount(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVolumeMount", []))

    @jsii.member(jsii_name="resetWorkingDir")
    def reset_working_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorkingDir", []))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> DaemonSetV1SpecTemplateSpecInitContainerEnvList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerEnvList, jsii.get(self, "env")
        )

    @builtins.property
    @jsii.member(jsii_name="envFrom")
    def env_from(self) -> DaemonSetV1SpecTemplateSpecInitContainerEnvFromList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerEnvFromList,
            jsii.get(self, "envFrom"),
        )

    @builtins.property
    @jsii.member(jsii_name="lifecycle")
    def lifecycle(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLifecycleOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLifecycleOutputReference,
            jsii.get(self, "lifecycle"),
        )

    @builtins.property
    @jsii.member(jsii_name="livenessProbe")
    def liveness_probe(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeOutputReference,
            jsii.get(self, "livenessProbe"),
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> "DaemonSetV1SpecTemplateSpecInitContainerPortList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerPortList", jsii.get(self, "port")
        )

    @builtins.property
    @jsii.member(jsii_name="readinessProbe")
    def readiness_probe(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeOutputReference",
            jsii.get(self, "readinessProbe"),
        )

    @builtins.property
    @jsii.member(jsii_name="resources")
    def resources(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerResourcesOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerResourcesOutputReference",
            jsii.get(self, "resources"),
        )

    @builtins.property
    @jsii.member(jsii_name="securityContext")
    def security_context(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextOutputReference",
            jsii.get(self, "securityContext"),
        )

    @builtins.property
    @jsii.member(jsii_name="startupProbe")
    def startup_probe(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeOutputReference",
            jsii.get(self, "startupProbe"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeMount")
    def volume_mount(self) -> "DaemonSetV1SpecTemplateSpecInitContainerVolumeMountList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerVolumeMountList",
            jsii.get(self, "volumeMount"),
        )

    @builtins.property
    @jsii.member(jsii_name="argsInput")
    def args_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "argsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envFromInput")
    def env_from_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnvFrom],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnvFrom],
                ]
            ],
            jsii.get(self, "envFromInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnv],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnv],
                ]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageInput"))

    @builtins.property
    @jsii.member(jsii_name="imagePullPolicyInput")
    def image_pull_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "imagePullPolicyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="lifecycleInput")
    def lifecycle_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecycle]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecycle],
            jsii.get(self, "lifecycleInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="livenessProbeInput")
    def liveness_probe_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe],
            jsii.get(self, "livenessProbeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerPort"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecInitContainerPort"],
                ]
            ],
            jsii.get(self, "portInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="readinessProbeInput")
    def readiness_probe_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe"],
            jsii.get(self, "readinessProbeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourcesInput")
    def resources_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerResources"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerResources"],
            jsii.get(self, "resourcesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="securityContextInput")
    def security_context_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerSecurityContext"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerSecurityContext"],
            jsii.get(self, "securityContextInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="startupProbeInput")
    def startup_probe_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerStartupProbe"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerStartupProbe"],
            jsii.get(self, "startupProbeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="stdinInput")
    def stdin_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "stdinInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="stdinOnceInput")
    def stdin_once_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "stdinOnceInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePathInput")
    def termination_message_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "terminationMessagePathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePolicyInput")
    def termination_message_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str],
            jsii.get(self, "terminationMessagePolicyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="ttyInput")
    def tty_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "ttyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeMountInput")
    def volume_mount_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerVolumeMount"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecInitContainerVolumeMount"],
                ]
            ],
            jsii.get(self, "volumeMountInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="workingDirInput")
    def working_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "workingDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="args")
    def args(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "args"))

    @args.setter
    def args(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2824307f8bc4f76b538891206546380645135c1d0ddf2d688ed25294a7a991d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "args", value)

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a2ce0a5f37087f9ae62070c47cb9f9ee1d361a56ec65593c5774095206a33b38
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "image"))

    @image.setter
    def image(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f218a5bf50cacde4fdcb25417fdddb591a6bdab5411fccd5aae13029da45f240
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "image", value)

    @builtins.property
    @jsii.member(jsii_name="imagePullPolicy")
    def image_pull_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagePullPolicy"))

    @image_pull_policy.setter
    def image_pull_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8c607d97a4150aa27747d42f75e86938d41cb525974b2b30912e5c5a9cc582c9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "imagePullPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__393a2d38ddcdf3d807df1e58c13ff0b81c7f8c5dc14781dced9386a4fe74c333
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="stdin")
    def stdin(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "stdin"),
        )

    @stdin.setter
    def stdin(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c6678d576a09a8dc48fcb6031cda0481ad3170d03759fe279ab3fe3f0e9d5988
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "stdin", value)

    @builtins.property
    @jsii.member(jsii_name="stdinOnce")
    def stdin_once(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "stdinOnce"),
        )

    @stdin_once.setter
    def stdin_once(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__66a74242eb3cfb9c4e124c7f6188937144fc95ac1fb7b0cedc94f671f1b4336c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "stdinOnce", value)

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePath")
    def termination_message_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "terminationMessagePath"))

    @termination_message_path.setter
    def termination_message_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a7767b5e1f516a0e011bd61a76f3c7ef0fceabd463cbf5dfbf97f7c425a75e46
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terminationMessagePath", value)

    @builtins.property
    @jsii.member(jsii_name="terminationMessagePolicy")
    def termination_message_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "terminationMessagePolicy"))

    @termination_message_policy.setter
    def termination_message_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a0c20f743230b7ec6a739363c57107fe05167bbaa86f3c8867dd69270dfa1c6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terminationMessagePolicy", value)

    @builtins.property
    @jsii.member(jsii_name="tty")
    def tty(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "tty"),
        )

    @tty.setter
    def tty(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d87aab59538e19e73773bded1b5024ede285f7f9bf32fd336693838089e2c2da
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "tty", value)

    @builtins.property
    @jsii.member(jsii_name="workingDir")
    def working_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "workingDir"))

    @working_dir.setter
    def working_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e33ee82219caabe10dc0b1c98eac9f639fbdfeda6fca009064b1af580aab330f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "workingDir", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainer
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainer,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainer
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__38c583575043fd3a6856c74b390c7851eb37d473f159bec6e3afd3b6ad0de70d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerPort",
    jsii_struct_bases=[],
    name_mapping={
        "container_port": "containerPort",
        "host_ip": "hostIp",
        "host_port": "hostPort",
        "name": "name",
        "protocol": "protocol",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerPort:
    def __init__(
        self,
        *,
        container_port: jsii.Number,
        host_ip: typing.Optional[builtins.str] = None,
        host_port: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        protocol: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_port DaemonSetV1#container_port}
        :param host_ip: What host IP to bind the external port to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_ip DaemonSetV1#host_ip}
        :param host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_port DaemonSetV1#host_port}
        :param name: If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#protocol DaemonSetV1#protocol}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1ad5789d11179ba661fd847280ff9dbd59c7d67747a311e33ee3d2db28465159
            )
            check_type(
                argname="argument container_port",
                value=container_port,
                expected_type=type_hints["container_port"],
            )
            check_type(
                argname="argument host_ip",
                value=host_ip,
                expected_type=type_hints["host_ip"],
            )
            check_type(
                argname="argument host_port",
                value=host_port,
                expected_type=type_hints["host_port"],
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument protocol",
                value=protocol,
                expected_type=type_hints["protocol"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_port": container_port,
        }
        if host_ip is not None:
            self._values["host_ip"] = host_ip
        if host_port is not None:
            self._values["host_port"] = host_port
        if name is not None:
            self._values["name"] = name
        if protocol is not None:
            self._values["protocol"] = protocol

    @builtins.property
    def container_port(self) -> jsii.Number:
        """Number of port to expose on the pod's IP address.

        This must be a valid port number, 0 < x < 65536.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_port DaemonSetV1#container_port}
        """
        result = self._values.get("container_port")
        assert result is not None, "Required property 'container_port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def host_ip(self) -> typing.Optional[builtins.str]:
        """What host IP to bind the external port to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_ip DaemonSetV1#host_ip}
        """
        result = self._values.get("host_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_port(self) -> typing.Optional[jsii.Number]:
        """Number of port to expose on the host.

        If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_port DaemonSetV1#host_port}
        """
        result = self._values.get("host_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """If specified, this must be an IANA_SVC_NAME and unique within the pod.

        Each named port in a pod must have a unique name. Name for the port that can be referred to by services

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def protocol(self) -> typing.Optional[builtins.str]:
        """Protocol for port. Must be UDP or TCP. Defaults to "TCP".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#protocol DaemonSetV1#protocol}
        """
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerPort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecInitContainerPortList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerPortList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ae211f36646aae53db0f7e49d81c14d04c787aa6bb65cc3c164e7e8891a47370
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerPortOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ddf4dacfb48bfda9ba47b875c65add248e20374917df6b61e52f3b38814d68e9
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerPortOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e725243fdcbf143445111045c223ced14ef316b1a6455e63ba36d52935e7893e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0e6adee863aace283ce066c57e8daacd0a9e9cf659009dec5424dfbf87d235aa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f0aa6b18c5ee31f2a27b249571a98b067698002cd9553efd74557704abc050a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerPort],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainerPort],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerPort],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__276a1316148d20e30ecaffc762c855562f263f82bc22f71bf382b2b344716fc9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerPortOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerPortOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__934714bed8cf22e13dc16c851abb45be1e117d25c861cc5814cdc4955eb1d277
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetHostIp")
    def reset_host_ip(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostIp", []))

    @jsii.member(jsii_name="resetHostPort")
    def reset_host_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostPort", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetProtocol")
    def reset_protocol(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProtocol", []))

    @builtins.property
    @jsii.member(jsii_name="containerPortInput")
    def container_port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "containerPortInput")
        )

    @builtins.property
    @jsii.member(jsii_name="hostIpInput")
    def host_ip_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostIpInput"))

    @builtins.property
    @jsii.member(jsii_name="hostPortInput")
    def host_port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "hostPortInput")
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="protocolInput")
    def protocol_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "protocolInput")
        )

    @builtins.property
    @jsii.member(jsii_name="containerPort")
    def container_port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "containerPort"))

    @container_port.setter
    def container_port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ff56656a42302d817a67ddbeb3788b5e75679e12ed265d0f0710db78b7ef97d1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "containerPort", value)

    @builtins.property
    @jsii.member(jsii_name="hostIp")
    def host_ip(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "hostIp"))

    @host_ip.setter
    def host_ip(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6136021d64394be9722b7e141eb62adc2755ad529461fffbf16e8655136fe51a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostIp", value)

    @builtins.property
    @jsii.member(jsii_name="hostPort")
    def host_port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "hostPort"))

    @host_port.setter
    def host_port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__62fb9a150a54a99d68c4a5a328a9aff2fb8258f9a5b01fa5948c524ed6c6b943
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostPort", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__43f4a5eeb264f4487379a2f75a387f0df6cd9c700fa8095aefd04c2c9dd3d7d5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="protocol")
    def protocol(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "protocol"))

    @protocol.setter
    def protocol(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c144e045907872e7d97c35a406d0efc17dd417f1306c4ba5cba1bbf170a991b7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "protocol", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainerPort
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerPort,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerPort,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d41680270daf614bff308943e659e7f5983973f1ae4bb4f99c19ecf335201169
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "grpc": "grpc",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1726680c3329592bf514ddbc495487a8262216bf07ff610350f05de2aa563084
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument failure_threshold",
                value=failure_threshold,
                expected_type=type_hints["failure_threshold"],
            )
            check_type(
                argname="argument grpc", value=grpc, expected_type=type_hints["grpc"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument initial_delay_seconds",
                value=initial_delay_seconds,
                expected_type=type_hints["initial_delay_seconds"],
            )
            check_type(
                argname="argument period_seconds",
                value=period_seconds,
                expected_type=type_hints["period_seconds"],
            )
            check_type(
                argname="argument success_threshold",
                value=success_threshold,
                expected_type=type_hints["success_threshold"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
            check_type(
                argname="argument timeout_seconds",
                value=timeout_seconds,
                expected_type=type_hints["timeout_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if grpc is not None:
            self._values["grpc"] = grpc
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec"
            ],
            result,
        )

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive failures for the probe to be considered failed after having succeeded.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        """
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def grpc(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc"],
        ]
    ]:
        """grpc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        """
        result = self._values.get("grpc")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet"
    ]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet"
            ],
            result,
        )

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        """
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        """How often (in seconds) to perform the probe.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        """
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive successes for the probe to be considered successful after having failed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        """
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket"
            ],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d4afec3d0e2e0c30855c8decce6481b8c6b97d3da5455b4e370b5f2685f17467
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ebd0efde2edfc29be42a4229c9a809a5f64bcbb5015de1585f84f6afa1218964
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c619041f830ce522e01e5d4cd33ff96ee95753e91247e69a0a4c702c8812d174
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6eccf48b0639bc736a2f47ec8d4fa676adf2d90a0ec39468ef9e1bd00d216115
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "service": "service"},
)
class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc:
    def __init__(
        self,
        *,
        port: jsii.Number,
        service: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param port: Number of the port to access on the container. Number must be in the range 1 to 65535. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__800a06f34cd9eeb96fbc604e82acf50fb3588025c6ca7c29c58578eff384c3e8
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument service",
                value=service,
                expected_type=type_hints["service"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }
        if service is not None:
            self._values["service"] = service

    @builtins.property
    def port(self) -> jsii.Number:
        """Number of the port to access on the container. Number must be in the range 1 to 65535.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def service(self) -> typing.Optional[builtins.str]:
        """Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        result = self._values.get("service")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c063a4f39f600022449ad411cfc6c523f52489cb032b8eea18fe370785bb98c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb8a17da73f2352db2c484e0d9a7f4c98924828483383650042b9dddc390ff23
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a10c948e61a972f550e80ccecc9eb500cf0aae7853596dcac1c0a0091d4787ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97836ebba7bf79386144f75486e87afce51eb1631a191e66721a1ec7c4026952
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__37c97c9dedf3447d8ec1bd1342785c793d6f241fd63204281159e35b456bf2c0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a6a92d7587235f8a43c4ac376216731109563a2b375230c3ca9def6c59bf3bc7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2ba341613a7a7d0180b769c300af120cc393143f96810a00423dc34386c305b2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "serviceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d6f5f18312e6aabc175541b9ca032dd2c1b4770a2625ed3f62263011ea3c2b00
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "service"))

    @service.setter
    def service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__64178ff47b245b3c2bd7d9851bbc2261a2a2d21c51b7959915a63c9a7b90c0ca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "service", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__20c66fd0ad7b4b93331deede4547d3db0902fd2f1b8c20b3de05fbf5af7a8431
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7a843fefbf6f300663a6413737a2ad93b6f980f4bd07755a4ca79cfcea80269d
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__680ee0954269d0f4b93cbb8a50abc793d81a6bb363de988ec766bf45ba8a3031
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6b391c4ff97c43b986d9dcf0c8ef184678841eb940ad72242b31d87bceb78cc1
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__700a342c6e5b9932e95b9a29ffeb6bc6a7a0a94c5c660f0f564e31c3d2659293
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e67675d882de7364f82a49e44a0fe32016d9ddeb7b3b6b71618e92eacf407143
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__854c70cfbba091551ffe9a95fb27e3c53ca53780ab7068084e85d480dee9f075
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__034e7bb08dd90db8d4c4ef0f946237df777920e44d7143396d950ce5a6f9c8b5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__831c4eb5256201365cfb4a82b3b6f19e1d8fdd48c0b91f30f3d41c798b95de2a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f1d79874dbfc3c4b303646efd4b6231bbd05c06b94bf8b9f6302cf948012ce43
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1ce6a8aca4d4aaf89b1ea71478f6c520892a344ff8a3d06977969dceccf3eede
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bed137f1cb0f946bf27c4775c09b44ce1fcb30eb2e260f4e4049232738a9535d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__027cf02070ea30832942523d691f83c116df914517cf55299630591376ab8377
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__82207d98a8e94869de45a87d6624160190c3dd72fea6031465cc0546b728a0e0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7845bec2bb0fe3a48b55ae14a43a2dcc0e6c8f050cc10c479b7a16acaef9f044
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5dc3c663af4e5fb4d0903802059b1be6ddac53004d50585ce1d55c8dda19a1a7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1a008353858b7cc57b377d20bdda7767523928b5fe747fe16e89464607ba60b9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__656d01a61db3c58dca3b440b36982f440f517bc5a4668a1f124f5ff7c1b68f36
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ccbf24a557826a6048f87af8898c02c14278dd84b249b0ba9488c2f03cdbcf16
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a130f1fabed68f138a9791ea0d7dac437d37cd218b63e20306e065f86d8ff889
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e8cc38b7878246b91c56a6d73e246f3f7628b5320fdb1b5538e4c2832ad79b30
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec(
            command=command
        )

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putGrpc")
    def put_grpc(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__be3d6a8ca5d3c3eb08ad60ecfe3e0ee8af2758e94dde7047a350aef796e3d8c8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putGrpc", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ffda6569d734ab79c4df4e5c3003a29461a77a910b2f125d47a74159f1271367
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetGrpc")
    def reset_grpc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGrpc", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="grpc")
    def grpc(self) -> DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcList,
            jsii.get(self, "grpc"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="grpcInput")
    def grpc_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc
                    ],
                ]
            ],
            jsii.get(self, "grpcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet
            ],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e661d5638ee72c0df87e02bea8abdb1436f4e2c0af526e6b065131b3bb08a6dc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "failureThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6191a7294427529cabae25b5f9ab1d521779b887d1b85eb9d31770f8b634cec9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "initialDelaySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f7c6fffab8a85905706b5b4e07d055641eb7e5257437f21ebfb2e79d89a5927
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "periodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__211e6720580e38cf8c2ab59669b0391de8f54bbfc5eb7c39d9756ecb7a927352
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "successThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__eb02921bafb719306d1143b102515bcb78dba1224f46aff2234124ffa018f1e1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "timeoutSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5bfca2c505fdc309dc3d825cc435d064a36e4d6f7591cb384b5204550fecb4cd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__89e94b2411386f5d246c447e5a51df317b084b9c52f85cc3d788911dd8b4a5b2
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__16b05bf3709e7aff24b954039c91410578b1280322a58b311bed1d7698b5b669
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> (
        "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketOutputReference"
    ):
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bf09d3e27138db25bb46e3d3acb884a503d1ef040c75e0bc952e5c32cb69e0a3
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__12298c5a43cb2596587bcd2b0b2d7f40b7f914bf7e3adff9909e1bd960779d8a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bc4cdd6f51d237e8ef7470d1cb363c708592ba42312b21319059d490bd93db3b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dee16be87d4d2db2dc614125f5bed06d2186f5c0133ff1049fb313b3daec27fd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8f61fe095c38729b023c8a6a95a1a841d1f3d1a25cf5834f6d90ba3afe7b706d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cec0f85ebd0da18e7799345fe3f5669a5063d5b4ed90080f680a48273f7ba4a4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f31d7c985cab5736f0e1ea5a4ceaa111206aa988e0e07bcaff7c7e40d49c24c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__261282eea9a1af17c4c429ad42c45287be1cef8ce666b5475178efa2bdef5333
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class DaemonSetV1SpecTemplateSpecInitContainerResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        """
        :param limits: Describes the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#limits DaemonSetV1#limits}
        :param requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/ Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#requests DaemonSetV1#requests}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__04a6c3e5193336d21924c30cf372666fbe175074c8342ea230b6a8fc6b6f449d
            )
            check_type(
                argname="argument limits",
                value=limits,
                expected_type=type_hints["limits"],
            )
            check_type(
                argname="argument requests",
                value=requests,
                expected_type=type_hints["requests"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Describes the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#limits DaemonSetV1#limits}
        """
        result = self._values.get("limits")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def requests(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Requests describes the minimum amount of compute resources required.

        If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#requests DaemonSetV1#requests}
        """
        result = self._values.get("requests")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecInitContainerResourcesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerResourcesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c100ed913c99c22089de35194bcf79e9f7a7bc11bcf1c86d9d818bb3868ffd11
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLimits")
    def reset_limits(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLimits", []))

    @jsii.member(jsii_name="resetRequests")
    def reset_requests(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequests", []))

    @builtins.property
    @jsii.member(jsii_name="limitsInput")
    def limits_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "limitsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="requestsInput")
    def requests_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "requestsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="limits")
    def limits(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "limits")
        )

    @limits.setter
    def limits(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c1e34193c950cfbcecf399fdfb0ebb58e436cf05869c281f6793e96924da9f42
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "limits", value)

    @builtins.property
    @jsii.member(jsii_name="requests")
    def requests(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "requests")
        )

    @requests.setter
    def requests(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e510abb3dcb6235448033c81f877431da8ca165bb6ad5a1547d41c1b117512ca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "requests", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerResources]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerResources],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerResources],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__23f7c9b144fb89f8d7b47854e5c161829cc3e3f7e6cce3339a8197b0bc0fd445
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "allow_privilege_escalation": "allowPrivilegeEscalation",
        "capabilities": "capabilities",
        "privileged": "privileged",
        "read_only_root_filesystem": "readOnlyRootFilesystem",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerSecurityContext:
    def __init__(
        self,
        *,
        allow_privilege_escalation: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        capabilities: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        privileged: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        read_only_root_filesystem: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_group: typing.Optional[builtins.str] = None,
        run_as_non_root: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_user: typing.Optional[builtins.str] = None,
        seccomp_profile: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        se_linux_options: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#allow_privilege_escalation DaemonSetV1#allow_privilege_escalation}
        :param capabilities: capabilities block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#capabilities DaemonSetV1#capabilities}
        :param privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#privileged DaemonSetV1#privileged}
        :param read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only_root_filesystem DaemonSetV1#read_only_root_filesystem}
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        :param seccomp_profile: seccomp_profile block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        :param se_linux_options: se_linux_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        """
        if isinstance(capabilities, dict):
            capabilities = (
                DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities(
                    **capabilities
                )
            )
        if isinstance(seccomp_profile, dict):
            seccomp_profile = (
                DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile(
                    **seccomp_profile
                )
            )
        if isinstance(se_linux_options, dict):
            se_linux_options = (
                DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions(
                    **se_linux_options
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__63fbd093abd5d824928f74e8941a04accc2ed9efe3a69d7889437d64a308a1aa
            )
            check_type(
                argname="argument allow_privilege_escalation",
                value=allow_privilege_escalation,
                expected_type=type_hints["allow_privilege_escalation"],
            )
            check_type(
                argname="argument capabilities",
                value=capabilities,
                expected_type=type_hints["capabilities"],
            )
            check_type(
                argname="argument privileged",
                value=privileged,
                expected_type=type_hints["privileged"],
            )
            check_type(
                argname="argument read_only_root_filesystem",
                value=read_only_root_filesystem,
                expected_type=type_hints["read_only_root_filesystem"],
            )
            check_type(
                argname="argument run_as_group",
                value=run_as_group,
                expected_type=type_hints["run_as_group"],
            )
            check_type(
                argname="argument run_as_non_root",
                value=run_as_non_root,
                expected_type=type_hints["run_as_non_root"],
            )
            check_type(
                argname="argument run_as_user",
                value=run_as_user,
                expected_type=type_hints["run_as_user"],
            )
            check_type(
                argname="argument seccomp_profile",
                value=seccomp_profile,
                expected_type=type_hints["seccomp_profile"],
            )
            check_type(
                argname="argument se_linux_options",
                value=se_linux_options,
                expected_type=type_hints["se_linux_options"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_privilege_escalation is not None:
            self._values["allow_privilege_escalation"] = allow_privilege_escalation
        if capabilities is not None:
            self._values["capabilities"] = capabilities
        if privileged is not None:
            self._values["privileged"] = privileged
        if read_only_root_filesystem is not None:
            self._values["read_only_root_filesystem"] = read_only_root_filesystem
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options

    @builtins.property
    def allow_privilege_escalation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process.

        This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#allow_privilege_escalation DaemonSetV1#allow_privilege_escalation}
        """
        result = self._values.get("allow_privilege_escalation")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def capabilities(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities"
    ]:
        """capabilities block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#capabilities DaemonSetV1#capabilities}
        """
        result = self._values.get("capabilities")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities"
            ],
            result,
        )

    @builtins.property
    def privileged(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Run container in privileged mode.

        Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#privileged DaemonSetV1#privileged}
        """
        result = self._values.get("privileged")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def read_only_root_filesystem(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether this container has a read-only root filesystem. Default is false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only_root_filesystem DaemonSetV1#read_only_root_filesystem}
        """
        result = self._values.get("read_only_root_filesystem")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def run_as_group(self) -> typing.Optional[builtins.str]:
        """The GID to run the entrypoint of the container process.

        Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        """
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_non_root(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Indicates that the container must run as a non-root user.

        If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        """
        result = self._values.get("run_as_non_root")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def run_as_user(self) -> typing.Optional[builtins.str]:
        """The UID to run the entrypoint of the container process.

        Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        """
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile"
    ]:
        """seccomp_profile block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        """
        result = self._values.get("seccomp_profile")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile"
            ],
            result,
        )

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions"
    ]:
        """se_linux_options block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        """
        result = self._values.get("se_linux_options")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerSecurityContext(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities",
    jsii_struct_bases=[],
    name_mapping={"add": "add", "drop": "drop"},
)
class DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities:
    def __init__(
        self,
        *,
        add: typing.Optional[typing.Sequence[builtins.str]] = None,
        drop: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param add: Added capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#add DaemonSetV1#add}
        :param drop: Removed capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#drop DaemonSetV1#drop}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__38eed2443450a9b898b945ccf8baa6e3bf2028c90b54f078a855d498c9782081
            )
            check_type(
                argname="argument add", value=add, expected_type=type_hints["add"]
            )
            check_type(
                argname="argument drop", value=drop, expected_type=type_hints["drop"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if add is not None:
            self._values["add"] = add
        if drop is not None:
            self._values["drop"] = drop

    @builtins.property
    def add(self) -> typing.Optional[typing.List[builtins.str]]:
        """Added capabilities.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#add DaemonSetV1#add}
        """
        result = self._values.get("add")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def drop(self) -> typing.Optional[typing.List[builtins.str]]:
        """Removed capabilities.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#drop DaemonSetV1#drop}
        """
        result = self._values.get("drop")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilitiesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilitiesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f0933fee788811c6303a7b59fcfda86e3a5ba658a54447112e58a910c402885f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAdd")
    def reset_add(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdd", []))

    @jsii.member(jsii_name="resetDrop")
    def reset_drop(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDrop", []))

    @builtins.property
    @jsii.member(jsii_name="addInput")
    def add_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "addInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dropInput")
    def drop_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "dropInput")
        )

    @builtins.property
    @jsii.member(jsii_name="add")
    def add(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "add"))

    @add.setter
    def add(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c9e5115ba1da43ffe6ed9c7b9f1636b0484f72f846e81a30fc538aaa4b33a9cf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "add", value)

    @builtins.property
    @jsii.member(jsii_name="drop")
    def drop(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "drop"))

    @drop.setter
    def drop(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1408588916973ba23df1933c179a92875289ba74b31c9e28684fe486798bfd18
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "drop", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__111521d4c3c657e5ac95ba893ad3ff6f19b2ac4f1aae4a6a5ef0004d542d62aa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerSecurityContextOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContextOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0b862239b66248201160e52b4d013434a228ef72c9dbad310e5e9b2bdf7a0b6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCapabilities")
    def put_capabilities(
        self,
        *,
        add: typing.Optional[typing.Sequence[builtins.str]] = None,
        drop: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param add: Added capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#add DaemonSetV1#add}
        :param drop: Removed capabilities. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#drop DaemonSetV1#drop}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities(
            add=add, drop=drop
        )

        return typing.cast(None, jsii.invoke(self, "putCapabilities", [value]))

    @jsii.member(jsii_name="putSeccompProfile")
    def put_seccomp_profile(
        self,
        *,
        localhost_profile: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        :param type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile(
            localhost_profile=localhost_profile, type=type
        )

        return typing.cast(None, jsii.invoke(self, "putSeccompProfile", [value]))

    @jsii.member(jsii_name="putSeLinuxOptions")
    def put_se_linux_options(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param level: Level is SELinux level label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        :param role: Role is a SELinux role label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        :param type: Type is a SELinux type label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        :param user: User is a SELinux user label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions(
            level=level, role=role, type=type, user=user
        )

        return typing.cast(None, jsii.invoke(self, "putSeLinuxOptions", [value]))

    @jsii.member(jsii_name="resetAllowPrivilegeEscalation")
    def reset_allow_privilege_escalation(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowPrivilegeEscalation", []))

    @jsii.member(jsii_name="resetCapabilities")
    def reset_capabilities(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCapabilities", []))

    @jsii.member(jsii_name="resetPrivileged")
    def reset_privileged(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivileged", []))

    @jsii.member(jsii_name="resetReadOnlyRootFilesystem")
    def reset_read_only_root_filesystem(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnlyRootFilesystem", []))

    @jsii.member(jsii_name="resetRunAsGroup")
    def reset_run_as_group(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsGroup", []))

    @jsii.member(jsii_name="resetRunAsNonRoot")
    def reset_run_as_non_root(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsNonRoot", []))

    @jsii.member(jsii_name="resetRunAsUser")
    def reset_run_as_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsUser", []))

    @jsii.member(jsii_name="resetSeccompProfile")
    def reset_seccomp_profile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSeccompProfile", []))

    @jsii.member(jsii_name="resetSeLinuxOptions")
    def reset_se_linux_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSeLinuxOptions", []))

    @builtins.property
    @jsii.member(jsii_name="capabilities")
    def capabilities(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilitiesOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilitiesOutputReference,
            jsii.get(self, "capabilities"),
        )

    @builtins.property
    @jsii.member(jsii_name="seccompProfile")
    def seccomp_profile(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfileOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfileOutputReference",
            jsii.get(self, "seccompProfile"),
        )

    @builtins.property
    @jsii.member(jsii_name="seLinuxOptions")
    def se_linux_options(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsOutputReference",
            jsii.get(self, "seLinuxOptions"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowPrivilegeEscalationInput")
    def allow_privilege_escalation_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "allowPrivilegeEscalationInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="capabilitiesInput")
    def capabilities_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities
            ],
            jsii.get(self, "capabilitiesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="privilegedInput")
    def privileged_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "privilegedInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="readOnlyRootFilesystemInput")
    def read_only_root_filesystem_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyRootFilesystemInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="runAsGroupInput")
    def run_as_group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runAsGroupInput")
        )

    @builtins.property
    @jsii.member(jsii_name="runAsNonRootInput")
    def run_as_non_root_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "runAsNonRootInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="runAsUserInput")
    def run_as_user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runAsUserInput")
        )

    @builtins.property
    @jsii.member(jsii_name="seccompProfileInput")
    def seccomp_profile_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile"
            ],
            jsii.get(self, "seccompProfileInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="seLinuxOptionsInput")
    def se_linux_options_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions"
            ],
            jsii.get(self, "seLinuxOptionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowPrivilegeEscalation")
    def allow_privilege_escalation(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "allowPrivilegeEscalation"),
        )

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3b5b9b47f1d10bda4f85db0c598397d73f15a4fce909514fa9ffecdaf8c2d551
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowPrivilegeEscalation", value)

    @builtins.property
    @jsii.member(jsii_name="privileged")
    def privileged(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "privileged"),
        )

    @privileged.setter
    def privileged(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c09d5ffef9817c6967ce547f4fafeac7303a80949dfb23fdf05c548a712475f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "privileged", value)

    @builtins.property
    @jsii.member(jsii_name="readOnlyRootFilesystem")
    def read_only_root_filesystem(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnlyRootFilesystem"),
        )

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4873dce355576c1f28fc492dc0cfd87f6e0bc053c00eae23572a09c63cde3cac
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnlyRootFilesystem", value)

    @builtins.property
    @jsii.member(jsii_name="runAsGroup")
    def run_as_group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runAsGroup"))

    @run_as_group.setter
    def run_as_group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c582c386a7d162396b804aa9a7a0da91ba8ea598ab6568f621823a92fb4d86f1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsGroup", value)

    @builtins.property
    @jsii.member(jsii_name="runAsNonRoot")
    def run_as_non_root(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "runAsNonRoot"),
        )

    @run_as_non_root.setter
    def run_as_non_root(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__360119548124f6b2495ac118bf3d5e61e423c59f5a61f39579f562929f6b9c4f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsNonRoot", value)

    @builtins.property
    @jsii.member(jsii_name="runAsUser")
    def run_as_user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runAsUser"))

    @run_as_user.setter
    def run_as_user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ded8fb42b475bbc19dd54d3a6db2c122736a1a032f95bb048918a5338acb503f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsUser", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerSecurityContext]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerSecurityContext],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerSecurityContext],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__333c68661a4482576aef3f2029172d11eeb804005c9c302281969c5acbf3dbfa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param level: Level is SELinux level label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        :param role: Role is a SELinux role label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        :param type: Type is a SELinux type label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        :param user: User is a SELinux user label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__274910baae7287cc0520a0d0d113f9a44d07a797fb88cf091ae6ed721e3f0428
            )
            check_type(
                argname="argument level", value=level, expected_type=type_hints["level"]
            )
            check_type(
                argname="argument role", value=role, expected_type=type_hints["role"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument user", value=user, expected_type=type_hints["user"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        """Level is SELinux level label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        """
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        """Role is a SELinux role label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        """
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type is a SELinux type label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        """User is a SELinux user label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dfa27a18bebf7ac681e00e2bcaa1a64f762b659fac6a2dab01cf3782d0a44a20
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLevel")
    def reset_level(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLevel", []))

    @jsii.member(jsii_name="resetRole")
    def reset_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRole", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="levelInput")
    def level_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "levelInput"))

    @builtins.property
    @jsii.member(jsii_name="roleInput")
    def role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "roleInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="level")
    def level(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "level"))

    @level.setter
    def level(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d9d8e577729ce628e71294c5b6c3f7444214227bdffeb6c4ee04a28c86e88993
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "level", value)

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "role"))

    @role.setter
    def role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__14d02ae606a0e33b55949da4634defcc854a11ec516b542ebc608e0545dbeb04
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "role", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d08a8343f25bf77c0f4c4129036677384dd9de9cab05232d11abd70c2fda328e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f61db6a053d0ac1a9afb215967bccf2bf9801ba55d6f9becd7c848e76b176478
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "user", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b3ac7914bcf77ce01d4e857b16fb4377a807e01638bf937225e88876906fc12e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"localhost_profile": "localhostProfile", "type": "type"},
)
class DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        localhost_profile: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        :param type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__24716d726e380d3258eedf27abfebc29f987d3ae6d524b5d258a0f34b6e308ba
            )
            check_type(
                argname="argument localhost_profile",
                value=localhost_profile,
                expected_type=type_hints["localhost_profile"],
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        """Localhost Profile indicates a profile defined in a file on the node should be used.

        The profile must be preconfigured on the node to work.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        """
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfileOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfileOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__153989d69e6f89c6d37d90cb7ca0855a1b44ae3d49195b78eb0d4382f74c581d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLocalhostProfile")
    def reset_localhost_profile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalhostProfile", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="localhostProfileInput")
    def localhost_profile_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "localhostProfileInput")
        )

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="localhostProfile")
    def localhost_profile(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "localhostProfile"))

    @localhost_profile.setter
    def localhost_profile(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__33bd43dcb18661e2397c8bdb155b032e6674a24189731de95285d4fe14811bf3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "localhostProfile", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8dc982d50b332f563495f0005aa7324cb269b07184763bdae1dbf416acb30857
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__494bda2bd132c0c63044a8954e13613a89cd4255b90e6298e06a84654abcce73
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "grpc": "grpc",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerStartupProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        grpc: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        http_get: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param exec: exec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        :param failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        :param grpc: grpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        :param http_get: http_get block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        :param initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        :param period_seconds: How often (in seconds) to perform the probe. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        :param success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        :param tcp_socket: tcp_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        :param timeout_seconds: Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        if isinstance(exec, dict):
            exec = DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet(
                **http_get
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a9b576b208feda386b346de2e296c7951d6a7d36614ecd73ec25c37568f07dfe
            )
            check_type(
                argname="argument exec", value=exec, expected_type=type_hints["exec"]
            )
            check_type(
                argname="argument failure_threshold",
                value=failure_threshold,
                expected_type=type_hints["failure_threshold"],
            )
            check_type(
                argname="argument grpc", value=grpc, expected_type=type_hints["grpc"]
            )
            check_type(
                argname="argument http_get",
                value=http_get,
                expected_type=type_hints["http_get"],
            )
            check_type(
                argname="argument initial_delay_seconds",
                value=initial_delay_seconds,
                expected_type=type_hints["initial_delay_seconds"],
            )
            check_type(
                argname="argument period_seconds",
                value=period_seconds,
                expected_type=type_hints["period_seconds"],
            )
            check_type(
                argname="argument success_threshold",
                value=success_threshold,
                expected_type=type_hints["success_threshold"],
            )
            check_type(
                argname="argument tcp_socket",
                value=tcp_socket,
                expected_type=type_hints["tcp_socket"],
            )
            check_type(
                argname="argument timeout_seconds",
                value=timeout_seconds,
                expected_type=type_hints["timeout_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if grpc is not None:
            self._values["grpc"] = grpc
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec"]:
        """exec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#exec DaemonSetV1#exec}
        """
        result = self._values.get("exec")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec"],
            result,
        )

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive failures for the probe to be considered failed after having succeeded.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#failure_threshold DaemonSetV1#failure_threshold}
        """
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def grpc(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc"],
        ]
    ]:
        """grpc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#grpc DaemonSetV1#grpc}
        """
        result = self._values.get("grpc")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet"]:
        """http_get block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_get DaemonSetV1#http_get}
        """
        result = self._values.get("http_get")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet"
            ],
            result,
        )

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after the container has started before liveness probes are initiated. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#initial_delay_seconds DaemonSetV1#initial_delay_seconds}
        """
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        """How often (in seconds) to perform the probe.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#period_seconds DaemonSetV1#period_seconds}
        """
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        """Minimum consecutive successes for the probe to be considered successful after having failed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#success_threshold DaemonSetV1#success_threshold}
        """
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket"
            ],
        ]
    ]:
        """tcp_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#tcp_socket DaemonSetV1#tcp_socket}
        """
        result = self._values.get("tcp_socket")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        """Number of seconds after which the probe times out. More info: http://kubernetes.io/docs/user-guide/pod-states#container-probes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#timeout_seconds DaemonSetV1#timeout_seconds}
        """
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerStartupProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4ad3839ff35b31d4c15b0e04761d359d956ab16545e9857986650548a6cb6fb9
            )
            check_type(
                argname="argument command",
                value=command,
                expected_type=type_hints["command"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        """Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem.

        The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__53edcbafea0a0d52c11548314369d5de7372d0c6018b43e98741b166c03bd007
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCommand")
    def reset_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCommand", []))

    @builtins.property
    @jsii.member(jsii_name="commandInput")
    def command_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "commandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="command")
    def command(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "command"))

    @command.setter
    def command(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__820590f03d66df17006a70ce5ddd368439a07b76e044eedd031b3a48c1b0e00a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "command", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f9688d568d82f10a303851d844d3e109865404fab421a77ea73c0c0debbe9cbd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "service": "service"},
)
class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc:
    def __init__(
        self,
        *,
        port: jsii.Number,
        service: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param port: Number of the port to access on the container. Number must be in the range 1 to 65535. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d4de413b88c671b6f90483076b229b3bca8bf2f8c98c73d9daa98c6d2b882db7
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument service",
                value=service,
                expected_type=type_hints["service"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }
        if service is not None:
            self._values["service"] = service

    @builtins.property
    def port(self) -> jsii.Number:
        """Number of the port to access on the container. Number must be in the range 1 to 65535.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def service(self) -> typing.Optional[builtins.str]:
        """Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service DaemonSetV1#service}
        """
        result = self._values.get("service")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7cf2ba5dc928fd1c041381b8c7541ce30f70f74735a195ab65d4ba08613f9db2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5d3e9744458cfb40bc58ebe04d93c1aa99bf8f5e30f0d466e5a449f3172d4a81
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1b4ad3f547055509e29d4e051ff7e3b693ac6ddf31d06683ffb75fa598772dc2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5dc5d5f863e6ceb55919724f1bc98dd60d87b237b2cf55c5d825ba104ca2c043
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c12c07e93e216a99409297399933d2bc26aaf6cad575dcf97e72299aebae61cd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a2303aaf07343248aa9d996d07a6c125e438dd5bdc4e85ded6db0f9dac2b9079
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8590c47cf61b1d954a8fccd0d1d376d48af52f028b3b3ca593ec7b9e87b3187c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "serviceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ff96060a23e0a9dbbc11a9d0a9ba2017ead096e898a148d9c43b94f20692f883
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "service"))

    @service.setter
    def service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__00078c595e6ae1e369ea01b091ea28534fbb3f3bcf5be28927ebe17b1b44882e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "service", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__141c05c05472977f9c493f0d2dec5412203c960728b6645afd651b93e4c29edd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "host": "host",
        "http_header": "httpHeader",
        "path": "path",
        "port": "port",
        "scheme": "scheme",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet:
    def __init__(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6a006840f4f325eeb1cc5595865f503fcc01ec23f48b099eeba931557cf9ae89
            )
            check_type(
                argname="argument host", value=host, expected_type=type_hints["host"]
            )
            check_type(
                argname="argument http_header",
                value=http_header,
                expected_type=type_hints["http_header"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
            check_type(
                argname="argument scheme",
                value=scheme,
                expected_type=type_hints["scheme"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if host is not None:
            self._values["host"] = host
        if http_header is not None:
            self._values["http_header"] = http_header
        if path is not None:
            self._values["path"] = path
        if port is not None:
            self._values["port"] = port
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        """Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        """
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_header(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader"
            ],
        ]
    ]:
        """http_header block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        """
        result = self._values.get("http_header")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path to access on the HTTP server.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        """Name or number of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        """Scheme to use for connecting to the host.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The header field name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: The header field value. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0b03c65a2153c9b42b4be7371bb8016a328ef5e65eba419db22845ecf767b5b
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The header field name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The header field value.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__25b23dc07fd4e698dcbff2a44525845bb2fb9b882e7c1ca407a6989e8bf1b345
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dad369352c8bbcd6e291361e6402485047b25bc453055ca41f3f1850d3b0d3aa
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d4d01c0624e8d064f4fc171cec4b86d57842fcf7c990288a53e10f7ba4009a7c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c76fe3aaacc274eafb0756dd2209eb81b347e0c2200b6c093fc375723626c9b1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fd3a46cf54a2b54c2d9a291a7fce470b72d12ac52919c0f3743353984fef16fc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__54a9282a11dbedccb818f97fe7ba588d41386bb3eb993fa99706a100f24f47e3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6756688116dcbc42ee2ddc32c63d6f89841b0aa0cfafa9c4e28b19bd13a65cce
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2e1004158347c69649175f3c32b2b7ec800bc0338df4155a2d3616dc60a0b08
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3874599a391e2f150aae95370a3a9537577666a2a2f7e9d455f25a484f61a2ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3bc9d8336710bbb53668a375a4aac26f3c882714a447bf6384c1301d9e0495ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__98f8731ff22a98a2b835f5bf31a454d30848922d9ae98d15854c175f1befc563
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHttpHeader")
    def put_http_header(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dc41cd8d8308a921be38160fcf784095869b41802360a4d3e984d39ce74fd484
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHttpHeader", [value]))

    @jsii.member(jsii_name="resetHost")
    def reset_host(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHost", []))

    @jsii.member(jsii_name="resetHttpHeader")
    def reset_http_header(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpHeader", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @builtins.property
    @jsii.member(jsii_name="httpHeader")
    def http_header(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderList,
            jsii.get(self, "httpHeader"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostInput")
    def host_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostInput"))

    @builtins.property
    @jsii.member(jsii_name="httpHeaderInput")
    def http_header_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader
                    ],
                ]
            ],
            jsii.get(self, "httpHeaderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="host")
    def host(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "host"))

    @host.setter
    def host(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6beed6d3a999c8be0d6660151468158e78e4070fe32ffbf242540b1d6075108f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "host", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5f65c4410fcc0ed289962a489da5ad42f5c14d544921a0c7b97daf295fd557d4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__03132e625427c825fd8466dfaab6f686a4f1b15260bb94469eb4b03f88ae3a94
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba4aef1f1d0b6b73bdac78d6c27de2ab525195b88f8f13c1f8fc4dd20ebe2c87
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scheme", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9fe18c7f70195c330f982b464f00600d7017d0496f064298a02b1d6c1372fd4f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ce4cdaaa80e66307db7e68b7b3b0f82883318f78e9e3d906a4098c5c7e6b5988
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putExec")
    def put_exec(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#command DaemonSetV1#command}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec(
            command=command
        )

        return typing.cast(None, jsii.invoke(self, "putExec", [value]))

    @jsii.member(jsii_name="putGrpc")
    def put_grpc(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ea01df1288cb13d49d4a18dd58c566076d39bd7c8a0a9721eb4b3a6a9b5958f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putGrpc", [value]))

    @jsii.member(jsii_name="putHttpGet")
    def put_http_get(
        self,
        *,
        host: typing.Optional[builtins.str] = None,
        http_header: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        path: typing.Optional[builtins.str] = None,
        port: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host DaemonSetV1#host}
        :param http_header: http_header block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#http_header DaemonSetV1#http_header}
        :param path: Path to access on the HTTP server. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        :param scheme: Scheme to use for connecting to the host. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#scheme DaemonSetV1#scheme}
        """
        value = DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet(
            host=host, http_header=http_header, path=path, port=port, scheme=scheme
        )

        return typing.cast(None, jsii.invoke(self, "putHttpGet", [value]))

    @jsii.member(jsii_name="putTcpSocket")
    def put_tcp_socket(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__256ab80d77a227a6144db2fb8c739c476b3feb18973d760336f4644a07be7022
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putTcpSocket", [value]))

    @jsii.member(jsii_name="resetExec")
    def reset_exec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExec", []))

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetGrpc")
    def reset_grpc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGrpc", []))

    @jsii.member(jsii_name="resetHttpGet")
    def reset_http_get(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpGet", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTcpSocket")
    def reset_tcp_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTcpSocket", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="exec")
    def exec(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExecOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExecOutputReference,
            jsii.get(self, "exec"),
        )

    @builtins.property
    @jsii.member(jsii_name="grpc")
    def grpc(self) -> DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcList,
            jsii.get(self, "grpc"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGet")
    def http_get(
        self,
    ) -> DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetOutputReference,
            jsii.get(self, "httpGet"),
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocket")
    def tcp_socket(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketList",
            jsii.get(self, "tcpSocket"),
        )

    @builtins.property
    @jsii.member(jsii_name="execInput")
    def exec_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec],
            jsii.get(self, "execInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="grpcInput")
    def grpc_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc
                    ],
                ]
            ],
            jsii.get(self, "grpcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpGetInput")
    def http_get_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet
            ],
            jsii.get(self, "httpGetInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tcpSocketInput")
    def tcp_socket_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket"
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket"
                    ],
                ]
            ],
            jsii.get(self, "tcpSocketInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba874f9e3d396eea04980f5091019e47e6e3d88603e6c5c36283b9b85ecf5306
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "failureThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fd920f06ceaddd956824ae31d5ebf332d1c5429a7b656aa6d97926fdd4e5d9ba
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "initialDelaySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f1ce391722ca94c3f7cc0916f619465bbbd6489a0c8375b10d0af875baf7abaa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "periodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c6c7d07bed085bfb68690f5cfd0118092b3cb67c50c292eb642deabaa67f8c03
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "successThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cd3bf758c6bf2304b3073bb4829a43dccbb51521cff012710105fae05e118ce0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "timeoutSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbe]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbe],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbe],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__666ea93d64efee713532c27b7733a3e9c72b4245298f838e28c00bd09e3dc7cf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port"},
)
class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket:
    def __init__(self, *, port: builtins.str) -> None:
        """
        :param port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6e76d91931805ea8735ef1f2aa694099b7f5f108f3486ad3633c4075171f87a0
            )
            check_type(
                argname="argument port", value=port, expected_type=type_hints["port"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "port": port,
        }

    @builtins.property
    def port(self) -> builtins.str:
        """Number or name of the port to access on the container.

        Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#port DaemonSetV1#port}
        """
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9e983b87d437a8ba8f97d5775e6d4e6e15b622214d49227a448d8b894e1ba71e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__33717f621aceb37311b4aa6685752c09b474175d696671225913f60c1dd308d5
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7ff3274bb707ce3cc52af6a6ca1e5a2116353a0b8c8bd81125ca92a0e6b3bdd8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b47f1757c27485405d7ae0c9863649a61ddf210ea2da4b31bb9af30aa0a70332
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__23b0440a287b4756ff9a88add16041090805e61c66705f7a9cf29dd68fa23753
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f2fb44ef306f17efed10f78ce770ade1387282562e82348ee7d82f9e6af7fb2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dc08e289f1d6a748d39c2930475c6dc04db92ca55ce450496255a036b538d9ef
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "port"))

    @port.setter
    def port(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2ef62da224d428cfbc0348d4f0a59a4074a22506a673809bfd77a2df71b3ebc2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__485fc0988eecb8bbb614effd5926b4ccc5d231c3678fcfb8fcdb586375b117d9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerVolumeMount",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "name": "name",
        "mount_propagation": "mountPropagation",
        "read_only": "readOnly",
        "sub_path": "subPath",
    },
)
class DaemonSetV1SpecTemplateSpecInitContainerVolumeMount:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        name: builtins.str,
        mount_propagation: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        sub_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param mount_path: Path within the container at which the volume should be mounted. Must not contain ':'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_path DaemonSetV1#mount_path}
        :param name: This must match the Name of a Volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_propagation DaemonSetV1#mount_propagation}
        :param read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sub_path DaemonSetV1#sub_path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8813cf19a91fe5de5d32b7e5eb039f71b5e681025a3357d681cd2d188031c953
            )
            check_type(
                argname="argument mount_path",
                value=mount_path,
                expected_type=type_hints["mount_path"],
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument mount_propagation",
                value=mount_propagation,
                expected_type=type_hints["mount_propagation"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument sub_path",
                value=sub_path,
                expected_type=type_hints["sub_path"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mount_path": mount_path,
            "name": name,
        }
        if mount_propagation is not None:
            self._values["mount_propagation"] = mount_propagation
        if read_only is not None:
            self._values["read_only"] = read_only
        if sub_path is not None:
            self._values["sub_path"] = sub_path

    @builtins.property
    def mount_path(self) -> builtins.str:
        """Path within the container at which the volume should be mounted. Must not contain ':'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_path DaemonSetV1#mount_path}
        """
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        """This must match the Name of a Volume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mount_propagation(self) -> typing.Optional[builtins.str]:
        """Mount propagation mode.

        mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mount_propagation DaemonSetV1#mount_propagation}
        """
        result = self._values.get("mount_propagation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def sub_path(self) -> typing.Optional[builtins.str]:
        """Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sub_path DaemonSetV1#sub_path}
        """
        result = self._values.get("sub_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecInitContainerVolumeMount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecInitContainerVolumeMountList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerVolumeMountList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85af27f985b813ba883ed00e749e410308815ce6eceaefcf57a4829d6d8ce006
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecInitContainerVolumeMountOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6eb32c2edb759d466577e34c4858df8072cd4ee311bc656584b6991ed4d38315
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecInitContainerVolumeMountOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a04cb05586b543989d6c24807acd2cb15d3d4c8886a464973d04ebab8667eb3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__78f7b5a8641ed4cebfa5b8f7071f72e3212752b387b9e52e15bfc05b5eedbe2e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9fe95621c88b1c1b32d07bf3128f25f00e09b53ddb8e94e9189dddc9f9081c0f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerVolumeMount],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainerVolumeMount],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecInitContainerVolumeMount],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47c4b630dc6b8e6b41abdf533bbcab9462d86872f389b95bf713072d28bc1345
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecInitContainerVolumeMountOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecInitContainerVolumeMountOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1048ee68cefa2a4dd94734b21ada9153b63fcbceb47177aa2736d3bbed29e679
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetMountPropagation")
    def reset_mount_propagation(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMountPropagation", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetSubPath")
    def reset_sub_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubPath", []))

    @builtins.property
    @jsii.member(jsii_name="mountPathInput")
    def mount_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "mountPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="mountPropagationInput")
    def mount_propagation_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "mountPropagationInput")
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="subPathInput")
    def sub_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "subPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="mountPath")
    def mount_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mountPath"))

    @mount_path.setter
    def mount_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aea9bb0c9b2dcd5c0bea09595b6875f0b24c55a8e5628bc6eb6725a7936e3005
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mountPath", value)

    @builtins.property
    @jsii.member(jsii_name="mountPropagation")
    def mount_propagation(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mountPropagation"))

    @mount_propagation.setter
    def mount_propagation(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b8c323408ec19f57f5a6c1ca985b1ed90d2390978b8639e55edb3663f9dc0c55
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mountPropagation", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3ba86f000ccfb8282911176e7829bdafd43ab3bcfa48c59316d6193a327580f2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__101a0951cde31ec001c9696792af16ecf08e8dbffa3f562f6fb24637e24b9aae
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="subPath")
    def sub_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subPath"))

    @sub_path.setter
    def sub_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bceb4f22715fc3f08b377e3ff570f44bd5fba52dea3fe1484aa87ee56dce3b0d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "subPath", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerVolumeMount,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecInitContainerVolumeMount,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecInitContainerVolumeMount,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f044a352ca96b27278f7a72bbada81ca0d07a7389c40c47022197c0c0fcdb56
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2076b43c3195d2147fe494b784b1f18395c7318f56ba8012dffe8e42ac9443f9
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAffinity")
    def put_affinity(
        self,
        *,
        node_affinity: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinity,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        pod_affinity: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinity,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        pod_anti_affinity: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param node_affinity: node_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_affinity DaemonSetV1#node_affinity}
        :param pod_affinity: pod_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_affinity DaemonSetV1#pod_affinity}
        :param pod_anti_affinity: pod_anti_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pod_anti_affinity DaemonSetV1#pod_anti_affinity}
        """
        value = DaemonSetV1SpecTemplateSpecAffinity(
            node_affinity=node_affinity,
            pod_affinity=pod_affinity,
            pod_anti_affinity=pod_anti_affinity,
        )

        return typing.cast(None, jsii.invoke(self, "putAffinity", [value]))

    @jsii.member(jsii_name="putContainer")
    def put_container(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainer,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8455cc713ece9596bb8eed7e1338283d8c99cbb20e4b853f14ab7ea0c16b9d3c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putContainer", [value]))

    @jsii.member(jsii_name="putDnsConfig")
    def put_dns_config(
        self,
        *,
        nameservers: typing.Optional[typing.Sequence[builtins.str]] = None,
        option: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecDnsConfigOption,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        searches: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param nameservers: A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#nameservers DaemonSetV1#nameservers}
        :param option: option block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#option DaemonSetV1#option}
        :param searches: A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#searches DaemonSetV1#searches}
        """
        value = DaemonSetV1SpecTemplateSpecDnsConfig(
            nameservers=nameservers, option=option, searches=searches
        )

        return typing.cast(None, jsii.invoke(self, "putDnsConfig", [value]))

    @jsii.member(jsii_name="putHostAliases")
    def put_host_aliases(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecHostAliases,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__17d36a684e8d2db199138edd13b23ec96dab9db20765e2eb626f0d9459312d11
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putHostAliases", [value]))

    @jsii.member(jsii_name="putImagePullSecrets")
    def put_image_pull_secrets(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecImagePullSecrets,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__38a324238bc47959c6dd885ec42dbaea1000e71facdc529d97d5830dd9b65429
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putImagePullSecrets", [value]))

    @jsii.member(jsii_name="putInitContainer")
    def put_init_container(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainer,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f952454d9e78c141e0e854cb8f0d09f0492011919341bfa5014a58809007dd5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putInitContainer", [value]))

    @jsii.member(jsii_name="putReadinessGate")
    def put_readiness_gate(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecReadinessGate",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__23982faedf01448549623fe7223c1d91b2c08cdb51071c1910096382a7fadcf7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putReadinessGate", [value]))

    @jsii.member(jsii_name="putSecurityContext")
    def put_security_context(
        self,
        *,
        fs_group: typing.Optional[builtins.str] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[builtins.str] = None,
        run_as_non_root: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_user: typing.Optional[builtins.str] = None,
        seccomp_profile: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        se_linux_options: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctl: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecSecurityContextSysctl",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_group DaemonSetV1#fs_group}
        :param fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_group_change_policy DaemonSetV1#fs_group_change_policy}
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        :param seccomp_profile: seccomp_profile block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        :param se_linux_options: se_linux_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        :param supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#supplemental_groups DaemonSetV1#supplemental_groups}
        :param sysctl: sysctl block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sysctl DaemonSetV1#sysctl}
        """
        value = DaemonSetV1SpecTemplateSpecSecurityContext(
            fs_group=fs_group,
            fs_group_change_policy=fs_group_change_policy,
            run_as_group=run_as_group,
            run_as_non_root=run_as_non_root,
            run_as_user=run_as_user,
            seccomp_profile=seccomp_profile,
            se_linux_options=se_linux_options,
            supplemental_groups=supplemental_groups,
            sysctl=sysctl,
        )

        return typing.cast(None, jsii.invoke(self, "putSecurityContext", [value]))

    @jsii.member(jsii_name="putToleration")
    def put_toleration(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecToleration",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f9098517da1ea2b4fabd2813c387a1abe327f81477bc3b115ba5c713bd1b0c8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putToleration", [value]))

    @jsii.member(jsii_name="putTopologySpreadConstraint")
    def put_topology_spread_constraint(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraint",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d09d78e1478d9aaa6230c7bdcdb38af3b76821419e69ff6d63b8d332a513fb5a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(
            None, jsii.invoke(self, "putTopologySpreadConstraint", [value])
        )

    @jsii.member(jsii_name="putVolume")
    def put_volume(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecVolume",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b6fbcf00ccd5ade73c1881058dd55e6934100b7a29a7d24bbaea9268221d1f62
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putVolume", [value]))

    @jsii.member(jsii_name="resetActiveDeadlineSeconds")
    def reset_active_deadline_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetActiveDeadlineSeconds", []))

    @jsii.member(jsii_name="resetAffinity")
    def reset_affinity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAffinity", []))

    @jsii.member(jsii_name="resetAutomountServiceAccountToken")
    def reset_automount_service_account_token(self) -> None:
        return typing.cast(
            None, jsii.invoke(self, "resetAutomountServiceAccountToken", [])
        )

    @jsii.member(jsii_name="resetContainer")
    def reset_container(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainer", []))

    @jsii.member(jsii_name="resetDnsConfig")
    def reset_dns_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDnsConfig", []))

    @jsii.member(jsii_name="resetDnsPolicy")
    def reset_dns_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDnsPolicy", []))

    @jsii.member(jsii_name="resetEnableServiceLinks")
    def reset_enable_service_links(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableServiceLinks", []))

    @jsii.member(jsii_name="resetHostAliases")
    def reset_host_aliases(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostAliases", []))

    @jsii.member(jsii_name="resetHostIpc")
    def reset_host_ipc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostIpc", []))

    @jsii.member(jsii_name="resetHostname")
    def reset_hostname(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostname", []))

    @jsii.member(jsii_name="resetHostNetwork")
    def reset_host_network(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostNetwork", []))

    @jsii.member(jsii_name="resetHostPid")
    def reset_host_pid(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostPid", []))

    @jsii.member(jsii_name="resetImagePullSecrets")
    def reset_image_pull_secrets(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagePullSecrets", []))

    @jsii.member(jsii_name="resetInitContainer")
    def reset_init_container(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitContainer", []))

    @jsii.member(jsii_name="resetNodeName")
    def reset_node_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeName", []))

    @jsii.member(jsii_name="resetNodeSelector")
    def reset_node_selector(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeSelector", []))

    @jsii.member(jsii_name="resetPriorityClassName")
    def reset_priority_class_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPriorityClassName", []))

    @jsii.member(jsii_name="resetReadinessGate")
    def reset_readiness_gate(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadinessGate", []))

    @jsii.member(jsii_name="resetRestartPolicy")
    def reset_restart_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRestartPolicy", []))

    @jsii.member(jsii_name="resetRuntimeClassName")
    def reset_runtime_class_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRuntimeClassName", []))

    @jsii.member(jsii_name="resetSchedulerName")
    def reset_scheduler_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSchedulerName", []))

    @jsii.member(jsii_name="resetSecurityContext")
    def reset_security_context(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecurityContext", []))

    @jsii.member(jsii_name="resetServiceAccountName")
    def reset_service_account_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceAccountName", []))

    @jsii.member(jsii_name="resetShareProcessNamespace")
    def reset_share_process_namespace(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetShareProcessNamespace", []))

    @jsii.member(jsii_name="resetSubdomain")
    def reset_subdomain(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubdomain", []))

    @jsii.member(jsii_name="resetTerminationGracePeriodSeconds")
    def reset_termination_grace_period_seconds(self) -> None:
        return typing.cast(
            None, jsii.invoke(self, "resetTerminationGracePeriodSeconds", [])
        )

    @jsii.member(jsii_name="resetToleration")
    def reset_toleration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetToleration", []))

    @jsii.member(jsii_name="resetTopologySpreadConstraint")
    def reset_topology_spread_constraint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTopologySpreadConstraint", []))

    @jsii.member(jsii_name="resetVolume")
    def reset_volume(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVolume", []))

    @builtins.property
    @jsii.member(jsii_name="affinity")
    def affinity(self) -> DaemonSetV1SpecTemplateSpecAffinityOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecAffinityOutputReference,
            jsii.get(self, "affinity"),
        )

    @builtins.property
    @jsii.member(jsii_name="container")
    def container(self) -> DaemonSetV1SpecTemplateSpecContainerList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecContainerList, jsii.get(self, "container")
        )

    @builtins.property
    @jsii.member(jsii_name="dnsConfig")
    def dns_config(self) -> DaemonSetV1SpecTemplateSpecDnsConfigOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecDnsConfigOutputReference,
            jsii.get(self, "dnsConfig"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostAliases")
    def host_aliases(self) -> DaemonSetV1SpecTemplateSpecHostAliasesList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecHostAliasesList, jsii.get(self, "hostAliases")
        )

    @builtins.property
    @jsii.member(jsii_name="imagePullSecrets")
    def image_pull_secrets(self) -> DaemonSetV1SpecTemplateSpecImagePullSecretsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecImagePullSecretsList,
            jsii.get(self, "imagePullSecrets"),
        )

    @builtins.property
    @jsii.member(jsii_name="initContainer")
    def init_container(self) -> DaemonSetV1SpecTemplateSpecInitContainerList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecInitContainerList,
            jsii.get(self, "initContainer"),
        )

    @builtins.property
    @jsii.member(jsii_name="readinessGate")
    def readiness_gate(self) -> "DaemonSetV1SpecTemplateSpecReadinessGateList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecReadinessGateList",
            jsii.get(self, "readinessGate"),
        )

    @builtins.property
    @jsii.member(jsii_name="securityContext")
    def security_context(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecSecurityContextOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecSecurityContextOutputReference",
            jsii.get(self, "securityContext"),
        )

    @builtins.property
    @jsii.member(jsii_name="toleration")
    def toleration(self) -> "DaemonSetV1SpecTemplateSpecTolerationList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecTolerationList", jsii.get(self, "toleration")
        )

    @builtins.property
    @jsii.member(jsii_name="topologySpreadConstraint")
    def topology_spread_constraint(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintList",
            jsii.get(self, "topologySpreadConstraint"),
        )

    @builtins.property
    @jsii.member(jsii_name="volume")
    def volume(self) -> "DaemonSetV1SpecTemplateSpecVolumeList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeList", jsii.get(self, "volume")
        )

    @builtins.property
    @jsii.member(jsii_name="activeDeadlineSecondsInput")
    def active_deadline_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "activeDeadlineSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="affinityInput")
    def affinity_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecAffinity]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecAffinity],
            jsii.get(self, "affinityInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="automountServiceAccountTokenInput")
    def automount_service_account_token_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "automountServiceAccountTokenInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="containerInput")
    def container_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainer],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecContainer],
                ]
            ],
            jsii.get(self, "containerInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="dnsConfigInput")
    def dns_config_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecDnsConfig]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecDnsConfig],
            jsii.get(self, "dnsConfigInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="dnsPolicyInput")
    def dns_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "dnsPolicyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="enableServiceLinksInput")
    def enable_service_links_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "enableServiceLinksInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostAliasesInput")
    def host_aliases_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecHostAliases],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecHostAliases],
                ]
            ],
            jsii.get(self, "hostAliasesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostIpcInput")
    def host_ipc_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "hostIpcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostnameInput")
    def hostname_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "hostnameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="hostNetworkInput")
    def host_network_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "hostNetworkInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostPidInput")
    def host_pid_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "hostPidInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="imagePullSecretsInput")
    def image_pull_secrets_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecImagePullSecrets],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecImagePullSecrets],
                ]
            ],
            jsii.get(self, "imagePullSecretsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="initContainerInput")
    def init_container_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainer],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecInitContainer],
                ]
            ],
            jsii.get(self, "initContainerInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nodeNameInput")
    def node_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "nodeNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="nodeSelectorInput")
    def node_selector_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "nodeSelectorInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="priorityClassNameInput")
    def priority_class_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "priorityClassNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="readinessGateInput")
    def readiness_gate_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecReadinessGate"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecReadinessGate"],
                ]
            ],
            jsii.get(self, "readinessGateInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="restartPolicyInput")
    def restart_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "restartPolicyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="runtimeClassNameInput")
    def runtime_class_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runtimeClassNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="schedulerNameInput")
    def scheduler_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "schedulerNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="securityContextInput")
    def security_context_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContext"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContext"],
            jsii.get(self, "securityContextInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="serviceAccountNameInput")
    def service_account_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "serviceAccountNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="shareProcessNamespaceInput")
    def share_process_namespace_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "shareProcessNamespaceInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="subdomainInput")
    def subdomain_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "subdomainInput")
        )

    @builtins.property
    @jsii.member(jsii_name="terminationGracePeriodSecondsInput")
    def termination_grace_period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number],
            jsii.get(self, "terminationGracePeriodSecondsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="tolerationInput")
    def toleration_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecToleration"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecToleration"],
                ]
            ],
            jsii.get(self, "tolerationInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="topologySpreadConstraintInput")
    def topology_spread_constraint_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecTopologySpreadConstraint"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecTopologySpreadConstraint"],
                ]
            ],
            jsii.get(self, "topologySpreadConstraintInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeInput")
    def volume_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolume"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolume"],
                ]
            ],
            jsii.get(self, "volumeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "activeDeadlineSeconds"))

    @active_deadline_seconds.setter
    def active_deadline_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__559e03269dcc1784ffb65460acc211009ac8b1d55517721f538e3c06a7348b0d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "activeDeadlineSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="automountServiceAccountToken")
    def automount_service_account_token(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "automountServiceAccountToken"),
        )

    @automount_service_account_token.setter
    def automount_service_account_token(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8a96266cefad29d235366fceb6d4b0d5a642e8ff274c9a39b2b2ff66e4574448
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "automountServiceAccountToken", value)

    @builtins.property
    @jsii.member(jsii_name="dnsPolicy")
    def dns_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dnsPolicy"))

    @dns_policy.setter
    def dns_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__588c2154320708d63e59a6126efac82eb404e41e54d177626d2bfeb09c0698ab
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dnsPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="enableServiceLinks")
    def enable_service_links(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "enableServiceLinks"),
        )

    @enable_service_links.setter
    def enable_service_links(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08302dca5f63f1a967387bf9bf6a2eb1abca557ab24fb1982b6f6577119f5dd0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "enableServiceLinks", value)

    @builtins.property
    @jsii.member(jsii_name="hostIpc")
    def host_ipc(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "hostIpc"),
        )

    @host_ipc.setter
    def host_ipc(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__de7fe3bb4f25fc7681fcb59686dba0b63dd51bd08b57fe33bd1aba537fd9e50f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostIpc", value)

    @builtins.property
    @jsii.member(jsii_name="hostname")
    def hostname(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "hostname"))

    @hostname.setter
    def hostname(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4791fd3bf369e79ad149b824bff1673b1a0ea62df2e5d67b5d9e332575db39ac
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostname", value)

    @builtins.property
    @jsii.member(jsii_name="hostNetwork")
    def host_network(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "hostNetwork"),
        )

    @host_network.setter
    def host_network(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a26a380059ea8969fb86c55c487c4638d15267d7535a9e185e7d372156ac667a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostNetwork", value)

    @builtins.property
    @jsii.member(jsii_name="hostPid")
    def host_pid(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "hostPid"),
        )

    @host_pid.setter
    def host_pid(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b1ee71ea8636841196d41a6dbe187f61ab451d7463b73a221090859cb4da490e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "hostPid", value)

    @builtins.property
    @jsii.member(jsii_name="nodeName")
    def node_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodeName"))

    @node_name.setter
    def node_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__82dde566511be2179868a113b90c652ad573e8a41b2e40a971e1d6cc2bba869f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "nodeName", value)

    @builtins.property
    @jsii.member(jsii_name="nodeSelector")
    def node_selector(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "nodeSelector")
        )

    @node_selector.setter
    def node_selector(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__043f0301234ee08c023c4c29ebd21eea4d5633f0e75c8f7a8944db5d4d575be1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "nodeSelector", value)

    @builtins.property
    @jsii.member(jsii_name="priorityClassName")
    def priority_class_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "priorityClassName"))

    @priority_class_name.setter
    def priority_class_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__244eb0a42e80c5849e34b11e630f3ceeeeaa16246d9cf52f588255e1dfec0916
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "priorityClassName", value)

    @builtins.property
    @jsii.member(jsii_name="restartPolicy")
    def restart_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "restartPolicy"))

    @restart_policy.setter
    def restart_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7b499e094ee7316e2d51f703ec39244e2494bd38555b7db131aaa3385a486969
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "restartPolicy", value)

    @builtins.property
    @jsii.member(jsii_name="runtimeClassName")
    def runtime_class_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runtimeClassName"))

    @runtime_class_name.setter
    def runtime_class_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__46dddbed3f456858695d043a7e2264cea0f67bd68bff2bf29e7d1f182845090e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runtimeClassName", value)

    @builtins.property
    @jsii.member(jsii_name="schedulerName")
    def scheduler_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "schedulerName"))

    @scheduler_name.setter
    def scheduler_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d10e874d911589032e5fb0a96662a147de6e03d9a43c6e0134a77e4c78d63d36
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "schedulerName", value)

    @builtins.property
    @jsii.member(jsii_name="serviceAccountName")
    def service_account_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceAccountName"))

    @service_account_name.setter
    def service_account_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0a4a0a91756a4ed533941cd3dad3cd0f48a39161aa5f8934daf482de0b55f7b0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "serviceAccountName", value)

    @builtins.property
    @jsii.member(jsii_name="shareProcessNamespace")
    def share_process_namespace(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "shareProcessNamespace"),
        )

    @share_process_namespace.setter
    def share_process_namespace(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__985505ec381e202db13870ce7b24bf5adff9a767a8a6a26e510d6408bcff83a8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "shareProcessNamespace", value)

    @builtins.property
    @jsii.member(jsii_name="subdomain")
    def subdomain(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subdomain"))

    @subdomain.setter
    def subdomain(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f5e8a18cb6b2c2b4241132b2fbe867f55a996b9b31fe01bf1ab51a81ca12d558
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "subdomain", value)

    @builtins.property
    @jsii.member(jsii_name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "terminationGracePeriodSeconds"))

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7179f51d746220fb53656be243eb01011276e6ffd6b8b440f5c0a6093b47aa2e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terminationGracePeriodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpec]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpec],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpec],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9b0fb85ba7416dc921a1a7236f9c639dbd1c3c70ea5d86b9996d052f159173e0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecReadinessGate",
    jsii_struct_bases=[],
    name_mapping={"condition_type": "conditionType"},
)
class DaemonSetV1SpecTemplateSpecReadinessGate:
    def __init__(self, *, condition_type: builtins.str) -> None:
        """
        :param condition_type: refers to a condition in the pod's condition list with matching type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#condition_type DaemonSetV1#condition_type}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4e31565c3cfb158f201bbcf3bff50993a15c6e6f4ea5303320f9c9a81e0cfd07
            )
            check_type(
                argname="argument condition_type",
                value=condition_type,
                expected_type=type_hints["condition_type"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "condition_type": condition_type,
        }

    @builtins.property
    def condition_type(self) -> builtins.str:
        """refers to a condition in the pod's condition list with matching type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#condition_type DaemonSetV1#condition_type}
        """
        result = self._values.get("condition_type")
        assert result is not None, "Required property 'condition_type' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecReadinessGate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecReadinessGateList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecReadinessGateList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ce529506e6fed9917a9206440fccf19d79c44b1e5be9f66d5ab768c828376b75
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecReadinessGateOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c2c9ed47dd428fb85c68b4ab3b3ecb737b626bad8d33848b373c7a793f67ebaf
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecReadinessGateOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5741c115b499767dc31d567234e9eb74f5eeb1cda2dfbedc66a0016a34177a2e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c26c067b6e1fa297749b5affb9194deb1f7232b1241a698dad0f479ded64576
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f6068eb0773db5754410902a561fd1a08c9f6fb81af4e3a73d25c320f2ca698c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecReadinessGate],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecReadinessGate],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecReadinessGate],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__badca0a77f4e99a0d8dfa979034e0eac5f205684baa5fe795a291fc0e82f167c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecReadinessGateOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecReadinessGateOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4d4393f3de60d82daca69d0e670892abefce15664435c932418cb90931a87033
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="conditionTypeInput")
    def condition_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "conditionTypeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="conditionType")
    def condition_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "conditionType"))

    @condition_type.setter
    def condition_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0087491f5567377e6beb3f52c6bb89d48eb23808522da8c01cb3140e70b56c80
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "conditionType", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecReadinessGate
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecReadinessGate,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecReadinessGate
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c50d28919a10843b7ce1d05ed27877c432d82d5ea596d6cd14449f778896a570
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctl": "sysctl",
    },
)
class DaemonSetV1SpecTemplateSpecSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[builtins.str] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[builtins.str] = None,
        run_as_non_root: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        run_as_user: typing.Optional[builtins.str] = None,
        seccomp_profile: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        se_linux_options: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctl: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecSecurityContextSysctl",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_group DaemonSetV1#fs_group}
        :param fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_group_change_policy DaemonSetV1#fs_group_change_policy}
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        :param seccomp_profile: seccomp_profile block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        :param se_linux_options: se_linux_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        :param supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#supplemental_groups DaemonSetV1#supplemental_groups}
        :param sysctl: sysctl block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sysctl DaemonSetV1#sysctl}
        """
        if isinstance(seccomp_profile, dict):
            seccomp_profile = DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile(
                **seccomp_profile
            )
        if isinstance(se_linux_options, dict):
            se_linux_options = DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions(
                **se_linux_options
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__25a24d7efa59128a3f6df55a93601ba341be320362950983d55022d891d17203
            )
            check_type(
                argname="argument fs_group",
                value=fs_group,
                expected_type=type_hints["fs_group"],
            )
            check_type(
                argname="argument fs_group_change_policy",
                value=fs_group_change_policy,
                expected_type=type_hints["fs_group_change_policy"],
            )
            check_type(
                argname="argument run_as_group",
                value=run_as_group,
                expected_type=type_hints["run_as_group"],
            )
            check_type(
                argname="argument run_as_non_root",
                value=run_as_non_root,
                expected_type=type_hints["run_as_non_root"],
            )
            check_type(
                argname="argument run_as_user",
                value=run_as_user,
                expected_type=type_hints["run_as_user"],
            )
            check_type(
                argname="argument seccomp_profile",
                value=seccomp_profile,
                expected_type=type_hints["seccomp_profile"],
            )
            check_type(
                argname="argument se_linux_options",
                value=se_linux_options,
                expected_type=type_hints["se_linux_options"],
            )
            check_type(
                argname="argument supplemental_groups",
                value=supplemental_groups,
                expected_type=type_hints["supplemental_groups"],
            )
            check_type(
                argname="argument sysctl",
                value=sysctl,
                expected_type=type_hints["sysctl"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctl is not None:
            self._values["sysctl"] = sysctl

    @builtins.property
    def fs_group(self) -> typing.Optional[builtins.str]:
        """A special supplemental group that applies to all containers in a pod.

        Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_group DaemonSetV1#fs_group}
        """
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        """fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod.

        This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_group_change_policy DaemonSetV1#fs_group_change_policy}
        """
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[builtins.str]:
        """The GID to run the entrypoint of the container process.

        Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_group DaemonSetV1#run_as_group}
        """
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_non_root(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Indicates that the container must run as a non-root user.

        If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_non_root DaemonSetV1#run_as_non_root}
        """
        result = self._values.get("run_as_non_root")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def run_as_user(self) -> typing.Optional[builtins.str]:
        """The UID to run the entrypoint of the container process.

        Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#run_as_user DaemonSetV1#run_as_user}
        """
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile"]:
        """seccomp_profile block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#seccomp_profile DaemonSetV1#seccomp_profile}
        """
        result = self._values.get("seccomp_profile")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile"],
            result,
        )

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions"]:
        """se_linux_options block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#se_linux_options DaemonSetV1#se_linux_options}
        """
        result = self._values.get("se_linux_options")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions"],
            result,
        )

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        """A list of groups applied to the first process run in each container, in addition to the container's primary GID.

        If unspecified, no groups will be added to any container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#supplemental_groups DaemonSetV1#supplemental_groups}
        """
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctl(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecSecurityContextSysctl"],
        ]
    ]:
        """sysctl block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sysctl DaemonSetV1#sysctl}
        """
        result = self._values.get("sysctl")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecSecurityContextSysctl"],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecSecurityContextOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf12c96da5f241660c2f734bc28e891c2829d0a195874fd5fc1544692eb25dcc
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSeccompProfile")
    def put_seccomp_profile(
        self,
        *,
        localhost_profile: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        :param type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        value = DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile(
            localhost_profile=localhost_profile, type=type
        )

        return typing.cast(None, jsii.invoke(self, "putSeccompProfile", [value]))

    @jsii.member(jsii_name="putSeLinuxOptions")
    def put_se_linux_options(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param level: Level is SELinux level label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        :param role: Role is a SELinux role label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        :param type: Type is a SELinux type label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        :param user: User is a SELinux user label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        value = DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions(
            level=level, role=role, type=type, user=user
        )

        return typing.cast(None, jsii.invoke(self, "putSeLinuxOptions", [value]))

    @jsii.member(jsii_name="putSysctl")
    def put_sysctl(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecSecurityContextSysctl",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__33a646ebc2ec1177e7808bb7cc65d4ca71d489e9997176bdb1a71905ef4e752d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putSysctl", [value]))

    @jsii.member(jsii_name="resetFsGroup")
    def reset_fs_group(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsGroup", []))

    @jsii.member(jsii_name="resetFsGroupChangePolicy")
    def reset_fs_group_change_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsGroupChangePolicy", []))

    @jsii.member(jsii_name="resetRunAsGroup")
    def reset_run_as_group(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsGroup", []))

    @jsii.member(jsii_name="resetRunAsNonRoot")
    def reset_run_as_non_root(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsNonRoot", []))

    @jsii.member(jsii_name="resetRunAsUser")
    def reset_run_as_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunAsUser", []))

    @jsii.member(jsii_name="resetSeccompProfile")
    def reset_seccomp_profile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSeccompProfile", []))

    @jsii.member(jsii_name="resetSeLinuxOptions")
    def reset_se_linux_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSeLinuxOptions", []))

    @jsii.member(jsii_name="resetSupplementalGroups")
    def reset_supplemental_groups(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSupplementalGroups", []))

    @jsii.member(jsii_name="resetSysctl")
    def reset_sysctl(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSysctl", []))

    @builtins.property
    @jsii.member(jsii_name="seccompProfile")
    def seccomp_profile(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfileOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfileOutputReference",
            jsii.get(self, "seccompProfile"),
        )

    @builtins.property
    @jsii.member(jsii_name="seLinuxOptions")
    def se_linux_options(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptionsOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptionsOutputReference",
            jsii.get(self, "seLinuxOptions"),
        )

    @builtins.property
    @jsii.member(jsii_name="sysctl")
    def sysctl(self) -> "DaemonSetV1SpecTemplateSpecSecurityContextSysctlList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecSecurityContextSysctlList",
            jsii.get(self, "sysctl"),
        )

    @builtins.property
    @jsii.member(jsii_name="fsGroupChangePolicyInput")
    def fs_group_change_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "fsGroupChangePolicyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fsGroupInput")
    def fs_group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "fsGroupInput")
        )

    @builtins.property
    @jsii.member(jsii_name="runAsGroupInput")
    def run_as_group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runAsGroupInput")
        )

    @builtins.property
    @jsii.member(jsii_name="runAsNonRootInput")
    def run_as_non_root_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "runAsNonRootInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="runAsUserInput")
    def run_as_user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runAsUserInput")
        )

    @builtins.property
    @jsii.member(jsii_name="seccompProfileInput")
    def seccomp_profile_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile"],
            jsii.get(self, "seccompProfileInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="seLinuxOptionsInput")
    def se_linux_options_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions"],
            jsii.get(self, "seLinuxOptionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="supplementalGroupsInput")
    def supplemental_groups_input(self) -> typing.Optional[typing.List[jsii.Number]]:
        return typing.cast(
            typing.Optional[typing.List[jsii.Number]],
            jsii.get(self, "supplementalGroupsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="sysctlInput")
    def sysctl_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecSecurityContextSysctl"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecSecurityContextSysctl"],
                ]
            ],
            jsii.get(self, "sysctlInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="fsGroup")
    def fs_group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsGroup"))

    @fs_group.setter
    def fs_group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__afde25ef097d339155a4aea0d6c02cab6d3b87f1711a168fbab4d2c901007c2a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsGroup", value)

    @builtins.property
    @jsii.member(jsii_name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsGroupChangePolicy"))

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dc85967d76e01360523f07ea128aafdab9e8e201f50b7231574a465195805dfc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsGroupChangePolicy", value)

    @builtins.property
    @jsii.member(jsii_name="runAsGroup")
    def run_as_group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runAsGroup"))

    @run_as_group.setter
    def run_as_group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d880bb32f72adf197b8e7f189f0df7893fa2c5d15ecd6a40fe63a518974895dd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsGroup", value)

    @builtins.property
    @jsii.member(jsii_name="runAsNonRoot")
    def run_as_non_root(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "runAsNonRoot"),
        )

    @run_as_non_root.setter
    def run_as_non_root(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__65cff982e3f9111a11fd02cc31e90fa8d04c670261261d56b991e0994a07c119
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsNonRoot", value)

    @builtins.property
    @jsii.member(jsii_name="runAsUser")
    def run_as_user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runAsUser"))

    @run_as_user.setter
    def run_as_user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c2b0e540bac2839221bd088ea263d6fc74167aaa9d5b7953c3dd2732016b17e1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runAsUser", value)

    @builtins.property
    @jsii.member(jsii_name="supplementalGroups")
    def supplemental_groups(self) -> typing.List[jsii.Number]:
        return typing.cast(
            typing.List[jsii.Number], jsii.get(self, "supplementalGroups")
        )

    @supplemental_groups.setter
    def supplemental_groups(self, value: typing.List[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e28f1454c0fd771c12d8301e5cf2b842bb5ca125fe4776ad43b68fb05a328115
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "supplementalGroups", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContext]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContext],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContext],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b84495a979b183f26e3212631b1f8d1f3578261466bfe35f1cc7f8cd1ec92ba8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param level: Level is SELinux level label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        :param role: Role is a SELinux role label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        :param type: Type is a SELinux type label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        :param user: User is a SELinux user label that applies to the container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__561996b725a1f5fe36340c70d2429aca9b4fb37ea9b3d1674853ffd168f504c5
            )
            check_type(
                argname="argument level", value=level, expected_type=type_hints["level"]
            )
            check_type(
                argname="argument role", value=role, expected_type=type_hints["role"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument user", value=user, expected_type=type_hints["user"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        """Level is SELinux level label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#level DaemonSetV1#level}
        """
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        """Role is a SELinux role label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#role DaemonSetV1#role}
        """
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type is a SELinux type label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        """User is a SELinux user label that applies to the container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__297ac5b668136abaa7f04f573694f3f3009c70726b979036a49f85ed9ecb3069
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLevel")
    def reset_level(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLevel", []))

    @jsii.member(jsii_name="resetRole")
    def reset_role(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRole", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="levelInput")
    def level_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "levelInput"))

    @builtins.property
    @jsii.member(jsii_name="roleInput")
    def role_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "roleInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="level")
    def level(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "level"))

    @level.setter
    def level(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__57e163bcdfe17f45913e3ed0b76cd5578f898e40b105fb49eb84773544ce5ea8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "level", value)

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "role"))

    @role.setter
    def role(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6be90aa7c8f76073a30c70edac0e02f8bbe6c0a5e8e8390f0cb262f2ef5f81c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "role", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4647b1fcbd237d2e78af0209fee9fc303bc6e1c7dc55d560838882b58808b5c6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a58bdff3cec61591d4638b2ccf7f5d2ae15a4930fb4823826e8aa8667fc5986
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "user", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af5d838405722dd2fe508359d721b23ae30bdd9ee2318997d3377f37d2343b2f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"localhost_profile": "localhostProfile", "type": "type"},
)
class DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        localhost_profile: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        :param type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af316715c4ee3b50ef5724cd92d6315e5dc4714af2a56028e83873b0b0d67e71
            )
            check_type(
                argname="argument localhost_profile",
                value=localhost_profile,
                expected_type=type_hints["localhost_profile"],
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        """Localhost Profile indicates a profile defined in a file on the node should be used.

        The profile must be preconfigured on the node to work.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#localhost_profile DaemonSetV1#localhost_profile}
        """
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfileOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfileOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__90c9ec9ea385c73bbf2490e98bcbf6c222177179e44f357ca445bd78202f722b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLocalhostProfile")
    def reset_localhost_profile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalhostProfile", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="localhostProfileInput")
    def localhost_profile_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "localhostProfileInput")
        )

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="localhostProfile")
    def localhost_profile(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "localhostProfile"))

    @localhost_profile.setter
    def localhost_profile(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac31f0ff8b8d8d07df3342a139aad55f114e1ac7e6e83320733031a23541843e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "localhostProfile", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56ace8af50e9e0efe632b9ca1e860cd882540fad8d864e17891aceb069b98ddf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__67fa70ce09dd3758325571198abbe85ce8041aad0e60760daf8425195ec6ac0e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextSysctl",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DaemonSetV1SpecTemplateSpecSecurityContextSysctl:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        """
        :param name: Name of a property to set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param value: Value of a property to set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__14b767d4813dd9fd4b2128f334f4aca098d31eebdead2533eb6142866fcded14
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        """Name of a property to set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        """Value of a property to set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecSecurityContextSysctl(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecSecurityContextSysctlList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextSysctlList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2290988818a82ec4b97ef79ad7b26e19a1ac7a7adcfdc9a739f6f956ad2e612
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecSecurityContextSysctlOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b7063931ec3944ccf92c372c7106f879877769baf36dd0e276bfc6dfc6387401
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecSecurityContextSysctlOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5707a2971ab1106334e5f0c099238ba54900e2f1bbb4a8de1177fb7260b8188c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ad1e777bbf4ceca5e444d8e8e9159af436c37587f4e8417b0fb9d818a7077dcf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b0a969ca1c8a2299e397d75594670ea4687c21604dfaa4448a5421516865017d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecSecurityContextSysctl],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecSecurityContextSysctl],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecSecurityContextSysctl],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bbab246f8ea62d991e7b56e17c03ffa589bceaf4f689656c58c484a69bb88206
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecSecurityContextSysctlOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecSecurityContextSysctlOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dc725c6a06024b23ab78ba23eb1fc1c8af7ad606bb80745fb96021f009fab69a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__63042bf015e7dda16e3333e67a8bdff2f58c251f71eb955b57c35c2f083c1d6e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__27680014dcf85e4a3f8421a569d941c662042593bf0aa8ba94ce7aade4f6adf0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecSecurityContextSysctl,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecSecurityContextSysctl,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecSecurityContextSysctl,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a7806c2fcdc24e18e49947c58c2657176856b98003421332c1d1c8ab0dd78630
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecToleration",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class DaemonSetV1SpecTemplateSpecToleration:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#effect DaemonSetV1#effect}
        :param key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#toleration_seconds DaemonSetV1#toleration_seconds}
        :param value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7e46e5f6af8727a33a738e2746658878c99f2f34383dcdf693d23271b1f0972d
            )
            check_type(
                argname="argument effect",
                value=effect,
                expected_type=type_hints["effect"],
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument toleration_seconds",
                value=toleration_seconds,
                expected_type=type_hints["toleration_seconds"],
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        """Effect indicates the taint effect to match.

        Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#effect DaemonSetV1#effect}
        """
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """Key is the taint key that the toleration applies to.

        Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """Operator represents a key's relationship to the value.

        Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[builtins.str]:
        """TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.

        By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#toleration_seconds DaemonSetV1#toleration_seconds}
        """
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """Value is the taint value the toleration matches to.

        If the operator is Exists, the value should be empty, otherwise just a regular string.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#value DaemonSetV1#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecToleration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecTolerationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTolerationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__18ff4b425b05766b4dff654c84442572668969de2448c171331b9b816d1ae131
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecTolerationOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6431c2ca2ca6316082dd2c44d43357d27eda36b9cdf3ae92ba64ff5fb0bacf53
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecTolerationOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f9e239f706520bfbc112d83472271318c2c564a7445fa84069079028362f3408
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e9d3976a0f27d54f383929b410d734efaee7cddb20a34529c3397b569df2d1b9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9f7c433c334a489aba0cc1a0dcbcc5aa4ba2f773e0c93780273d9b1ee3729e24
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecToleration],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecToleration],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecToleration],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__52e8a154eafc8721f655620d5f855faca799846b07349a092a8ff62cc3e83aa0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecTolerationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTolerationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e792c73e4ac56c5e32e31806e6112aaac86393ee5f6a65046de2824fcaba19d4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetEffect")
    def reset_effect(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEffect", []))

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetTolerationSeconds")
    def reset_toleration_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTolerationSeconds", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="effectInput")
    def effect_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "effectInput"))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tolerationSecondsInput")
    def toleration_seconds_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "tolerationSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="effect")
    def effect(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "effect"))

    @effect.setter
    def effect(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__87e571c407e04a65fc8f85d798cae2b8320f779ac163d6fd5270db8f8cd29360
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "effect", value)

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bf9fdb37997ce60b58b98c81a82d9ed9493357389ec09e93bdf5357dfef00327
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f28e69474d581cc9dd6955a90ebedb7587ae2605c2a265900cbbdcf82299bdbf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="tolerationSeconds")
    def toleration_seconds(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tolerationSeconds"))

    @toleration_seconds.setter
    def toleration_seconds(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6c8ddd5882ef3b36ce5831210269c7033382eeef75b9b83add22facf260f7cba
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "tolerationSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3cf22d4d102ef224d15fee2e188b184eef64da76fcfc4e4144f51fb5960c75f3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecToleration]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecToleration
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecToleration
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56093b63161922cce76b4b9dac22870e7a8381b107a17edbe0269ce0f2dda94f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraint",
    jsii_struct_bases=[],
    name_mapping={
        "label_selector": "labelSelector",
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
    },
)
class DaemonSetV1SpecTemplateSpecTopologySpreadConstraint:
    def __init__(
        self,
        *,
        label_selector: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        max_skew: typing.Optional[jsii.Number] = None,
        topology_key: typing.Optional[builtins.str] = None,
        when_unsatisfiable: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param label_selector: label_selector block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        :param max_skew: describes the degree to which pods may be unevenly distributed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#max_skew DaemonSetV1#max_skew}
        :param topology_key: the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        :param when_unsatisfiable: indicates how to deal with a pod if it doesn't satisfy the spread constraint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#when_unsatisfiable DaemonSetV1#when_unsatisfiable}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9946af7fdd14a637758c38973a9b0e91bb8bc14975dc12458cd6b9a5afc939c7
            )
            check_type(
                argname="argument label_selector",
                value=label_selector,
                expected_type=type_hints["label_selector"],
            )
            check_type(
                argname="argument max_skew",
                value=max_skew,
                expected_type=type_hints["max_skew"],
            )
            check_type(
                argname="argument topology_key",
                value=topology_key,
                expected_type=type_hints["topology_key"],
            )
            check_type(
                argname="argument when_unsatisfiable",
                value=when_unsatisfiable,
                expected_type=type_hints["when_unsatisfiable"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if max_skew is not None:
            self._values["max_skew"] = max_skew
        if topology_key is not None:
            self._values["topology_key"] = topology_key
        if when_unsatisfiable is not None:
            self._values["when_unsatisfiable"] = when_unsatisfiable

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector"
            ],
        ]
    ]:
        """label_selector block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#label_selector DaemonSetV1#label_selector}
        """
        result = self._values.get("label_selector")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def max_skew(self) -> typing.Optional[jsii.Number]:
        """describes the degree to which pods may be unevenly distributed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#max_skew DaemonSetV1#max_skew}
        """
        result = self._values.get("max_skew")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def topology_key(self) -> typing.Optional[builtins.str]:
        """the key of node labels.

        Nodes that have a label with this key and identical values are considered to be in the same topology.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#topology_key DaemonSetV1#topology_key}
        """
        result = self._values.get("topology_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def when_unsatisfiable(self) -> typing.Optional[builtins.str]:
        """indicates how to deal with a pod if it doesn't satisfy the spread constraint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#when_unsatisfiable DaemonSetV1#when_unsatisfiable}
        """
        result = self._values.get("when_unsatisfiable")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecTopologySpreadConstraint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        match_labels: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param match_expressions: match_expressions block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        :param match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d907a0924fee39c1dc56a5de289ec8810de198dd9918913081b84edaf93b42ea
            )
            check_type(
                argname="argument match_expressions",
                value=match_expressions,
                expected_type=type_hints["match_expressions"],
            )
            check_type(
                argname="argument match_labels",
                value=match_labels,
                expected_type=type_hints["match_labels"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions"
            ],
        ]
    ]:
        """match_expressions block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_expressions DaemonSetV1#match_expressions}
        """
        result = self._values.get("match_expressions")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """A map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of ``match_expressions``, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#match_labels DaemonSetV1#match_labels}
        """
        result = self._values.get("match_labels")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__939f4070a7ef9b041b64d1ecdc72c82efe112d0dfec27a9b025d310172a2db8e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8321f5a0a198b8bfe2a633911352309721ee7b7bde297f585e1e60188027833f
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__93cd3c27f3cce9ca60f7f81ee0c81af7f06a57d9768b82f5bc644c8b35729ee3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15809b8931e241e11dfbc8f1f59904407f8e6b4fdc2e4e8dae90880f3274193d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__935f962a3504f623a741ebb8b7f7fffd279f821d1c4bfdd73ef73d61b0a0078f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__398aa9668bb9591012de705be31093ec5c238d802a72be2047bf298df1673662
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        """
        :param key: The label key that the selector applies to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param operator: A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        :param values: An array of string values. If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__be21bd956af383029f07d65ba7bc291b8fc30d7c0a05afb610fb7c8e10dc0985
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument values",
                value=values,
                expected_type=type_hints["values"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The label key that the selector applies to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        """A key's relationship to a set of values. Valid operators ard ``In``, ``NotIn``, ``Exists`` and ``DoesNotExist``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#operator DaemonSetV1#operator}
        """
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        """An array of string values.

        If the operator is ``In`` or ``NotIn``, the values array must be non-empty. If the operator is ``Exists`` or ``DoesNotExist``, the values array must be empty. This array is replaced during a strategic merge patch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#values DaemonSetV1#values}
        """
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3b3c019f0af3d277e894f41293a5a3fce7ff7fc4eb8a828c7639a07bf475bd26
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a7585890e3ffd54e6500a7783fd4226082f5d68ee6772aaa7f743b78e0972ab6
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b59bcea9bad56c173679841191b382edc57372baeeae1229a35984cc0ffb37fd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c912c7c4a187f9ffefc7ea83b7e9aa093699095bffccd9c9ce11135f134215ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8f8d26cc1601a8de4451689f2acc11cd12a3918f082465a5f9efac416054a8f5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fd9aa0a9cd9d0a4540f2c3be85bc6e27b2179011aab19bdcc5ac9821ab5c7406
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e3d5a58826b0ffcd0e3223617d136e3de3df6be243779a8580b46117891b7a9f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetOperator")
    def reset_operator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOperator", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput")
        )

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ab9a7b0a3b59a0a21e5a5e58de20da255f12fe1e953111bd726c566833deabc8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ffc6a4e08be57bdab480017f5df3a8a66eebf146871ae955624ed0df3d9e24bd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ed23aaa456d1a329ec5db56b5d536efcd8d3ba234eac952374574c625dcb1cc2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "values", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8203862bc5a7f1697fbd7e930da0ddeadd825dcd3cb123c74d66d49ede1f49aa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5d97d944dc57fa43374e91bda5224280713579ca646804f719acb1a35ac36a8a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putMatchExpressions")
    def put_match_expressions(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5085ab2792921a9f05ef0b6721a60b99ccb90ba7e5b13058327a909dea62bb6e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putMatchExpressions", [value]))

    @jsii.member(jsii_name="resetMatchExpressions")
    def reset_match_expressions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchExpressions", []))

    @jsii.member(jsii_name="resetMatchLabels")
    def reset_match_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatchLabels", []))

    @builtins.property
    @jsii.member(jsii_name="matchExpressions")
    def match_expressions(
        self,
    ) -> DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsList,
            jsii.get(self, "matchExpressions"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchExpressionsInput")
    def match_expressions_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
                    ],
                ]
            ],
            jsii.get(self, "matchExpressionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabelsInput")
    def match_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "matchLabelsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="matchLabels")
    def match_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "matchLabels")
        )

    @match_labels.setter
    def match_labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__266117cab75c443e016ac5be1fe96d8d8be35cff695399abb7194722885d7996
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "matchLabels", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e334163b3d411a3f11e0d8bb22a6299a66416eb77491534343b54cf13b0cfccd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2e2700ad81a4c167144fbf607c85c85f3ae8412636cf858ac2a45362eff8b70d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1955f697541f541bfc7c2e8c29d97b3b54d469a32cac0ff17faabb8319200698
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d20a329a46b959e5d32619b72bb0b1f644ba7a26a89934a1bb19dea172dc2157
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__190ecda199b744d1c001ce08973545f48488918ab1bbe447ef927d23e6318310
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e7e8dc03fc7833373be8d2106fcc0add90060d3488d7ec2ffd3e032461a37158
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecTopologySpreadConstraint],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecTopologySpreadConstraint],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecTopologySpreadConstraint],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5b4b292e83f9807441810878d44dfad191e73f16d27729d907d1d2fed356dbfe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecTopologySpreadConstraintOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecTopologySpreadConstraintOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fbdf2a2624ee24cd61b0d497145044f7c2fc445ec95b641505ca29f7119daf42
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putLabelSelector")
    def put_label_selector(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__65cacb67d1b01a257d24bedd425bd6f5ebe2d9820f02d2781039bfa0b2bffb70
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLabelSelector", [value]))

    @jsii.member(jsii_name="resetLabelSelector")
    def reset_label_selector(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabelSelector", []))

    @jsii.member(jsii_name="resetMaxSkew")
    def reset_max_skew(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxSkew", []))

    @jsii.member(jsii_name="resetTopologyKey")
    def reset_topology_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTopologyKey", []))

    @jsii.member(jsii_name="resetWhenUnsatisfiable")
    def reset_when_unsatisfiable(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWhenUnsatisfiable", []))

    @builtins.property
    @jsii.member(jsii_name="labelSelector")
    def label_selector(
        self,
    ) -> DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorList,
            jsii.get(self, "labelSelector"),
        )

    @builtins.property
    @jsii.member(jsii_name="labelSelectorInput")
    def label_selector_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector
                    ],
                ]
            ],
            jsii.get(self, "labelSelectorInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="maxSkewInput")
    def max_skew_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxSkewInput"))

    @builtins.property
    @jsii.member(jsii_name="topologyKeyInput")
    def topology_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "topologyKeyInput")
        )

    @builtins.property
    @jsii.member(jsii_name="whenUnsatisfiableInput")
    def when_unsatisfiable_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "whenUnsatisfiableInput")
        )

    @builtins.property
    @jsii.member(jsii_name="maxSkew")
    def max_skew(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxSkew"))

    @max_skew.setter
    def max_skew(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af82e8fbecca1451eb43984901bcc34a1c159873b385a8e96820c03b7612c136
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "maxSkew", value)

    @builtins.property
    @jsii.member(jsii_name="topologyKey")
    def topology_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "topologyKey"))

    @topology_key.setter
    def topology_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c5ffb607fbf48ac8d23415029f0816e8171558ec502bc497886efcc97fe57760
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "topologyKey", value)

    @builtins.property
    @jsii.member(jsii_name="whenUnsatisfiable")
    def when_unsatisfiable(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "whenUnsatisfiable"))

    @when_unsatisfiable.setter
    def when_unsatisfiable(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac761509fb767535b1f1ec272aab4e2a674d1e851245dd26440ec3b62e4634bd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "whenUnsatisfiable", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraint,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraint,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraint,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f432815bd3c6c3a15385f3cc9a220a42ad05681298276583302edb5912e293c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolume",
    jsii_struct_bases=[],
    name_mapping={
        "aws_elastic_block_store": "awsElasticBlockStore",
        "azure_disk": "azureDisk",
        "azure_file": "azureFile",
        "ceph_fs": "cephFs",
        "cinder": "cinder",
        "config_map": "configMap",
        "csi": "csi",
        "downward_api": "downwardApi",
        "empty_dir": "emptyDir",
        "fc": "fc",
        "flex_volume": "flexVolume",
        "flocker": "flocker",
        "gce_persistent_disk": "gcePersistentDisk",
        "git_repo": "gitRepo",
        "glusterfs": "glusterfs",
        "host_path": "hostPath",
        "iscsi": "iscsi",
        "local": "local",
        "name": "name",
        "nfs": "nfs",
        "persistent_volume_claim": "persistentVolumeClaim",
        "photon_persistent_disk": "photonPersistentDisk",
        "projected": "projected",
        "quobyte": "quobyte",
        "rbd": "rbd",
        "secret": "secret",
        "vsphere_volume": "vsphereVolume",
    },
)
class DaemonSetV1SpecTemplateSpecVolume:
    def __init__(
        self,
        *,
        aws_elastic_block_store: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        azure_disk: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeAzureDisk",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        azure_file: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeAzureFile",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        ceph_fs: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeCephFs",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        cinder: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeCinder",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        config_map: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeConfigMap",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        csi: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeCsi",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        downward_api: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeDownwardApi",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        empty_dir: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeEmptyDir",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        fc: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeFc",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        flex_volume: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeFlexVolume",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        flocker: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeFlocker",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        gce_persistent_disk: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        git_repo: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeGitRepo",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        glusterfs: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeGlusterfs",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        host_path: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeHostPath",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        iscsi: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeIscsi",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        local: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeLocal",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        name: typing.Optional[builtins.str] = None,
        nfs: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeNfs",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        persistent_volume_claim: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        photon_persistent_disk: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        projected: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeProjected",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        quobyte: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeQuobyte",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        rbd: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeRbd",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        secret: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeSecret",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        vsphere_volume: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeVsphereVolume",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param aws_elastic_block_store: aws_elastic_block_store block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#aws_elastic_block_store DaemonSetV1#aws_elastic_block_store}
        :param azure_disk: azure_disk block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#azure_disk DaemonSetV1#azure_disk}
        :param azure_file: azure_file block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#azure_file DaemonSetV1#azure_file}
        :param ceph_fs: ceph_fs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#ceph_fs DaemonSetV1#ceph_fs}
        :param cinder: cinder block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#cinder DaemonSetV1#cinder}
        :param config_map: config_map block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map DaemonSetV1#config_map}
        :param csi: csi block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#csi DaemonSetV1#csi}
        :param downward_api: downward_api block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#downward_api DaemonSetV1#downward_api}
        :param empty_dir: empty_dir block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#empty_dir DaemonSetV1#empty_dir}
        :param fc: fc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fc DaemonSetV1#fc}
        :param flex_volume: flex_volume block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#flex_volume DaemonSetV1#flex_volume}
        :param flocker: flocker block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#flocker DaemonSetV1#flocker}
        :param gce_persistent_disk: gce_persistent_disk block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#gce_persistent_disk DaemonSetV1#gce_persistent_disk}
        :param git_repo: git_repo block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#git_repo DaemonSetV1#git_repo}
        :param glusterfs: glusterfs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#glusterfs DaemonSetV1#glusterfs}
        :param host_path: host_path block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_path DaemonSetV1#host_path}
        :param iscsi: iscsi block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iscsi DaemonSetV1#iscsi}
        :param local: local block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#local DaemonSetV1#local}
        :param name: Volume's name. Must be a DNS_LABEL and unique within the pod. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param nfs: nfs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#nfs DaemonSetV1#nfs}
        :param persistent_volume_claim: persistent_volume_claim block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#persistent_volume_claim DaemonSetV1#persistent_volume_claim}
        :param photon_persistent_disk: photon_persistent_disk block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#photon_persistent_disk DaemonSetV1#photon_persistent_disk}
        :param projected: projected block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#projected DaemonSetV1#projected}
        :param quobyte: quobyte block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#quobyte DaemonSetV1#quobyte}
        :param rbd: rbd block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd DaemonSetV1#rbd}
        :param secret: secret block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret DaemonSetV1#secret}
        :param vsphere_volume: vsphere_volume block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#vsphere_volume DaemonSetV1#vsphere_volume}
        """
        if isinstance(aws_elastic_block_store, dict):
            aws_elastic_block_store = (
                DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore(
                    **aws_elastic_block_store
                )
            )
        if isinstance(azure_disk, dict):
            azure_disk = DaemonSetV1SpecTemplateSpecVolumeAzureDisk(**azure_disk)
        if isinstance(azure_file, dict):
            azure_file = DaemonSetV1SpecTemplateSpecVolumeAzureFile(**azure_file)
        if isinstance(ceph_fs, dict):
            ceph_fs = DaemonSetV1SpecTemplateSpecVolumeCephFs(**ceph_fs)
        if isinstance(cinder, dict):
            cinder = DaemonSetV1SpecTemplateSpecVolumeCinder(**cinder)
        if isinstance(config_map, dict):
            config_map = DaemonSetV1SpecTemplateSpecVolumeConfigMap(**config_map)
        if isinstance(csi, dict):
            csi = DaemonSetV1SpecTemplateSpecVolumeCsi(**csi)
        if isinstance(downward_api, dict):
            downward_api = DaemonSetV1SpecTemplateSpecVolumeDownwardApi(**downward_api)
        if isinstance(empty_dir, dict):
            empty_dir = DaemonSetV1SpecTemplateSpecVolumeEmptyDir(**empty_dir)
        if isinstance(fc, dict):
            fc = DaemonSetV1SpecTemplateSpecVolumeFc(**fc)
        if isinstance(flex_volume, dict):
            flex_volume = DaemonSetV1SpecTemplateSpecVolumeFlexVolume(**flex_volume)
        if isinstance(flocker, dict):
            flocker = DaemonSetV1SpecTemplateSpecVolumeFlocker(**flocker)
        if isinstance(gce_persistent_disk, dict):
            gce_persistent_disk = DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk(
                **gce_persistent_disk
            )
        if isinstance(git_repo, dict):
            git_repo = DaemonSetV1SpecTemplateSpecVolumeGitRepo(**git_repo)
        if isinstance(glusterfs, dict):
            glusterfs = DaemonSetV1SpecTemplateSpecVolumeGlusterfs(**glusterfs)
        if isinstance(host_path, dict):
            host_path = DaemonSetV1SpecTemplateSpecVolumeHostPath(**host_path)
        if isinstance(iscsi, dict):
            iscsi = DaemonSetV1SpecTemplateSpecVolumeIscsi(**iscsi)
        if isinstance(local, dict):
            local = DaemonSetV1SpecTemplateSpecVolumeLocal(**local)
        if isinstance(nfs, dict):
            nfs = DaemonSetV1SpecTemplateSpecVolumeNfs(**nfs)
        if isinstance(persistent_volume_claim, dict):
            persistent_volume_claim = (
                DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim(
                    **persistent_volume_claim
                )
            )
        if isinstance(photon_persistent_disk, dict):
            photon_persistent_disk = (
                DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk(
                    **photon_persistent_disk
                )
            )
        if isinstance(quobyte, dict):
            quobyte = DaemonSetV1SpecTemplateSpecVolumeQuobyte(**quobyte)
        if isinstance(rbd, dict):
            rbd = DaemonSetV1SpecTemplateSpecVolumeRbd(**rbd)
        if isinstance(secret, dict):
            secret = DaemonSetV1SpecTemplateSpecVolumeSecret(**secret)
        if isinstance(vsphere_volume, dict):
            vsphere_volume = DaemonSetV1SpecTemplateSpecVolumeVsphereVolume(
                **vsphere_volume
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6ddaea26d1f41d1995c97e0cab5a6c2c04a9833a0cf50fc1130352f65593a607
            )
            check_type(
                argname="argument aws_elastic_block_store",
                value=aws_elastic_block_store,
                expected_type=type_hints["aws_elastic_block_store"],
            )
            check_type(
                argname="argument azure_disk",
                value=azure_disk,
                expected_type=type_hints["azure_disk"],
            )
            check_type(
                argname="argument azure_file",
                value=azure_file,
                expected_type=type_hints["azure_file"],
            )
            check_type(
                argname="argument ceph_fs",
                value=ceph_fs,
                expected_type=type_hints["ceph_fs"],
            )
            check_type(
                argname="argument cinder",
                value=cinder,
                expected_type=type_hints["cinder"],
            )
            check_type(
                argname="argument config_map",
                value=config_map,
                expected_type=type_hints["config_map"],
            )
            check_type(
                argname="argument csi", value=csi, expected_type=type_hints["csi"]
            )
            check_type(
                argname="argument downward_api",
                value=downward_api,
                expected_type=type_hints["downward_api"],
            )
            check_type(
                argname="argument empty_dir",
                value=empty_dir,
                expected_type=type_hints["empty_dir"],
            )
            check_type(argname="argument fc", value=fc, expected_type=type_hints["fc"])
            check_type(
                argname="argument flex_volume",
                value=flex_volume,
                expected_type=type_hints["flex_volume"],
            )
            check_type(
                argname="argument flocker",
                value=flocker,
                expected_type=type_hints["flocker"],
            )
            check_type(
                argname="argument gce_persistent_disk",
                value=gce_persistent_disk,
                expected_type=type_hints["gce_persistent_disk"],
            )
            check_type(
                argname="argument git_repo",
                value=git_repo,
                expected_type=type_hints["git_repo"],
            )
            check_type(
                argname="argument glusterfs",
                value=glusterfs,
                expected_type=type_hints["glusterfs"],
            )
            check_type(
                argname="argument host_path",
                value=host_path,
                expected_type=type_hints["host_path"],
            )
            check_type(
                argname="argument iscsi", value=iscsi, expected_type=type_hints["iscsi"]
            )
            check_type(
                argname="argument local", value=local, expected_type=type_hints["local"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument nfs", value=nfs, expected_type=type_hints["nfs"]
            )
            check_type(
                argname="argument persistent_volume_claim",
                value=persistent_volume_claim,
                expected_type=type_hints["persistent_volume_claim"],
            )
            check_type(
                argname="argument photon_persistent_disk",
                value=photon_persistent_disk,
                expected_type=type_hints["photon_persistent_disk"],
            )
            check_type(
                argname="argument projected",
                value=projected,
                expected_type=type_hints["projected"],
            )
            check_type(
                argname="argument quobyte",
                value=quobyte,
                expected_type=type_hints["quobyte"],
            )
            check_type(
                argname="argument rbd", value=rbd, expected_type=type_hints["rbd"]
            )
            check_type(
                argname="argument secret",
                value=secret,
                expected_type=type_hints["secret"],
            )
            check_type(
                argname="argument vsphere_volume",
                value=vsphere_volume,
                expected_type=type_hints["vsphere_volume"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if aws_elastic_block_store is not None:
            self._values["aws_elastic_block_store"] = aws_elastic_block_store
        if azure_disk is not None:
            self._values["azure_disk"] = azure_disk
        if azure_file is not None:
            self._values["azure_file"] = azure_file
        if ceph_fs is not None:
            self._values["ceph_fs"] = ceph_fs
        if cinder is not None:
            self._values["cinder"] = cinder
        if config_map is not None:
            self._values["config_map"] = config_map
        if csi is not None:
            self._values["csi"] = csi
        if downward_api is not None:
            self._values["downward_api"] = downward_api
        if empty_dir is not None:
            self._values["empty_dir"] = empty_dir
        if fc is not None:
            self._values["fc"] = fc
        if flex_volume is not None:
            self._values["flex_volume"] = flex_volume
        if flocker is not None:
            self._values["flocker"] = flocker
        if gce_persistent_disk is not None:
            self._values["gce_persistent_disk"] = gce_persistent_disk
        if git_repo is not None:
            self._values["git_repo"] = git_repo
        if glusterfs is not None:
            self._values["glusterfs"] = glusterfs
        if host_path is not None:
            self._values["host_path"] = host_path
        if iscsi is not None:
            self._values["iscsi"] = iscsi
        if local is not None:
            self._values["local"] = local
        if name is not None:
            self._values["name"] = name
        if nfs is not None:
            self._values["nfs"] = nfs
        if persistent_volume_claim is not None:
            self._values["persistent_volume_claim"] = persistent_volume_claim
        if photon_persistent_disk is not None:
            self._values["photon_persistent_disk"] = photon_persistent_disk
        if projected is not None:
            self._values["projected"] = projected
        if quobyte is not None:
            self._values["quobyte"] = quobyte
        if rbd is not None:
            self._values["rbd"] = rbd
        if secret is not None:
            self._values["secret"] = secret
        if vsphere_volume is not None:
            self._values["vsphere_volume"] = vsphere_volume

    @builtins.property
    def aws_elastic_block_store(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore"]:
        """aws_elastic_block_store block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#aws_elastic_block_store DaemonSetV1#aws_elastic_block_store}
        """
        result = self._values.get("aws_elastic_block_store")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore"],
            result,
        )

    @builtins.property
    def azure_disk(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeAzureDisk"]:
        """azure_disk block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#azure_disk DaemonSetV1#azure_disk}
        """
        result = self._values.get("azure_disk")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeAzureDisk"], result
        )

    @builtins.property
    def azure_file(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeAzureFile"]:
        """azure_file block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#azure_file DaemonSetV1#azure_file}
        """
        result = self._values.get("azure_file")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeAzureFile"], result
        )

    @builtins.property
    def ceph_fs(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCephFs"]:
        """ceph_fs block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#ceph_fs DaemonSetV1#ceph_fs}
        """
        result = self._values.get("ceph_fs")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCephFs"], result
        )

    @builtins.property
    def cinder(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCinder"]:
        """cinder block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#cinder DaemonSetV1#cinder}
        """
        result = self._values.get("cinder")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCinder"], result
        )

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeConfigMap"]:
        """config_map block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map DaemonSetV1#config_map}
        """
        result = self._values.get("config_map")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeConfigMap"], result
        )

    @builtins.property
    def csi(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCsi"]:
        """csi block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#csi DaemonSetV1#csi}
        """
        result = self._values.get("csi")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCsi"], result
        )

    @builtins.property
    def downward_api(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeDownwardApi"]:
        """downward_api block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#downward_api DaemonSetV1#downward_api}
        """
        result = self._values.get("downward_api")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeDownwardApi"], result
        )

    @builtins.property
    def empty_dir(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeEmptyDir"]:
        """empty_dir block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#empty_dir DaemonSetV1#empty_dir}
        """
        result = self._values.get("empty_dir")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeEmptyDir"], result
        )

    @builtins.property
    def fc(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFc"]:
        """fc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fc DaemonSetV1#fc}
        """
        result = self._values.get("fc")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFc"], result
        )

    @builtins.property
    def flex_volume(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlexVolume"]:
        """flex_volume block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#flex_volume DaemonSetV1#flex_volume}
        """
        result = self._values.get("flex_volume")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlexVolume"], result
        )

    @builtins.property
    def flocker(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlocker"]:
        """flocker block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#flocker DaemonSetV1#flocker}
        """
        result = self._values.get("flocker")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlocker"], result
        )

    @builtins.property
    def gce_persistent_disk(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk"]:
        """gce_persistent_disk block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#gce_persistent_disk DaemonSetV1#gce_persistent_disk}
        """
        result = self._values.get("gce_persistent_disk")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk"],
            result,
        )

    @builtins.property
    def git_repo(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeGitRepo"]:
        """git_repo block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#git_repo DaemonSetV1#git_repo}
        """
        result = self._values.get("git_repo")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeGitRepo"], result
        )

    @builtins.property
    def glusterfs(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeGlusterfs"]:
        """glusterfs block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#glusterfs DaemonSetV1#glusterfs}
        """
        result = self._values.get("glusterfs")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeGlusterfs"], result
        )

    @builtins.property
    def host_path(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeHostPath"]:
        """host_path block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#host_path DaemonSetV1#host_path}
        """
        result = self._values.get("host_path")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeHostPath"], result
        )

    @builtins.property
    def iscsi(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeIscsi"]:
        """iscsi block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iscsi DaemonSetV1#iscsi}
        """
        result = self._values.get("iscsi")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeIscsi"], result
        )

    @builtins.property
    def local(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeLocal"]:
        """local block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#local DaemonSetV1#local}
        """
        result = self._values.get("local")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeLocal"], result
        )

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Volume's name. Must be a DNS_LABEL and unique within the pod. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nfs(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeNfs"]:
        """nfs block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#nfs DaemonSetV1#nfs}
        """
        result = self._values.get("nfs")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeNfs"], result
        )

    @builtins.property
    def persistent_volume_claim(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim"]:
        """persistent_volume_claim block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#persistent_volume_claim DaemonSetV1#persistent_volume_claim}
        """
        result = self._values.get("persistent_volume_claim")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim"],
            result,
        )

    @builtins.property
    def photon_persistent_disk(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk"]:
        """photon_persistent_disk block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#photon_persistent_disk DaemonSetV1#photon_persistent_disk}
        """
        result = self._values.get("photon_persistent_disk")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk"],
            result,
        )

    @builtins.property
    def projected(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeProjected"],
        ]
    ]:
        """projected block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#projected DaemonSetV1#projected}
        """
        result = self._values.get("projected")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolumeProjected"],
                ]
            ],
            result,
        )

    @builtins.property
    def quobyte(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeQuobyte"]:
        """quobyte block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#quobyte DaemonSetV1#quobyte}
        """
        result = self._values.get("quobyte")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeQuobyte"], result
        )

    @builtins.property
    def rbd(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbd"]:
        """rbd block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd DaemonSetV1#rbd}
        """
        result = self._values.get("rbd")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbd"], result
        )

    @builtins.property
    def secret(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeSecret"]:
        """secret block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret DaemonSetV1#secret}
        """
        result = self._values.get("secret")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeSecret"], result
        )

    @builtins.property
    def vsphere_volume(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeVsphereVolume"]:
        """vsphere_volume block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#vsphere_volume DaemonSetV1#vsphere_volume}
        """
        result = self._values.get("vsphere_volume")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeVsphereVolume"], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "partition": "partition",
        "read_only": "readOnly",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param volume_id: Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_id DaemonSetV1#volume_id}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#partition DaemonSetV1#partition}
        :param read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a3ae7730986d61f2c690fbeaa73e67e78d2b88797c2889630856872202b1af40
            )
            check_type(
                argname="argument volume_id",
                value=volume_id,
                expected_type=type_hints["volume_id"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument partition",
                value=partition,
                expected_type=type_hints["partition"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if partition is not None:
            self._values["partition"] = partition
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def volume_id(self) -> builtins.str:
        """Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_id DaemonSetV1#volume_id}
        """
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type of the volume that you want to mount.

        Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def partition(self) -> typing.Optional[jsii.Number]:
        """The partition in the volume that you want to mount.

        If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#partition DaemonSetV1#partition}
        """
        result = self._values.get("partition")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStoreOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStoreOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__071d6ca6c1b0070e1245cc719cfdaf77d6802980e82946017e31ee60c86ffa0e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetPartition")
    def reset_partition(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPartition", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="partitionInput")
    def partition_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "partitionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeIdInput")
    def volume_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "volumeIdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0b324083cca13c760916fc5b569cc850bff8ff8660225ca3490eca9846f8d76
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="partition")
    def partition(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "partition"))

    @partition.setter
    def partition(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__25b00713d6e65377b0c027feb6d5a98055a2468ea6f87cce9436a774869f3415
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "partition", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c19a8ecb58644da0dab49a321be5b63e85000fd86b082f93929ad9d971f9b49b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="volumeId")
    def volume_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "volumeId"))

    @volume_id.setter
    def volume_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e09e649620e4e2f64e021e8849d3a6d4f87382b13336b5a4c63fd17b7d709aaa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "volumeId", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7df1a46d4c5341d1bd02e07ec82baffb0164455beb9d78746b1bc41971dcc469
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeAzureDisk",
    jsii_struct_bases=[],
    name_mapping={
        "caching_mode": "cachingMode",
        "data_disk_uri": "dataDiskUri",
        "disk_name": "diskName",
        "fs_type": "fsType",
        "kind": "kind",
        "read_only": "readOnly",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeAzureDisk:
    def __init__(
        self,
        *,
        caching_mode: builtins.str,
        data_disk_uri: builtins.str,
        disk_name: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param caching_mode: Host Caching mode: None, Read Only, Read Write. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#caching_mode DaemonSetV1#caching_mode}
        :param data_disk_uri: The URI the data disk in the blob storage. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#data_disk_uri DaemonSetV1#data_disk_uri}
        :param disk_name: The Name of the data disk in the blob storage. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#disk_name DaemonSetV1#disk_name}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param kind: The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#kind DaemonSetV1#kind}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__736eacd0737422fc42ec527366f007ad693727e17d4e8de1ca2e25bd3ec4eaab
            )
            check_type(
                argname="argument caching_mode",
                value=caching_mode,
                expected_type=type_hints["caching_mode"],
            )
            check_type(
                argname="argument data_disk_uri",
                value=data_disk_uri,
                expected_type=type_hints["data_disk_uri"],
            )
            check_type(
                argname="argument disk_name",
                value=disk_name,
                expected_type=type_hints["disk_name"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument kind", value=kind, expected_type=type_hints["kind"]
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "caching_mode": caching_mode,
            "data_disk_uri": data_disk_uri,
            "disk_name": disk_name,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if kind is not None:
            self._values["kind"] = kind
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def caching_mode(self) -> builtins.str:
        """Host Caching mode: None, Read Only, Read Write.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#caching_mode DaemonSetV1#caching_mode}
        """
        result = self._values.get("caching_mode")
        assert result is not None, "Required property 'caching_mode' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def data_disk_uri(self) -> builtins.str:
        """The URI the data disk in the blob storage.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#data_disk_uri DaemonSetV1#data_disk_uri}
        """
        result = self._values.get("data_disk_uri")
        assert result is not None, "Required property 'data_disk_uri' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disk_name(self) -> builtins.str:
        """The Name of the data disk in the blob storage.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#disk_name DaemonSetV1#disk_name}
        """
        result = self._values.get("disk_name")
        assert result is not None, "Required property 'disk_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type to mount.

        Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        """The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#kind DaemonSetV1#kind}
        """
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeAzureDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeAzureDiskOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeAzureDiskOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e87efd917b36571360ac8a21d1f12ad91e5da422aea91e7ed6544e5435d637b1
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetKind")
    def reset_kind(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKind", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="cachingModeInput")
    def caching_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "cachingModeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dataDiskUriInput")
    def data_disk_uri_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "dataDiskUriInput")
        )

    @builtins.property
    @jsii.member(jsii_name="diskNameInput")
    def disk_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "diskNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="kindInput")
    def kind_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kindInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="cachingMode")
    def caching_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cachingMode"))

    @caching_mode.setter
    def caching_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8733a9e1de36d4d356e69304e584f1e0a9ab2eca1251480a14f3fbcc70b57bca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "cachingMode", value)

    @builtins.property
    @jsii.member(jsii_name="dataDiskUri")
    def data_disk_uri(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dataDiskUri"))

    @data_disk_uri.setter
    def data_disk_uri(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f1f96235187487fa0b2384b2f807de7302029e76a56c9bc8b5ce349ad3edbe1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dataDiskUri", value)

    @builtins.property
    @jsii.member(jsii_name="diskName")
    def disk_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskName"))

    @disk_name.setter
    def disk_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cdd05b497986c6e5cc0f667561269cdf2601392799c080f9cad889d3f2355765
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "diskName", value)

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__80dcf93c2b60494e3e62013bcd497bcd3aacb045de1f8391b7c0a46918518ad4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="kind")
    def kind(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "kind"))

    @kind.setter
    def kind(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f8c88db39ce191696a736e488b4065ff82871f04b6cfd20a53983098ab2ca80c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "kind", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b106b46fdf887da3d2418e154df91d6e6a603e0fac9a33a7fb75f428f37b4a33
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureDisk]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureDisk],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureDisk],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6bf6015326a986d0d9ecca089bcff3f7ab94bd6a7820d9190e9b9182060feb4e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeAzureFile",
    jsii_struct_bases=[],
    name_mapping={
        "secret_name": "secretName",
        "share_name": "shareName",
        "read_only": "readOnly",
        "secret_namespace": "secretNamespace",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeAzureFile:
    def __init__(
        self,
        *,
        secret_name: builtins.str,
        share_name: builtins.str,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param secret_name: The name of secret that contains Azure Storage Account Name and Key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_name DaemonSetV1#secret_name}
        :param share_name: Share Name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#share_name DaemonSetV1#share_name}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_namespace: The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_namespace DaemonSetV1#secret_namespace}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4bef08474b6118301118a33a10f7a7e1e8b79df6b19511e921f32f7cb09a0ac7
            )
            check_type(
                argname="argument secret_name",
                value=secret_name,
                expected_type=type_hints["secret_name"],
            )
            check_type(
                argname="argument share_name",
                value=share_name,
                expected_type=type_hints["share_name"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument secret_namespace",
                value=secret_namespace,
                expected_type=type_hints["secret_namespace"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_name": secret_name,
            "share_name": share_name,
        }
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_namespace is not None:
            self._values["secret_namespace"] = secret_namespace

    @builtins.property
    def secret_name(self) -> builtins.str:
        """The name of secret that contains Azure Storage Account Name and Key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_name DaemonSetV1#secret_name}
        """
        result = self._values.get("secret_name")
        assert result is not None, "Required property 'secret_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def share_name(self) -> builtins.str:
        """Share Name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#share_name DaemonSetV1#share_name}
        """
        result = self._values.get("share_name")
        assert result is not None, "Required property 'share_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def secret_namespace(self) -> typing.Optional[builtins.str]:
        """The namespace of the secret that contains Azure Storage Account Name and Key.

        For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_namespace DaemonSetV1#secret_namespace}
        """
        result = self._values.get("secret_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeAzureFile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeAzureFileOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeAzureFileOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8d047e68cece4211cc0dd130ed568d6f9e6608b6c599290aded872775e89f6f6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetSecretNamespace")
    def reset_secret_namespace(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretNamespace", []))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretNameInput")
    def secret_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "secretNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="secretNamespaceInput")
    def secret_namespace_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "secretNamespaceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="shareNameInput")
    def share_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "shareNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8e677d6ac1413967d6b69165378dd0d84c781bd45bd2e2fd4ca5753e44e0a5d9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="secretName")
    def secret_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretName"))

    @secret_name.setter
    def secret_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__725aeb4bfded1a44a5c0037a061c30d1a3eb487f98294557b448b059c193cfc1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "secretName", value)

    @builtins.property
    @jsii.member(jsii_name="secretNamespace")
    def secret_namespace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretNamespace"))

    @secret_namespace.setter
    def secret_namespace(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a769fb3294fba4c9ebf2f6e506b22aa0ce4a53d880615b474d0267b6604c1423
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "secretNamespace", value)

    @builtins.property
    @jsii.member(jsii_name="shareName")
    def share_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "shareName"))

    @share_name.setter
    def share_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d303b14d8d4578f6081c93c5eb3a45d773eea6d8baaf38c5d3d7bbe2d92cecf4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "shareName", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureFile]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureFile],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureFile],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c3d1cd993a489ad0863f8d412cb320196cd3d70e0989f8800b48d9bdab51705
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCephFs",
    jsii_struct_bases=[],
    name_mapping={
        "monitors": "monitors",
        "path": "path",
        "read_only": "readOnly",
        "secret_file": "secretFile",
        "secret_ref": "secretRef",
        "user": "user",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeCephFs:
    def __init__(
        self,
        *,
        monitors: typing.Sequence[builtins.str],
        path: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_file: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param monitors: Monitors is a collection of Ceph monitors More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#monitors DaemonSetV1#monitors}
        :param path: Used as the mounted root, rather than the full Ceph tree, default is /. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to ``false`` (read/write). More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_file: The path to key ring for User, default is /etc/ceph/user.secret More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_file DaemonSetV1#secret_file}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        :param user: User is the rados user name, default is admin. More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        if isinstance(secret_ref, dict):
            secret_ref = DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bc94c88f8a9e2bfc70abae4d09fe7d344e0542fb11133252f624ea467268d1d7
            )
            check_type(
                argname="argument monitors",
                value=monitors,
                expected_type=type_hints["monitors"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument secret_file",
                value=secret_file,
                expected_type=type_hints["secret_file"],
            )
            check_type(
                argname="argument secret_ref",
                value=secret_ref,
                expected_type=type_hints["secret_ref"],
            )
            check_type(
                argname="argument user", value=user, expected_type=type_hints["user"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "monitors": monitors,
        }
        if path is not None:
            self._values["path"] = path
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_file is not None:
            self._values["secret_file"] = secret_file
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def monitors(self) -> typing.List[builtins.str]:
        """Monitors is a collection of Ceph monitors More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#monitors DaemonSetV1#monitors}
        """
        result = self._values.get("monitors")
        assert result is not None, "Required property 'monitors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Used as the mounted root, rather than the full Ceph tree, default is /.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the read-only setting in VolumeMounts. Defaults to ``false`` (read/write). More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def secret_file(self) -> typing.Optional[builtins.str]:
        """The path to key ring for User, default is /etc/ceph/user.secret More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_file DaemonSetV1#secret_file}
        """
        result = self._values.get("secret_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef"]:
        """secret_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        result = self._values.get("secret_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef"], result
        )

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        """User is the rados user name, default is admin. More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeCephFs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeCephFsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCephFsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2f92aaa6fbb3cb858b7e28011f4de8d1f6f8ab69e550a36d3d05be1cfd6b88d4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSecretRef")
    def put_secret_ref(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef(
            name=name, namespace=namespace
        )

        return typing.cast(None, jsii.invoke(self, "putSecretRef", [value]))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetSecretFile")
    def reset_secret_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretFile", []))

    @jsii.member(jsii_name="resetSecretRef")
    def reset_secret_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretRef", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="secretRef")
    def secret_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRefOutputReference",
            jsii.get(self, "secretRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="monitorsInput")
    def monitors_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "monitorsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretFileInput")
    def secret_file_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "secretFileInput")
        )

    @builtins.property
    @jsii.member(jsii_name="secretRefInput")
    def secret_ref_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef"],
            jsii.get(self, "secretRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="monitors")
    def monitors(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "monitors"))

    @monitors.setter
    def monitors(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3613cb2b6a432ca7e05b85573e9f441ef59aa5bcb3d40b50f355dadf97881db5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "monitors", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d236c69511e7acdb54a4903e0e8b578bdd6b97a86e239171713220ea95d23149
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7f768e2e0b89e350fc660aa48c688eaeda4c0e45d62cb0650be8cf7757413f65
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="secretFile")
    def secret_file(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretFile"))

    @secret_file.setter
    def secret_file(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__baf244b7344f394a69afe41641c0b052a79a40adaf748d6344684c9062a982da
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "secretFile", value)

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4cf4c7c27d6e91bfe8df729276422f9ac739d5d731a43fd9858792f8229306c6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "user", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFs]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFs],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFs],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8305a90ec311791d6f8b58004a3e0e786e07cef8ea47b6088cf1763161f53d85
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "namespace": "namespace"},
)
class DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e33cc8acb67923c903c8e2f01460236ad10cbb796b960ab127c70bc6e459d5e7
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument namespace",
                value=namespace,
                expected_type=type_hints["namespace"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cfe1d3e234be8ead05c6d954f857d8196b3c7cf67edecfd2595200a9cd668a73
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetNamespace")
    def reset_namespace(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespace", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="namespaceInput")
    def namespace_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "namespaceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e3ca5db1e095131ac479dbdeb0fe8f4965d8744d3caf0599569890a2e11e4239
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @namespace.setter
    def namespace(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__12a68556c0d50a510be0b095d61f428f74522857e64bc65990d40940f4a7342a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespace", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e1827c57b73322a704d3fccdedcff85c3f7fcd645b59d8ac6edc77c5b3e9b024
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCinder",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "read_only": "readOnly",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeCinder:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param volume_id: Volume ID used to identify the volume in Cinder. More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_id DaemonSetV1#volume_id}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bc59bd2038ccc1cfcaa45a6e14291a5f16e39ac59de8bf3bb5604c14cfa8d484
            )
            check_type(
                argname="argument volume_id",
                value=volume_id,
                expected_type=type_hints["volume_id"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def volume_id(self) -> builtins.str:
        """Volume ID used to identify the volume in Cinder. More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_id DaemonSetV1#volume_id}
        """
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type to mount.

        Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeCinder(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeCinderOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCinderOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__522c117e22e513fab39164b6b0ca8c794f75a2eecc96ca2ef80e515af7e51c36
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeIdInput")
    def volume_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "volumeIdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e15ccf9944b826f745225e0b0370995ab90ed5c74a71cde483b58f456ee073a8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97d0f961ebf520fdfc48325666c6e1fcf44c4560226eb65d6efced15de003f7f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="volumeId")
    def volume_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "volumeId"))

    @volume_id.setter
    def volume_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7b3482be8d4857dc53526c1a99ce4819f8483e2e13e3264edd1c1f72316f36c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "volumeId", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCinder]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCinder],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCinder],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a3669b29bd35b2e019b42dec263fbf136a54de3311a45326a7c7aaf68f720797
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeConfigMap",
    jsii_struct_bases=[],
    name_mapping={
        "default_mode": "defaultMode",
        "items": "items",
        "name": "name",
        "optional": "optional",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeConfigMap:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[builtins.str] = None,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeConfigMapItems",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Optional: Specify whether the ConfigMap or its keys must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__98d2b0fda4d3c74fc2621afc5936443ea9f856b70a025c9072f201e03f89b84a
            )
            check_type(
                argname="argument default_mode",
                value=default_mode,
                expected_type=type_hints["default_mode"],
            )
            check_type(
                argname="argument items", value=items, expected_type=type_hints["items"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def default_mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on created files by default.

        Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        """
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeConfigMapItems"],
        ]
    ]:
        """items block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        result = self._values.get("items")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolumeConfigMapItems"],
                ]
            ],
            result,
        )

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Optional: Specify whether the ConfigMap or its keys must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "mode": "mode", "path": "path"},
)
class DaemonSetV1SpecTemplateSpecVolumeConfigMapItems:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The key to project. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        :param path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0c2cbb7e0a9781f6fe55cfe86fcd2e3e995086a8a38f0025c40b4584464967ea
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument mode", value=mode, expected_type=type_hints["mode"]
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if mode is not None:
            self._values["mode"] = mode
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key to project.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on this file, must be a value between 0 and 0777.

        If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        """
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """The relative path of the file to map the key to.

        May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ad192594e8cfbced6e024816d7fde60e3770b21fb0938772ea012d2d327186bc
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e58d48d887afe1802eefe1e5c687341bff36ea9e3083952e3ce65e9202637bc9
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__659913d755c34a69c3e63545b99c63fe5a10065023f9b17054d2da4632dc5efe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c25f026afa3db43246142f16baf3f605769a2463be7c188bf86a16b04cad47e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1898a7c7879c68ab47b46c3584ed2a2b82959306eb72a00590445361caa0e41b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeConfigMapItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeConfigMapItems],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolumeConfigMapItems],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6d8866c68be981d9af0a71fd119097820038a18f0e2f77c8a2d16f6298366180
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c9c3560d99653be12e2bd4e65a3ccafa01db8265f5710a0b36064caaa5f87349
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ab45df4948a1e41d716d4b8228043d48e1fd3ec268796108d4ce46a40af3c7b7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3206cb6036fc37b746a38e01e83c38fdbfcc1a3e9bfa97bed305177e9f230126
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mode", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0eeaabf89b0d99de56cab297c74e67799b55501ad624a7ec3621d9ce198dbe95
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolumeConfigMapItems
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeConfigMapItems,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeConfigMapItems,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b7469d6e148bae40426b30a0648bf2545158f1019aa455130518e9a86a9f0a96
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeConfigMapOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeConfigMapOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__755ceb42f0833dc8d9b33bafb54635c25017641f0e6991318b4d9c5b7b1e6d53
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putItems")
    def put_items(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeConfigMapItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3ef25a49280bbb361afdeef3516f575a83db64ea4259a7d21a41cef72e6a9517
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putItems", [value]))

    @jsii.member(jsii_name="resetDefaultMode")
    def reset_default_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultMode", []))

    @jsii.member(jsii_name="resetItems")
    def reset_items(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetItems", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="items")
    def items(self) -> DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsList, jsii.get(self, "items")
        )

    @builtins.property
    @jsii.member(jsii_name="defaultModeInput")
    def default_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "defaultModeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="itemsInput")
    def items_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeConfigMapItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeConfigMapItems],
                ]
            ],
            jsii.get(self, "itemsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="defaultMode")
    def default_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "defaultMode"))

    @default_mode.setter
    def default_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__add20d40d916d2c17f4620e42ee28deed72f3df7a3252ec7f8a94503d8fe667d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "defaultMode", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9ed6c07f19e3b09c7134f572d56011a16a705bf0e21a0047f00580528c0a945c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6b5a6c7c3c575d83a4da5a4363198decaaa14683851d4a031a8a996ada6bb267
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeConfigMap]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeConfigMap],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeConfigMap],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e926f955a3db96f35cb1e41f50234e6d7fe32501492e54baf0e83d26f01765ee
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCsi",
    jsii_struct_bases=[],
    name_mapping={
        "driver": "driver",
        "fs_type": "fsType",
        "node_publish_secret_ref": "nodePublishSecretRef",
        "read_only": "readOnly",
        "volume_attributes": "volumeAttributes",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeCsi:
    def __init__(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        node_publish_secret_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        volume_attributes: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param driver: the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#driver DaemonSetV1#driver}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param node_publish_secret_ref: node_publish_secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_publish_secret_ref DaemonSetV1#node_publish_secret_ref}
        :param read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: http://kubernetes.io/docs/user-guide/volumes#csi. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param volume_attributes: Attributes of the volume to publish. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_attributes DaemonSetV1#volume_attributes}
        """
        if isinstance(node_publish_secret_ref, dict):
            node_publish_secret_ref = (
                DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef(
                    **node_publish_secret_ref
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8853dca537727253d7604fab068dd7328d92271b458497395cf17744a4d238b1
            )
            check_type(
                argname="argument driver",
                value=driver,
                expected_type=type_hints["driver"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument node_publish_secret_ref",
                value=node_publish_secret_ref,
                expected_type=type_hints["node_publish_secret_ref"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument volume_attributes",
                value=volume_attributes,
                expected_type=type_hints["volume_attributes"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "driver": driver,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if node_publish_secret_ref is not None:
            self._values["node_publish_secret_ref"] = node_publish_secret_ref
        if read_only is not None:
            self._values["read_only"] = read_only
        if volume_attributes is not None:
            self._values["volume_attributes"] = volume_attributes

    @builtins.property
    def driver(self) -> builtins.str:
        """the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#driver DaemonSetV1#driver}
        """
        result = self._values.get("driver")
        assert result is not None, "Required property 'driver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type to mount.

        Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_publish_secret_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef"]:
        """node_publish_secret_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_publish_secret_ref DaemonSetV1#node_publish_secret_ref}
        """
        result = self._values.get("node_publish_secret_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef"],
            result,
        )

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: http://kubernetes.io/docs/user-guide/volumes#csi.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def volume_attributes(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Attributes of the volume to publish.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_attributes DaemonSetV1#volume_attributes}
        """
        result = self._values.get("volume_attributes")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeCsi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a17e87722bbb0e0daa605be303de7f519182d8836b441da82c9390a2dfb4aacb
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__eb75743473f1b36ebc6a701d3c27bc0a6a3551273c34cbe3fdb0092d3de12e01
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c142dde5be471a1e87347ebfc3857dd06b6b860388aaa42e713185fee4550cde
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__63d7ce4595a4d7300c97e139e932626df6e93c19a67cd50e90455a8350f5aa91
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeCsiOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeCsiOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__616f7e69e17d954f81120a2484c42662d0b28bd3a8895149c5b5553886811fb5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putNodePublishSecretRef")
    def put_node_publish_secret_ref(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef(name=name)

        return typing.cast(None, jsii.invoke(self, "putNodePublishSecretRef", [value]))

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetNodePublishSecretRef")
    def reset_node_publish_secret_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodePublishSecretRef", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetVolumeAttributes")
    def reset_volume_attributes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVolumeAttributes", []))

    @builtins.property
    @jsii.member(jsii_name="nodePublishSecretRef")
    def node_publish_secret_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRefOutputReference,
            jsii.get(self, "nodePublishSecretRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="driverInput")
    def driver_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "driverInput"))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="nodePublishSecretRefInput")
    def node_publish_secret_ref_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef],
            jsii.get(self, "nodePublishSecretRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="volumeAttributesInput")
    def volume_attributes_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "volumeAttributesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="driver")
    def driver(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "driver"))

    @driver.setter
    def driver(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5f320edd47397ffba43efdecdbb34c6cdfabca20d8e1daa42280a9f2bbd2d6f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "driver", value)

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__36345ca8310045545346fb02dc3483b9caa90db0620c874ae0fdf6aabd68a24d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__48b71f53ef90b5c25b8ec7d75adfe1a9bd5ce0cf9b75bf9acd25f59cbe14d106
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="volumeAttributes")
    def volume_attributes(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str],
            jsii.get(self, "volumeAttributes"),
        )

    @volume_attributes.setter
    def volume_attributes(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b1a113991cfc7070ae860ac8ee4adebd49b25347cf4f61eaa1920e285e3d0042
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "volumeAttributes", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsi]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsi],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsi],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e446d2b7846741be53d726476b105aa863bd2f9917cd9ab2d35f6cfba318a604
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApi",
    jsii_struct_bases=[],
    name_mapping={"default_mode": "defaultMode", "items": "items"},
)
class DaemonSetV1SpecTemplateSpecVolumeDownwardApi:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[builtins.str] = None,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b9249439624c50a7c2c12221fbb715adecbca1d4f121a69eeb584bf12f407a41
            )
            check_type(
                argname="argument default_mode",
                value=default_mode,
                expected_type=type_hints["default_mode"],
            )
            check_type(
                argname="argument items", value=items, expected_type=type_hints["items"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items

    @builtins.property
    def default_mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on created files by default.

        Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        """
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems"],
        ]
    ]:
        """items block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        result = self._values.get("items")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems"],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeDownwardApi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems",
    jsii_struct_bases=[],
    name_mapping={
        "field_ref": "fieldRef",
        "path": "path",
        "mode": "mode",
        "resource_field_ref": "resourceFieldRef",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems:
    def __init__(
        self,
        *,
        field_ref: typing.Union[
            "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef",
            typing.Dict[builtins.str, typing.Any],
        ],
        path: builtins.str,
        mode: typing.Optional[builtins.str] = None,
        resource_field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param field_ref: field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        :param path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..' Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        :param resource_field_ref: resource_field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        """
        if isinstance(field_ref, dict):
            field_ref = DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef(
                **field_ref
            )
        if isinstance(resource_field_ref, dict):
            resource_field_ref = (
                DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef(
                    **resource_field_ref
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d5e49aa25881c89be9091ac8f4e15b9995825e98d35a22340309276217cd7a21
            )
            check_type(
                argname="argument field_ref",
                value=field_ref,
                expected_type=type_hints["field_ref"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument mode", value=mode, expected_type=type_hints["mode"]
            )
            check_type(
                argname="argument resource_field_ref",
                value=resource_field_ref,
                expected_type=type_hints["resource_field_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "field_ref": field_ref,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref

    @builtins.property
    def field_ref(self) -> "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef":
        """field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        """
        result = self._values.get("field_ref")
        assert result is not None, "Required property 'field_ref' is missing"
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef", result
        )

    @builtins.property
    def path(self) -> builtins.str:
        """Path is the relative path name of the file to be created.

        Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on this file, must be a value between 0 and 0777.

        If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        """
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef"
    ]:
        """resource_field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        """
        result = self._values.get("resource_field_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef",
    jsii_struct_bases=[],
    name_mapping={"api_version": "apiVersion", "field_path": "fieldPath"},
)
class DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a78bed222e39691c60d5b36bc901c5180cbd42b1167b794e1abf38331ed62fdb
            )
            check_type(
                argname="argument api_version",
                value=api_version,
                expected_type=type_hints["api_version"],
            )
            check_type(
                argname="argument field_path",
                value=field_path,
                expected_type=type_hints["field_path"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if field_path is not None:
            self._values["field_path"] = field_path

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        """Version of the schema the FieldPath is written in terms of, defaults to "v1".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        """
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def field_path(self) -> typing.Optional[builtins.str]:
        """Path of the field to select in the specified API version.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        result = self._values.get("field_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d3cf4fd34356abd2c3eee98f89cc1fbc18b4cd92168467e448dd89e5e0c80079
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetApiVersion")
    def reset_api_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiVersion", []))

    @jsii.member(jsii_name="resetFieldPath")
    def reset_field_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFieldPath", []))

    @builtins.property
    @jsii.member(jsii_name="apiVersionInput")
    def api_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "apiVersionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fieldPathInput")
    def field_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "fieldPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiVersion")
    def api_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiVersion"))

    @api_version.setter
    def api_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__df118ff9b1ea08e936255277759e785db5e88aa259ea8d2d1e08de45e3291802
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiVersion", value)

    @builtins.property
    @jsii.member(jsii_name="fieldPath")
    def field_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fieldPath"))

    @field_path.setter
    def field_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__32a2fd7d5b27e9a3f25e67ec2eb04f7b49721afd4caeb33f6d9c65c8c4a74556
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fieldPath", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f640c6c0e2bbfa467e5e3c85a6148cd49be7a5e08dad13c2b8b596c878de4d3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__812128e875ef81324b015e051585721d5ce153accc906b1712666efea69508b0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8e1258b82e0c772ff1986cb5ebffecc9323c5fdb7d5d4d12b5de7d4328b75e70
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b1d736e5805850f412b7901155d19edb2f2e64c76e314d2bbd1d339a5f805185
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aa2b90ccaed1768986c4ba95bd067fde9ea29915c45a8e0a6e9ef3d2ead67de2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1133e69a4d5b5effbaf0c2b50fec8fabaed7a2eb38ae145d29e68164e0aec1a0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2d5781a4e6b82bbf8849f99d681f7af1f514e3469d56fec8edf139156f9dfdff
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9d89905e8d53f242a9137cefe11d8ea29cf14aa385b4edaf8cb97c216bc1e0d0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putFieldRef")
    def put_field_ref(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef(
            api_version=api_version, field_path=field_path
        )

        return typing.cast(None, jsii.invoke(self, "putFieldRef", [value]))

    @jsii.member(jsii_name="putResourceFieldRef")
    def put_resource_field_ref(
        self,
        *,
        container_name: builtins.str,
        resource: builtins.str,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        value = DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef(
            container_name=container_name, resource=resource, divisor=divisor
        )

        return typing.cast(None, jsii.invoke(self, "putResourceFieldRef", [value]))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetResourceFieldRef")
    def reset_resource_field_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceFieldRef", []))

    @builtins.property
    @jsii.member(jsii_name="fieldRef")
    def field_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRefOutputReference,
            jsii.get(self, "fieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRef")
    def resource_field_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRefOutputReference",
            jsii.get(self, "resourceFieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="fieldRefInput")
    def field_ref_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef],
            jsii.get(self, "fieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRefInput")
    def resource_field_ref_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef"
            ],
            jsii.get(self, "resourceFieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__46fd7e5333d6200acd5691b5b5fad43d8367fd6d5796292a4893c4d1ff2291df
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mode", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dfd59b7ed2439f8f57b15d92f544a592ed056b81ee1f9a97ce4699d1f2d0d12b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1b77caf4d44bd6c50c32e1e973dbdf9e0d47eea228534432306436318398f28b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "container_name": "containerName",
        "resource": "resource",
        "divisor": "divisor",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef:
    def __init__(
        self,
        *,
        container_name: builtins.str,
        resource: builtins.str,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__79e6a59e9aba0734a0154c06e0b9d2c89859daf752da8bf46eb78de88bd20016
            )
            check_type(
                argname="argument container_name",
                value=container_name,
                expected_type=type_hints["container_name"],
            )
            check_type(
                argname="argument resource",
                value=resource,
                expected_type=type_hints["resource"],
            )
            check_type(
                argname="argument divisor",
                value=divisor,
                expected_type=type_hints["divisor"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_name": container_name,
            "resource": resource,
        }
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def container_name(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}."""
        result = self._values.get("container_name")
        assert result is not None, "Required property 'container_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource(self) -> builtins.str:
        """Resource to select.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        """
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def divisor(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}."""
        result = self._values.get("divisor")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0ea759a21e220b72248d538c2681b70acb2d7043ad494c06816aec22b8325ce0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDivisor")
    def reset_divisor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDivisor", []))

    @builtins.property
    @jsii.member(jsii_name="containerNameInput")
    def container_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "containerNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="divisorInput")
    def divisor_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "divisorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="resourceInput")
    def resource_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "resourceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="containerName")
    def container_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerName"))

    @container_name.setter
    def container_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4d259df4bbe8904b1b3e56e5b088c760b31588264429835ae8aebfc0aec27726
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "containerName", value)

    @builtins.property
    @jsii.member(jsii_name="divisor")
    def divisor(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "divisor"))

    @divisor.setter
    def divisor(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ea46a7c6e2947db8f46b118bcf11e7d78d2feb86c47e034b8af97ea745cbd351
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "divisor", value)

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resource"))

    @resource.setter
    def resource(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b72a479262be215eadb9800741adcbcc2993be5dd31961e33f6d7f9970560d40
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "resource", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c9b4fc5c275fa5f99454ee55c61195ddfd8736a1ec517306fa70cc93b7af9ec4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeDownwardApiOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeDownwardApiOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__adf813a67a57882482ed77a45005f493bb20716223a00838d8287f77691fa507
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putItems")
    def put_items(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__390b32e8b4083ec92d5d7d07820ad841431d88ce2790f5a6c16c9db01ccd4cf1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putItems", [value]))

    @jsii.member(jsii_name="resetDefaultMode")
    def reset_default_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultMode", []))

    @jsii.member(jsii_name="resetItems")
    def reset_items(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetItems", []))

    @builtins.property
    @jsii.member(jsii_name="items")
    def items(self) -> DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsList,
            jsii.get(self, "items"),
        )

    @builtins.property
    @jsii.member(jsii_name="defaultModeInput")
    def default_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "defaultModeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="itemsInput")
    def items_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems],
                ]
            ],
            jsii.get(self, "itemsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="defaultMode")
    def default_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "defaultMode"))

    @default_mode.setter
    def default_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b76f07d24d1b530b621eea3a4ffa9f6accdcc271025112d0949a89f5f30fdcbf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "defaultMode", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApi]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApi],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApi],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__94ec7251a1f2867386443b7ef480078bc684441d138850171c30fdc0dc18fc42
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeEmptyDir",
    jsii_struct_bases=[],
    name_mapping={"medium": "medium", "size_limit": "sizeLimit"},
)
class DaemonSetV1SpecTemplateSpecVolumeEmptyDir:
    def __init__(
        self,
        *,
        medium: typing.Optional[builtins.str] = None,
        size_limit: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param medium: What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#medium DaemonSetV1#medium}
        :param size_limit: Total amount of local storage required for this EmptyDir volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#size_limit DaemonSetV1#size_limit}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d2f0a4c17e0f2e93533beb223ea460dbd106b425f2a8e9a11174ec5a846a9238
            )
            check_type(
                argname="argument medium",
                value=medium,
                expected_type=type_hints["medium"],
            )
            check_type(
                argname="argument size_limit",
                value=size_limit,
                expected_type=type_hints["size_limit"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if medium is not None:
            self._values["medium"] = medium
        if size_limit is not None:
            self._values["size_limit"] = size_limit

    @builtins.property
    def medium(self) -> typing.Optional[builtins.str]:
        """What type of storage medium should back this directory.

        The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#medium DaemonSetV1#medium}
        """
        result = self._values.get("medium")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def size_limit(self) -> typing.Optional[builtins.str]:
        """Total amount of local storage required for this EmptyDir volume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#size_limit DaemonSetV1#size_limit}
        """
        result = self._values.get("size_limit")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeEmptyDir(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeEmptyDirOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeEmptyDirOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__32b696cc695c2453bc5a0931398b7e77589fabe5d052308059e5617a87df234b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetMedium")
    def reset_medium(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMedium", []))

    @jsii.member(jsii_name="resetSizeLimit")
    def reset_size_limit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSizeLimit", []))

    @builtins.property
    @jsii.member(jsii_name="mediumInput")
    def medium_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "mediumInput"))

    @builtins.property
    @jsii.member(jsii_name="sizeLimitInput")
    def size_limit_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "sizeLimitInput")
        )

    @builtins.property
    @jsii.member(jsii_name="medium")
    def medium(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "medium"))

    @medium.setter
    def medium(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ff113b336c85b2eb1f72bd7cffb78b459fc6e28be785f5d85c05037c6957454
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "medium", value)

    @builtins.property
    @jsii.member(jsii_name="sizeLimit")
    def size_limit(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sizeLimit"))

    @size_limit.setter
    def size_limit(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c2cd09bbbd018fd505366278097a7b3cdf3428f159fdbf8c5e794208fc5847c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "sizeLimit", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeEmptyDir]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeEmptyDir],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeEmptyDir],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5cadf97fd9e493ef6f88bbf846f13acdb73e7f2eec461a2c54d62c7763d56eec
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFc",
    jsii_struct_bases=[],
    name_mapping={
        "lun": "lun",
        "target_ww_ns": "targetWwNs",
        "fs_type": "fsType",
        "read_only": "readOnly",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeFc:
    def __init__(
        self,
        *,
        lun: jsii.Number,
        target_ww_ns: typing.Sequence[builtins.str],
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param lun: FC target lun number. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lun DaemonSetV1#lun}
        :param target_ww_ns: FC target worldwide names (WWNs). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#target_ww_ns DaemonSetV1#target_ww_ns}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba3bcf3929965d4a6ccb07475298157f5e54ca15fd4b8e2d41597c84cbc89bc1
            )
            check_type(
                argname="argument lun", value=lun, expected_type=type_hints["lun"]
            )
            check_type(
                argname="argument target_ww_ns",
                value=target_ww_ns,
                expected_type=type_hints["target_ww_ns"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "lun": lun,
            "target_ww_ns": target_ww_ns,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def lun(self) -> jsii.Number:
        """FC target lun number.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lun DaemonSetV1#lun}
        """
        result = self._values.get("lun")
        assert result is not None, "Required property 'lun' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def target_ww_ns(self) -> typing.List[builtins.str]:
        """FC target worldwide names (WWNs).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#target_ww_ns DaemonSetV1#target_ww_ns}
        """
        result = self._values.get("target_ww_ns")
        assert result is not None, "Required property 'target_ww_ns' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type to mount.

        Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeFc(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeFcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c1181254ac5985653bb325dcb9b3d5942aa55648473457c9b224015e0ff1a48
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="lunInput")
    def lun_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "lunInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="targetWwNsInput")
    def target_ww_ns_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "targetWwNsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__df02dc067c67544442acd4c7bd167d45b27295a7461d2a44d36ad0688e11f52e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="lun")
    def lun(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "lun"))

    @lun.setter
    def lun(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__855a146010f81c28bf01b67f973cb6fce69fb0efdb757b997a7f5ad1e47b7be0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "lun", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e131698e780f7aaa5635e128221b0c4b68d981965ba78a9f1b834c5b24160524
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="targetWwNs")
    def target_ww_ns(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "targetWwNs"))

    @target_ww_ns.setter
    def target_ww_ns(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__38eee4045e1dbf05ef34cd11a82eec81b27d80e05659fa681234d1556098ac40
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "targetWwNs", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFc]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFc],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFc],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ec3c458118c771ca39c46f96ce0cdd4b630a965eb5a12a12365b2fe37bdfc2e5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFlexVolume",
    jsii_struct_bases=[],
    name_mapping={
        "driver": "driver",
        "fs_type": "fsType",
        "options": "options",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeFlexVolume:
    def __init__(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        options: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param driver: Driver is the name of the driver to use for this volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#driver DaemonSetV1#driver}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param options: Extra command options if any. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#options DaemonSetV1#options}
        :param read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        if isinstance(secret_ref, dict):
            secret_ref = DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef(
                **secret_ref
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bab7905fa3a007110a64188c1f9e85ced87bc8c4779421903e36b04534047f9f
            )
            check_type(
                argname="argument driver",
                value=driver,
                expected_type=type_hints["driver"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument options",
                value=options,
                expected_type=type_hints["options"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument secret_ref",
                value=secret_ref,
                expected_type=type_hints["secret_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "driver": driver,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if options is not None:
            self._values["options"] = options
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def driver(self) -> builtins.str:
        """Driver is the name of the driver to use for this volume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#driver DaemonSetV1#driver}
        """
        result = self._values.get("driver")
        assert result is not None, "Required property 'driver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type to mount.

        Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def options(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        """Extra command options if any.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#options DaemonSetV1#options}
        """
        result = self._values.get("options")
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]], result
        )

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef"]:
        """secret_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        result = self._values.get("secret_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef"],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeFlexVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeFlexVolumeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFlexVolumeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__df5a6f2ffacaa392903461a9aa404cd95921abf7e18d2b4cbdb7d25218f8dc8a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSecretRef")
    def put_secret_ref(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef(
            name=name, namespace=namespace
        )

        return typing.cast(None, jsii.invoke(self, "putSecretRef", [value]))

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetOptions")
    def reset_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptions", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetSecretRef")
    def reset_secret_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretRef", []))

    @builtins.property
    @jsii.member(jsii_name="secretRef")
    def secret_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRefOutputReference",
            jsii.get(self, "secretRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="driverInput")
    def driver_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "driverInput"))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="optionsInput")
    def options_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(
            typing.Optional[typing.Mapping[builtins.str, builtins.str]],
            jsii.get(self, "optionsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretRefInput")
    def secret_ref_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef"],
            jsii.get(self, "secretRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="driver")
    def driver(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "driver"))

    @driver.setter
    def driver(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__da948760d05705e941bde1a0f75abb027bb5578f8de612debcaa8b8a1d2510cb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "driver", value)

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cfbe88338d8afe262bc1bf5df1d9110c58ada100266a1af9bf6884ea1ce62770
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="options")
    def options(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(
            typing.Mapping[builtins.str, builtins.str], jsii.get(self, "options")
        )

    @options.setter
    def options(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7667478e343151c79a8eec31def92e675a6c59c0b834c76e80bd815e07d52aea
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "options", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d4da89dc8b9e0da1c1b5087956bacde452eb0978228f5bb76932d7009bcd5d25
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolume]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolume],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolume],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__058542390a3624e33db8be4c1a7034c1433bd814364edd3640e44c6f406bb165
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "namespace": "namespace"},
)
class DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aa805b8bf0ad4fa80068de6f0bc89c6587788aa623ef77b2b94a2e52a6282db1
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument namespace",
                value=namespace,
                expected_type=type_hints["namespace"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__52eda7f1f8c4df90e0057a6dc5fa1fab362c33a68642393f9c424469775d2220
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetNamespace")
    def reset_namespace(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespace", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="namespaceInput")
    def namespace_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "namespaceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__208eb2016a8838082bf59ed7274192cdff4d133f7c39f053860bbe0631dd236d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @namespace.setter
    def namespace(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b1a08ec1a5b3e58e1a23ff0571f62af5135a63c54ca43b8191753088ab99b409
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespace", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b0287504d4e020ce76c28f93d37fe7827b95317a3cd0fe6647631af75754865f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFlocker",
    jsii_struct_bases=[],
    name_mapping={"dataset_name": "datasetName", "dataset_uuid": "datasetUuid"},
)
class DaemonSetV1SpecTemplateSpecVolumeFlocker:
    def __init__(
        self,
        *,
        dataset_name: typing.Optional[builtins.str] = None,
        dataset_uuid: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param dataset_name: Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dataset_name DaemonSetV1#dataset_name}
        :param dataset_uuid: UUID of the dataset. This is unique identifier of a Flocker dataset. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dataset_uuid DaemonSetV1#dataset_uuid}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7f9a38d84ca44752646a47d5ceb06d3def6a1f5f9b3b0d823853a93e24dc096
            )
            check_type(
                argname="argument dataset_name",
                value=dataset_name,
                expected_type=type_hints["dataset_name"],
            )
            check_type(
                argname="argument dataset_uuid",
                value=dataset_uuid,
                expected_type=type_hints["dataset_uuid"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dataset_name is not None:
            self._values["dataset_name"] = dataset_name
        if dataset_uuid is not None:
            self._values["dataset_uuid"] = dataset_uuid

    @builtins.property
    def dataset_name(self) -> typing.Optional[builtins.str]:
        """Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dataset_name DaemonSetV1#dataset_name}
        """
        result = self._values.get("dataset_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dataset_uuid(self) -> typing.Optional[builtins.str]:
        """UUID of the dataset. This is unique identifier of a Flocker dataset.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dataset_uuid DaemonSetV1#dataset_uuid}
        """
        result = self._values.get("dataset_uuid")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeFlocker(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeFlockerOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeFlockerOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dd15e58670335882d4dd33b16825186d06458ba5beadb107e6cc1d5d031fd25b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDatasetName")
    def reset_dataset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatasetName", []))

    @jsii.member(jsii_name="resetDatasetUuid")
    def reset_dataset_uuid(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatasetUuid", []))

    @builtins.property
    @jsii.member(jsii_name="datasetNameInput")
    def dataset_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "datasetNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="datasetUuidInput")
    def dataset_uuid_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "datasetUuidInput")
        )

    @builtins.property
    @jsii.member(jsii_name="datasetName")
    def dataset_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "datasetName"))

    @dataset_name.setter
    def dataset_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b9d2cd6ec396043493d1373ef34a713555f8257585ba6de49b985e4b4c9905cf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "datasetName", value)

    @builtins.property
    @jsii.member(jsii_name="datasetUuid")
    def dataset_uuid(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "datasetUuid"))

    @dataset_uuid.setter
    def dataset_uuid(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1fbb85ccd8b137a0de2afc99c24d78eaf5accd83d95a3ac5479d4dbf8fbeacb9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "datasetUuid", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlocker]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlocker],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlocker],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5284833b83c54c3333ec05aea5df5f97df8e9d2f81879cb22f6d05eb63485c7b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk",
    jsii_struct_bases=[],
    name_mapping={
        "pd_name": "pdName",
        "fs_type": "fsType",
        "partition": "partition",
        "read_only": "readOnly",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk:
    def __init__(
        self,
        *,
        pd_name: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param pd_name: Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pd_name DaemonSetV1#pd_name}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#partition DaemonSetV1#partition}
        :param read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c5ee2265b263485c889e1f665220f05f7786ea92b515c5625b893a00cf60f02
            )
            check_type(
                argname="argument pd_name",
                value=pd_name,
                expected_type=type_hints["pd_name"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument partition",
                value=partition,
                expected_type=type_hints["partition"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pd_name": pd_name,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if partition is not None:
            self._values["partition"] = partition
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def pd_name(self) -> builtins.str:
        """Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pd_name DaemonSetV1#pd_name}
        """
        result = self._values.get("pd_name")
        assert result is not None, "Required property 'pd_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type of the volume that you want to mount.

        Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def partition(self) -> typing.Optional[jsii.Number]:
        """The partition in the volume that you want to mount.

        If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#partition DaemonSetV1#partition}
        """
        result = self._values.get("partition")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeGcePersistentDiskOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeGcePersistentDiskOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a327fc3c8acf469b8c08ed3a4bd7d6c63f2dabefccc7658f76e8b34c39726238
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetPartition")
    def reset_partition(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPartition", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="partitionInput")
    def partition_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "partitionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="pdNameInput")
    def pd_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pdNameInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6ba3007404fc8408c6f657353d4ccb9d4bfa3fabdbff510c568c1eac56432fc8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="partition")
    def partition(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "partition"))

    @partition.setter
    def partition(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cafa833a6a4559d9dfd0cf64926a0c4b2234ce9a4099b00c3accd18754cd4155
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "partition", value)

    @builtins.property
    @jsii.member(jsii_name="pdName")
    def pd_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pdName"))

    @pd_name.setter
    def pd_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b1c0810d130a9eecc2fefb14494fe8bc3c2ff4b2a6ae6fd8da5b9321144bce5a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "pdName", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__13df52d01a9fe0fa6748d4fe80c5773763222cc6c5236b50b7ad39c8090b7afc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__87f6e952431668a95a6f7eef818040a550d39a142649fd2d31407c51c2d40539
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeGitRepo",
    jsii_struct_bases=[],
    name_mapping={
        "directory": "directory",
        "repository": "repository",
        "revision": "revision",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeGitRepo:
    def __init__(
        self,
        *,
        directory: typing.Optional[builtins.str] = None,
        repository: typing.Optional[builtins.str] = None,
        revision: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param directory: Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#directory DaemonSetV1#directory}
        :param repository: Repository URL. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#repository DaemonSetV1#repository}
        :param revision: Commit hash for the specified revision. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#revision DaemonSetV1#revision}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8960dd1ced032c4e49b5b50860439fe71a227720afb605e43c3837b91fe25333
            )
            check_type(
                argname="argument directory",
                value=directory,
                expected_type=type_hints["directory"],
            )
            check_type(
                argname="argument repository",
                value=repository,
                expected_type=type_hints["repository"],
            )
            check_type(
                argname="argument revision",
                value=revision,
                expected_type=type_hints["revision"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if directory is not None:
            self._values["directory"] = directory
        if repository is not None:
            self._values["repository"] = repository
        if revision is not None:
            self._values["revision"] = revision

    @builtins.property
    def directory(self) -> typing.Optional[builtins.str]:
        """Target directory name.

        Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#directory DaemonSetV1#directory}
        """
        result = self._values.get("directory")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repository(self) -> typing.Optional[builtins.str]:
        """Repository URL.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#repository DaemonSetV1#repository}
        """
        result = self._values.get("repository")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def revision(self) -> typing.Optional[builtins.str]:
        """Commit hash for the specified revision.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#revision DaemonSetV1#revision}
        """
        result = self._values.get("revision")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeGitRepo(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeGitRepoOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeGitRepoOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4eb6b094478b22a1aa0cdb5b7abd88be7b27e462c350e8265b67bf1b1409416a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDirectory")
    def reset_directory(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDirectory", []))

    @jsii.member(jsii_name="resetRepository")
    def reset_repository(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepository", []))

    @jsii.member(jsii_name="resetRevision")
    def reset_revision(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRevision", []))

    @builtins.property
    @jsii.member(jsii_name="directoryInput")
    def directory_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "directoryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="repositoryInput")
    def repository_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repositoryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="revisionInput")
    def revision_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "revisionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="directory")
    def directory(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "directory"))

    @directory.setter
    def directory(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a32d733ab7c4d17277498d518f0f14f79218c7f4128eb261ebfbd35e10f5fdc4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "directory", value)

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repository"))

    @repository.setter
    def repository(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__341b487b605cf34fef9b2730e9b930bc79e30dbf4ae525af5d942c0009670983
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repository", value)

    @builtins.property
    @jsii.member(jsii_name="revision")
    def revision(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "revision"))

    @revision.setter
    def revision(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__861207f0f76522230df51a4a2945887384ac0cb7fcd1af28dc683db60ad6743f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "revision", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGitRepo]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGitRepo],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGitRepo],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f1a15272d1b67d4d72194bb3d8f50beaa6d0e752e3580726cab8cc055c027806
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeGlusterfs",
    jsii_struct_bases=[],
    name_mapping={
        "endpoints_name": "endpointsName",
        "path": "path",
        "read_only": "readOnly",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeGlusterfs:
    def __init__(
        self,
        *,
        endpoints_name: builtins.str,
        path: builtins.str,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param endpoints_name: The endpoint name that details Glusterfs topology. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#endpoints_name DaemonSetV1#endpoints_name}
        :param path: The Glusterfs volume path. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param read_only: Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e0e2e805bd8f35fd9f9002a91cd3f20361188630f54638c6613dd1ece5076466
            )
            check_type(
                argname="argument endpoints_name",
                value=endpoints_name,
                expected_type=type_hints["endpoints_name"],
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoints_name": endpoints_name,
            "path": path,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def endpoints_name(self) -> builtins.str:
        """The endpoint name that details Glusterfs topology. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#endpoints_name DaemonSetV1#endpoints_name}
        """
        result = self._values.get("endpoints_name")
        assert result is not None, "Required property 'endpoints_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        """The Glusterfs volume path. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeGlusterfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeGlusterfsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeGlusterfsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c473454ceff1b6bc6ac6d5d009bfeffddbcf2e2bc6a2b6cdc007c526a5110f8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="endpointsNameInput")
    def endpoints_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointsNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="endpointsName")
    def endpoints_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpointsName"))

    @endpoints_name.setter
    def endpoints_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1735044eeae33f19210bd3160cb6590772493c01a1feb800b4702de607f94ce9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpointsName", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e389c44e4a51811ae2723206d5a0edfd4dc1110192c21e6ebb2e845402f81add
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c5aa2ee32c545ab05e13afe7bb42cc1b0086c248d81d42371c9f4c82294b233f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGlusterfs]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGlusterfs],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGlusterfs],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d1e9d8cab45ec7f64ecda8134844cc93078f1e712e0411b9482d1b1d850be568
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeHostPath",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "type": "type"},
)
class DaemonSetV1SpecTemplateSpecVolumeHostPath:
    def __init__(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param path: Path of the directory on the host. More info: http://kubernetes.io/docs/user-guide/volumes#hostpath. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param type: Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bb67312a65a9fdb3487efccd9e473768ed8a2829834b0819e1f41c91c18715cb
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path of the directory on the host. More info: http://kubernetes.io/docs/user-guide/volumes#hostpath.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeHostPath(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeHostPathOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeHostPathOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bca35177d6bf9cfd3548b83b043a431545dcc9828b7b45ad46860859158ed06e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c85d4d18fc960fcecdec492ab773e07016d67b106e66214c7466bdd5bdd3c655
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__604638a20d43493c5ba5bf8c227fdd4c52cf0a50cd1c8cd760202798e53696e4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeHostPath]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeHostPath],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeHostPath],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6858a16a2a6b6338ffda6629a7acc7a61593ea0993b6b34f78aab47b1fc46b07
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeIscsi",
    jsii_struct_bases=[],
    name_mapping={
        "iqn": "iqn",
        "target_portal": "targetPortal",
        "fs_type": "fsType",
        "iscsi_interface": "iscsiInterface",
        "lun": "lun",
        "read_only": "readOnly",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeIscsi:
    def __init__(
        self,
        *,
        iqn: builtins.str,
        target_portal: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        iscsi_interface: typing.Optional[builtins.str] = None,
        lun: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param iqn: Target iSCSI Qualified Name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iqn DaemonSetV1#iqn}
        :param target_portal: iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#target_portal DaemonSetV1#target_portal}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#iscsi Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param iscsi_interface: iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iscsi_interface DaemonSetV1#iscsi_interface}
        :param lun: iSCSI target lun number. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lun DaemonSetV1#lun}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d177f89bdcaf95ee00adcf80ce4272fba6049a3fff1eb29d8756cdb658b77f62
            )
            check_type(
                argname="argument iqn", value=iqn, expected_type=type_hints["iqn"]
            )
            check_type(
                argname="argument target_portal",
                value=target_portal,
                expected_type=type_hints["target_portal"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument iscsi_interface",
                value=iscsi_interface,
                expected_type=type_hints["iscsi_interface"],
            )
            check_type(
                argname="argument lun", value=lun, expected_type=type_hints["lun"]
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "iqn": iqn,
            "target_portal": target_portal,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if iscsi_interface is not None:
            self._values["iscsi_interface"] = iscsi_interface
        if lun is not None:
            self._values["lun"] = lun
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def iqn(self) -> builtins.str:
        """Target iSCSI Qualified Name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iqn DaemonSetV1#iqn}
        """
        result = self._values.get("iqn")
        assert result is not None, "Required property 'iqn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_portal(self) -> builtins.str:
        """iSCSI target portal.

        The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#target_portal DaemonSetV1#target_portal}
        """
        result = self._values.get("target_portal")
        assert result is not None, "Required property 'target_portal' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type of the volume that you want to mount.

        Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#iscsi

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iscsi_interface(self) -> typing.Optional[builtins.str]:
        """iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iscsi_interface DaemonSetV1#iscsi_interface}
        """
        result = self._values.get("iscsi_interface")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lun(self) -> typing.Optional[jsii.Number]:
        """iSCSI target lun number.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lun DaemonSetV1#lun}
        """
        result = self._values.get("lun")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the read-only setting in VolumeMounts. Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeIscsi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeIscsiOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeIscsiOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9eebd0c39edf6c57c4f20e6408d189c983f33246b0fd42fc7ab89a25ae151c8f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetIscsiInterface")
    def reset_iscsi_interface(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIscsiInterface", []))

    @jsii.member(jsii_name="resetLun")
    def reset_lun(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLun", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="iqnInput")
    def iqn_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "iqnInput"))

    @builtins.property
    @jsii.member(jsii_name="iscsiInterfaceInput")
    def iscsi_interface_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "iscsiInterfaceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="lunInput")
    def lun_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "lunInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="targetPortalInput")
    def target_portal_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "targetPortalInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba24ca5c918f3c627436b44b3e93a8033fbe68864e99affc00d30fadf7cdf9f4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="iqn")
    def iqn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "iqn"))

    @iqn.setter
    def iqn(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fcccc408f43436f8020e4ed62072c770c929e8ae656aa262e6dfd267fb5e0be5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "iqn", value)

    @builtins.property
    @jsii.member(jsii_name="iscsiInterface")
    def iscsi_interface(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "iscsiInterface"))

    @iscsi_interface.setter
    def iscsi_interface(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__196868eca1d53a24572344fceb4e4aa7017c1ebf377cb2b31d6a3830f1c67b22
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "iscsiInterface", value)

    @builtins.property
    @jsii.member(jsii_name="lun")
    def lun(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "lun"))

    @lun.setter
    def lun(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__19ac0545ba00bd2af119be7dd4d7beb04a0431c308aad75bd8829fd148839928
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "lun", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__77fe5dff87b7639f9fd30f3ed94a35083a27169bf27c4c59d2c8b384682f4b31
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="targetPortal")
    def target_portal(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "targetPortal"))

    @target_portal.setter
    def target_portal(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3b791222b335cd1aeee84c86127b25d5cd7d99c7ed65431db0a187e0bdbbe711
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "targetPortal", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeIscsi]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeIscsi],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeIscsi],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4d04acf21ea28c1e3d6ff9677676980347d9add83ecc37f8756a7a55252c9d0e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__02e0f67c84db748d224e4ee091fadbc0c38e30ecd0409e6dd1239827d8ac86ba
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8964f16048920ff6d141f0709da0721e7d4ed03fc0365d289a891ca017155228
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e894cc34e7edec4857a9cbf9052eb85d1c8a8ab2c5c8bc97e47434162ece9b08
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f59d8796e68f9031a72e3906ba7b52949a52aa236c4bfff7c9499f1afdb69f7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__745ba0e96e6a6304e56a7ef98cbd57b691180a513168994e05c83dd923e2181f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[DaemonSetV1SpecTemplateSpecVolume]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolume],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolume],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7d454899559822542bb473d3de5f0dd86f29cf67e4bdfbc6755e5f0d9e6b6206
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeLocal",
    jsii_struct_bases=[],
    name_mapping={"path": "path"},
)
class DaemonSetV1SpecTemplateSpecVolumeLocal:
    def __init__(self, *, path: typing.Optional[builtins.str] = None) -> None:
        """
        :param path: Path of the directory on the host. More info: http://kubernetes.io/docs/user-guide/volumes#local. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dc750ff7a935272686157b3a9d669600d5fb47dfe1e250bbcc95dcbbe22f4c4a
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path of the directory on the host. More info: http://kubernetes.io/docs/user-guide/volumes#local.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeLocal(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeLocalOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeLocalOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ba1eed458896fa41c5fe2a83095e1e7177dcbdacec594674b870685072d5bbd6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f9763d3aea04c14042da34256cb83492a1599b0e31dd66c7dfdd17f09120613a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeLocal]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeLocal],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeLocal],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aa2db6b8cbcc0283b324e174ec00f2d317d81a9ec4de63c15f089595c9a85a3b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeNfs",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "server": "server", "read_only": "readOnly"},
)
class DaemonSetV1SpecTemplateSpecVolumeNfs:
    def __init__(
        self,
        *,
        path: builtins.str,
        server: builtins.str,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param path: Path that is exported by the NFS server. More info: http://kubernetes.io/docs/user-guide/volumes#nfs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param server: Server is the hostname or IP address of the NFS server. More info: http://kubernetes.io/docs/user-guide/volumes#nfs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#server DaemonSetV1#server}
        :param read_only: Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: http://kubernetes.io/docs/user-guide/volumes#nfs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__13c9342b9f8155760b77183288a0342888cf7b542dea8898db1d4d565d70d3b4
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument server",
                value=server,
                expected_type=type_hints["server"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "server": server,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def path(self) -> builtins.str:
        """Path that is exported by the NFS server. More info: http://kubernetes.io/docs/user-guide/volumes#nfs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def server(self) -> builtins.str:
        """Server is the hostname or IP address of the NFS server. More info: http://kubernetes.io/docs/user-guide/volumes#nfs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#server DaemonSetV1#server}
        """
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: http://kubernetes.io/docs/user-guide/volumes#nfs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeNfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeNfsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeNfsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0dad8a914be304d45d843fec22d6617267d3a01a9ec7f916f70eecee9df17a48
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="serverInput")
    def server_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "serverInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5dfb2468b4a884c3c6576c57e5b74dfc96ab47b6e36f94cbf9049a5088869b98
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1d2acc35d0f9e8298f1409563315edf1c9c2bd7b540d51d8f27fe54a6282f130
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="server")
    def server(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "server"))

    @server.setter
    def server(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3efaefd573325edf08e545c90e7ac1475077ec2e99a7b3970366fc86291e5161
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "server", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeNfs]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeNfs],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeNfs],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca8b06ce8f1bc02c661193e9aaf7ccd5b994be871a1b562a9e0541a132f6a89b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56b1e48bc000fd89babb1ecff4f2b539e6f1f4d6e513580528cceb3e7a9d5e5a
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putAwsElasticBlockStore")
    def put_aws_elastic_block_store(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param volume_id: Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_id DaemonSetV1#volume_id}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#partition DaemonSetV1#partition}
        :param read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore(
            volume_id=volume_id,
            fs_type=fs_type,
            partition=partition,
            read_only=read_only,
        )

        return typing.cast(None, jsii.invoke(self, "putAwsElasticBlockStore", [value]))

    @jsii.member(jsii_name="putAzureDisk")
    def put_azure_disk(
        self,
        *,
        caching_mode: builtins.str,
        data_disk_uri: builtins.str,
        disk_name: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param caching_mode: Host Caching mode: None, Read Only, Read Write. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#caching_mode DaemonSetV1#caching_mode}
        :param data_disk_uri: The URI the data disk in the blob storage. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#data_disk_uri DaemonSetV1#data_disk_uri}
        :param disk_name: The Name of the data disk in the blob storage. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#disk_name DaemonSetV1#disk_name}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param kind: The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#kind DaemonSetV1#kind}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeAzureDisk(
            caching_mode=caching_mode,
            data_disk_uri=data_disk_uri,
            disk_name=disk_name,
            fs_type=fs_type,
            kind=kind,
            read_only=read_only,
        )

        return typing.cast(None, jsii.invoke(self, "putAzureDisk", [value]))

    @jsii.member(jsii_name="putAzureFile")
    def put_azure_file(
        self,
        *,
        secret_name: builtins.str,
        share_name: builtins.str,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param secret_name: The name of secret that contains Azure Storage Account Name and Key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_name DaemonSetV1#secret_name}
        :param share_name: Share Name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#share_name DaemonSetV1#share_name}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_namespace: The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_namespace DaemonSetV1#secret_namespace}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeAzureFile(
            secret_name=secret_name,
            share_name=share_name,
            read_only=read_only,
            secret_namespace=secret_namespace,
        )

        return typing.cast(None, jsii.invoke(self, "putAzureFile", [value]))

    @jsii.member(jsii_name="putCephFs")
    def put_ceph_fs(
        self,
        *,
        monitors: typing.Sequence[builtins.str],
        path: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_file: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param monitors: Monitors is a collection of Ceph monitors More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#monitors DaemonSetV1#monitors}
        :param path: Used as the mounted root, rather than the full Ceph tree, default is /. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to ``false`` (read/write). More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_file: The path to key ring for User, default is /etc/ceph/user.secret More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_file DaemonSetV1#secret_file}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        :param user: User is the rados user name, default is admin. More info: http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeCephFs(
            monitors=monitors,
            path=path,
            read_only=read_only,
            secret_file=secret_file,
            secret_ref=secret_ref,
            user=user,
        )

        return typing.cast(None, jsii.invoke(self, "putCephFs", [value]))

    @jsii.member(jsii_name="putCinder")
    def put_cinder(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param volume_id: Volume ID used to identify the volume in Cinder. More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_id DaemonSetV1#volume_id}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeCinder(
            volume_id=volume_id, fs_type=fs_type, read_only=read_only
        )

        return typing.cast(None, jsii.invoke(self, "putCinder", [value]))

    @jsii.member(jsii_name="putConfigMap")
    def put_config_map(
        self,
        *,
        default_mode: typing.Optional[builtins.str] = None,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecVolumeConfigMapItems,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Optional: Specify whether the ConfigMap or its keys must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeConfigMap(
            default_mode=default_mode, items=items, name=name, optional=optional
        )

        return typing.cast(None, jsii.invoke(self, "putConfigMap", [value]))

    @jsii.member(jsii_name="putCsi")
    def put_csi(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        node_publish_secret_ref: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        volume_attributes: typing.Optional[
            typing.Mapping[builtins.str, builtins.str]
        ] = None,
    ) -> None:
        """
        :param driver: the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#driver DaemonSetV1#driver}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param node_publish_secret_ref: node_publish_secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#node_publish_secret_ref DaemonSetV1#node_publish_secret_ref}
        :param read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: http://kubernetes.io/docs/user-guide/volumes#csi. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param volume_attributes: Attributes of the volume to publish. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_attributes DaemonSetV1#volume_attributes}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeCsi(
            driver=driver,
            fs_type=fs_type,
            node_publish_secret_ref=node_publish_secret_ref,
            read_only=read_only,
            volume_attributes=volume_attributes,
        )

        return typing.cast(None, jsii.invoke(self, "putCsi", [value]))

    @jsii.member(jsii_name="putDownwardApi")
    def put_downward_api(
        self,
        *,
        default_mode: typing.Optional[builtins.str] = None,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeDownwardApi(
            default_mode=default_mode, items=items
        )

        return typing.cast(None, jsii.invoke(self, "putDownwardApi", [value]))

    @jsii.member(jsii_name="putEmptyDir")
    def put_empty_dir(
        self,
        *,
        medium: typing.Optional[builtins.str] = None,
        size_limit: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param medium: What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#medium DaemonSetV1#medium}
        :param size_limit: Total amount of local storage required for this EmptyDir volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#size_limit DaemonSetV1#size_limit}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeEmptyDir(
            medium=medium, size_limit=size_limit
        )

        return typing.cast(None, jsii.invoke(self, "putEmptyDir", [value]))

    @jsii.member(jsii_name="putFc")
    def put_fc(
        self,
        *,
        lun: jsii.Number,
        target_ww_ns: typing.Sequence[builtins.str],
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param lun: FC target lun number. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lun DaemonSetV1#lun}
        :param target_ww_ns: FC target worldwide names (WWNs). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#target_ww_ns DaemonSetV1#target_ww_ns}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeFc(
            lun=lun, target_ww_ns=target_ww_ns, fs_type=fs_type, read_only=read_only
        )

        return typing.cast(None, jsii.invoke(self, "putFc", [value]))

    @jsii.member(jsii_name="putFlexVolume")
    def put_flex_volume(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        options: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_ref: typing.Optional[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param driver: Driver is the name of the driver to use for this volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#driver DaemonSetV1#driver}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param options: Extra command options if any. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#options DaemonSetV1#options}
        :param read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeFlexVolume(
            driver=driver,
            fs_type=fs_type,
            options=options,
            read_only=read_only,
            secret_ref=secret_ref,
        )

        return typing.cast(None, jsii.invoke(self, "putFlexVolume", [value]))

    @jsii.member(jsii_name="putFlocker")
    def put_flocker(
        self,
        *,
        dataset_name: typing.Optional[builtins.str] = None,
        dataset_uuid: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param dataset_name: Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dataset_name DaemonSetV1#dataset_name}
        :param dataset_uuid: UUID of the dataset. This is unique identifier of a Flocker dataset. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#dataset_uuid DaemonSetV1#dataset_uuid}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeFlocker(
            dataset_name=dataset_name, dataset_uuid=dataset_uuid
        )

        return typing.cast(None, jsii.invoke(self, "putFlocker", [value]))

    @jsii.member(jsii_name="putGcePersistentDisk")
    def put_gce_persistent_disk(
        self,
        *,
        pd_name: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param pd_name: Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pd_name DaemonSetV1#pd_name}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#partition DaemonSetV1#partition}
        :param read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk(
            pd_name=pd_name, fs_type=fs_type, partition=partition, read_only=read_only
        )

        return typing.cast(None, jsii.invoke(self, "putGcePersistentDisk", [value]))

    @jsii.member(jsii_name="putGitRepo")
    def put_git_repo(
        self,
        *,
        directory: typing.Optional[builtins.str] = None,
        repository: typing.Optional[builtins.str] = None,
        revision: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param directory: Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#directory DaemonSetV1#directory}
        :param repository: Repository URL. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#repository DaemonSetV1#repository}
        :param revision: Commit hash for the specified revision. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#revision DaemonSetV1#revision}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeGitRepo(
            directory=directory, repository=repository, revision=revision
        )

        return typing.cast(None, jsii.invoke(self, "putGitRepo", [value]))

    @jsii.member(jsii_name="putGlusterfs")
    def put_glusterfs(
        self,
        *,
        endpoints_name: builtins.str,
        path: builtins.str,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param endpoints_name: The endpoint name that details Glusterfs topology. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#endpoints_name DaemonSetV1#endpoints_name}
        :param path: The Glusterfs volume path. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param read_only: Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeGlusterfs(
            endpoints_name=endpoints_name, path=path, read_only=read_only
        )

        return typing.cast(None, jsii.invoke(self, "putGlusterfs", [value]))

    @jsii.member(jsii_name="putHostPath")
    def put_host_path(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param path: Path of the directory on the host. More info: http://kubernetes.io/docs/user-guide/volumes#hostpath. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param type: Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#type DaemonSetV1#type}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeHostPath(path=path, type=type)

        return typing.cast(None, jsii.invoke(self, "putHostPath", [value]))

    @jsii.member(jsii_name="putIscsi")
    def put_iscsi(
        self,
        *,
        iqn: builtins.str,
        target_portal: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        iscsi_interface: typing.Optional[builtins.str] = None,
        lun: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param iqn: Target iSCSI Qualified Name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iqn DaemonSetV1#iqn}
        :param target_portal: iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#target_portal DaemonSetV1#target_portal}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#iscsi Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param iscsi_interface: iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#iscsi_interface DaemonSetV1#iscsi_interface}
        :param lun: iSCSI target lun number. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#lun DaemonSetV1#lun}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeIscsi(
            iqn=iqn,
            target_portal=target_portal,
            fs_type=fs_type,
            iscsi_interface=iscsi_interface,
            lun=lun,
            read_only=read_only,
        )

        return typing.cast(None, jsii.invoke(self, "putIscsi", [value]))

    @jsii.member(jsii_name="putLocal")
    def put_local(self, *, path: typing.Optional[builtins.str] = None) -> None:
        """
        :param path: Path of the directory on the host. More info: http://kubernetes.io/docs/user-guide/volumes#local. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeLocal(path=path)

        return typing.cast(None, jsii.invoke(self, "putLocal", [value]))

    @jsii.member(jsii_name="putNfs")
    def put_nfs(
        self,
        *,
        path: builtins.str,
        server: builtins.str,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param path: Path that is exported by the NFS server. More info: http://kubernetes.io/docs/user-guide/volumes#nfs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param server: Server is the hostname or IP address of the NFS server. More info: http://kubernetes.io/docs/user-guide/volumes#nfs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#server DaemonSetV1#server}
        :param read_only: Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: http://kubernetes.io/docs/user-guide/volumes#nfs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeNfs(
            path=path, server=server, read_only=read_only
        )

        return typing.cast(None, jsii.invoke(self, "putNfs", [value]))

    @jsii.member(jsii_name="putPersistentVolumeClaim")
    def put_persistent_volume_claim(
        self,
        *,
        claim_name: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param claim_name: ClaimName is the name of a PersistentVolumeClaim in the same. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#claim_name DaemonSetV1#claim_name}
        :param read_only: Will force the ReadOnly setting in VolumeMounts. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        value = DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim(
            claim_name=claim_name, read_only=read_only
        )

        return typing.cast(None, jsii.invoke(self, "putPersistentVolumeClaim", [value]))

    @jsii.member(jsii_name="putPhotonPersistentDisk")
    def put_photon_persistent_disk(
        self,
        *,
        pd_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param pd_id: ID that identifies Photon Controller persistent disk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pd_id DaemonSetV1#pd_id}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        value = DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk(
            pd_id=pd_id, fs_type=fs_type
        )

        return typing.cast(None, jsii.invoke(self, "putPhotonPersistentDisk", [value]))

    @jsii.member(jsii_name="putProjected")
    def put_projected(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecVolumeProjected",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__88a4e6815431239f5c8a8a2ce116052e5c1ce792e31b56a03fcacd116bbcf3d9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putProjected", [value]))

    @jsii.member(jsii_name="putQuobyte")
    def put_quobyte(
        self,
        *,
        registry: builtins.str,
        volume: builtins.str,
        group: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry: Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#registry DaemonSetV1#registry}
        :param volume: Volume is a string that references an already created Quobyte volume by name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume DaemonSetV1#volume}
        :param group: Group to map volume access to Default is no group. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#group DaemonSetV1#group}
        :param read_only: Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param user: User to map volume access to Defaults to serivceaccount user. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeQuobyte(
            registry=registry,
            volume=volume,
            group=group,
            read_only=read_only,
            user=user,
        )

        return typing.cast(None, jsii.invoke(self, "putQuobyte", [value]))

    @jsii.member(jsii_name="putRbd")
    def put_rbd(
        self,
        *,
        ceph_monitors: typing.Sequence[builtins.str],
        rbd_image: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        keyring: typing.Optional[builtins.str] = None,
        rados_user: typing.Optional[builtins.str] = None,
        rbd_pool: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param ceph_monitors: A collection of Ceph monitors. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#ceph_monitors DaemonSetV1#ceph_monitors}
        :param rbd_image: The rados image name. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd_image DaemonSetV1#rbd_image}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#rbd Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param keyring: Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#keyring DaemonSetV1#keyring}
        :param rados_user: The rados user name. Default is admin. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rados_user DaemonSetV1#rados_user}
        :param rbd_pool: The rados pool name. Default is rbd. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd_pool DaemonSetV1#rbd_pool}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeRbd(
            ceph_monitors=ceph_monitors,
            rbd_image=rbd_image,
            fs_type=fs_type,
            keyring=keyring,
            rados_user=rados_user,
            rbd_pool=rbd_pool,
            read_only=read_only,
            secret_ref=secret_ref,
        )

        return typing.cast(None, jsii.invoke(self, "putRbd", [value]))

    @jsii.member(jsii_name="putSecret")
    def put_secret(
        self,
        *,
        default_mode: typing.Optional[builtins.str] = None,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeSecretItems",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        :param optional: Optional: Specify whether the Secret or its keys must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        :param secret_name: Name of the secret in the pod's namespace to use. More info: http://kubernetes.io/docs/user-guide/volumes#secrets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_name DaemonSetV1#secret_name}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeSecret(
            default_mode=default_mode,
            items=items,
            optional=optional,
            secret_name=secret_name,
        )

        return typing.cast(None, jsii.invoke(self, "putSecret", [value]))

    @jsii.member(jsii_name="putVsphereVolume")
    def put_vsphere_volume(
        self,
        *,
        volume_path: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param volume_path: Path that identifies vSphere volume vmdk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_path DaemonSetV1#volume_path}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeVsphereVolume(
            volume_path=volume_path, fs_type=fs_type
        )

        return typing.cast(None, jsii.invoke(self, "putVsphereVolume", [value]))

    @jsii.member(jsii_name="resetAwsElasticBlockStore")
    def reset_aws_elastic_block_store(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAwsElasticBlockStore", []))

    @jsii.member(jsii_name="resetAzureDisk")
    def reset_azure_disk(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAzureDisk", []))

    @jsii.member(jsii_name="resetAzureFile")
    def reset_azure_file(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAzureFile", []))

    @jsii.member(jsii_name="resetCephFs")
    def reset_ceph_fs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCephFs", []))

    @jsii.member(jsii_name="resetCinder")
    def reset_cinder(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCinder", []))

    @jsii.member(jsii_name="resetConfigMap")
    def reset_config_map(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigMap", []))

    @jsii.member(jsii_name="resetCsi")
    def reset_csi(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCsi", []))

    @jsii.member(jsii_name="resetDownwardApi")
    def reset_downward_api(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDownwardApi", []))

    @jsii.member(jsii_name="resetEmptyDir")
    def reset_empty_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEmptyDir", []))

    @jsii.member(jsii_name="resetFc")
    def reset_fc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFc", []))

    @jsii.member(jsii_name="resetFlexVolume")
    def reset_flex_volume(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFlexVolume", []))

    @jsii.member(jsii_name="resetFlocker")
    def reset_flocker(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFlocker", []))

    @jsii.member(jsii_name="resetGcePersistentDisk")
    def reset_gce_persistent_disk(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcePersistentDisk", []))

    @jsii.member(jsii_name="resetGitRepo")
    def reset_git_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitRepo", []))

    @jsii.member(jsii_name="resetGlusterfs")
    def reset_glusterfs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGlusterfs", []))

    @jsii.member(jsii_name="resetHostPath")
    def reset_host_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostPath", []))

    @jsii.member(jsii_name="resetIscsi")
    def reset_iscsi(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIscsi", []))

    @jsii.member(jsii_name="resetLocal")
    def reset_local(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocal", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetNfs")
    def reset_nfs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNfs", []))

    @jsii.member(jsii_name="resetPersistentVolumeClaim")
    def reset_persistent_volume_claim(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPersistentVolumeClaim", []))

    @jsii.member(jsii_name="resetPhotonPersistentDisk")
    def reset_photon_persistent_disk(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPhotonPersistentDisk", []))

    @jsii.member(jsii_name="resetProjected")
    def reset_projected(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProjected", []))

    @jsii.member(jsii_name="resetQuobyte")
    def reset_quobyte(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetQuobyte", []))

    @jsii.member(jsii_name="resetRbd")
    def reset_rbd(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRbd", []))

    @jsii.member(jsii_name="resetSecret")
    def reset_secret(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecret", []))

    @jsii.member(jsii_name="resetVsphereVolume")
    def reset_vsphere_volume(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVsphereVolume", []))

    @builtins.property
    @jsii.member(jsii_name="awsElasticBlockStore")
    def aws_elastic_block_store(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStoreOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStoreOutputReference,
            jsii.get(self, "awsElasticBlockStore"),
        )

    @builtins.property
    @jsii.member(jsii_name="azureDisk")
    def azure_disk(self) -> DaemonSetV1SpecTemplateSpecVolumeAzureDiskOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeAzureDiskOutputReference,
            jsii.get(self, "azureDisk"),
        )

    @builtins.property
    @jsii.member(jsii_name="azureFile")
    def azure_file(self) -> DaemonSetV1SpecTemplateSpecVolumeAzureFileOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeAzureFileOutputReference,
            jsii.get(self, "azureFile"),
        )

    @builtins.property
    @jsii.member(jsii_name="cephFs")
    def ceph_fs(self) -> DaemonSetV1SpecTemplateSpecVolumeCephFsOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeCephFsOutputReference,
            jsii.get(self, "cephFs"),
        )

    @builtins.property
    @jsii.member(jsii_name="cinder")
    def cinder(self) -> DaemonSetV1SpecTemplateSpecVolumeCinderOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeCinderOutputReference,
            jsii.get(self, "cinder"),
        )

    @builtins.property
    @jsii.member(jsii_name="configMap")
    def config_map(self) -> DaemonSetV1SpecTemplateSpecVolumeConfigMapOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeConfigMapOutputReference,
            jsii.get(self, "configMap"),
        )

    @builtins.property
    @jsii.member(jsii_name="csi")
    def csi(self) -> DaemonSetV1SpecTemplateSpecVolumeCsiOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeCsiOutputReference, jsii.get(self, "csi")
        )

    @builtins.property
    @jsii.member(jsii_name="downwardApi")
    def downward_api(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeDownwardApiOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiOutputReference,
            jsii.get(self, "downwardApi"),
        )

    @builtins.property
    @jsii.member(jsii_name="emptyDir")
    def empty_dir(self) -> DaemonSetV1SpecTemplateSpecVolumeEmptyDirOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeEmptyDirOutputReference,
            jsii.get(self, "emptyDir"),
        )

    @builtins.property
    @jsii.member(jsii_name="fc")
    def fc(self) -> DaemonSetV1SpecTemplateSpecVolumeFcOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeFcOutputReference, jsii.get(self, "fc")
        )

    @builtins.property
    @jsii.member(jsii_name="flexVolume")
    def flex_volume(self) -> DaemonSetV1SpecTemplateSpecVolumeFlexVolumeOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeFlexVolumeOutputReference,
            jsii.get(self, "flexVolume"),
        )

    @builtins.property
    @jsii.member(jsii_name="flocker")
    def flocker(self) -> DaemonSetV1SpecTemplateSpecVolumeFlockerOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeFlockerOutputReference,
            jsii.get(self, "flocker"),
        )

    @builtins.property
    @jsii.member(jsii_name="gcePersistentDisk")
    def gce_persistent_disk(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeGcePersistentDiskOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeGcePersistentDiskOutputReference,
            jsii.get(self, "gcePersistentDisk"),
        )

    @builtins.property
    @jsii.member(jsii_name="gitRepo")
    def git_repo(self) -> DaemonSetV1SpecTemplateSpecVolumeGitRepoOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeGitRepoOutputReference,
            jsii.get(self, "gitRepo"),
        )

    @builtins.property
    @jsii.member(jsii_name="glusterfs")
    def glusterfs(self) -> DaemonSetV1SpecTemplateSpecVolumeGlusterfsOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeGlusterfsOutputReference,
            jsii.get(self, "glusterfs"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostPath")
    def host_path(self) -> DaemonSetV1SpecTemplateSpecVolumeHostPathOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeHostPathOutputReference,
            jsii.get(self, "hostPath"),
        )

    @builtins.property
    @jsii.member(jsii_name="iscsi")
    def iscsi(self) -> DaemonSetV1SpecTemplateSpecVolumeIscsiOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeIscsiOutputReference,
            jsii.get(self, "iscsi"),
        )

    @builtins.property
    @jsii.member(jsii_name="local")
    def local(self) -> DaemonSetV1SpecTemplateSpecVolumeLocalOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeLocalOutputReference,
            jsii.get(self, "local"),
        )

    @builtins.property
    @jsii.member(jsii_name="nfs")
    def nfs(self) -> DaemonSetV1SpecTemplateSpecVolumeNfsOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeNfsOutputReference, jsii.get(self, "nfs")
        )

    @builtins.property
    @jsii.member(jsii_name="persistentVolumeClaim")
    def persistent_volume_claim(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaimOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaimOutputReference",
            jsii.get(self, "persistentVolumeClaim"),
        )

    @builtins.property
    @jsii.member(jsii_name="photonPersistentDisk")
    def photon_persistent_disk(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDiskOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDiskOutputReference",
            jsii.get(self, "photonPersistentDisk"),
        )

    @builtins.property
    @jsii.member(jsii_name="projected")
    def projected(self) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedList",
            jsii.get(self, "projected"),
        )

    @builtins.property
    @jsii.member(jsii_name="quobyte")
    def quobyte(self) -> "DaemonSetV1SpecTemplateSpecVolumeQuobyteOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeQuobyteOutputReference",
            jsii.get(self, "quobyte"),
        )

    @builtins.property
    @jsii.member(jsii_name="rbd")
    def rbd(self) -> "DaemonSetV1SpecTemplateSpecVolumeRbdOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeRbdOutputReference", jsii.get(self, "rbd")
        )

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> "DaemonSetV1SpecTemplateSpecVolumeSecretOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeSecretOutputReference",
            jsii.get(self, "secret"),
        )

    @builtins.property
    @jsii.member(jsii_name="vsphereVolume")
    def vsphere_volume(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeVsphereVolumeOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeVsphereVolumeOutputReference",
            jsii.get(self, "vsphereVolume"),
        )

    @builtins.property
    @jsii.member(jsii_name="awsElasticBlockStoreInput")
    def aws_elastic_block_store_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore],
            jsii.get(self, "awsElasticBlockStoreInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="azureDiskInput")
    def azure_disk_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureDisk]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureDisk],
            jsii.get(self, "azureDiskInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="azureFileInput")
    def azure_file_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureFile]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureFile],
            jsii.get(self, "azureFileInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="cephFsInput")
    def ceph_fs_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFs]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFs],
            jsii.get(self, "cephFsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="cinderInput")
    def cinder_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCinder]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCinder],
            jsii.get(self, "cinderInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="configMapInput")
    def config_map_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeConfigMap]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeConfigMap],
            jsii.get(self, "configMapInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="csiInput")
    def csi_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsi]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsi],
            jsii.get(self, "csiInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="downwardApiInput")
    def downward_api_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApi]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApi],
            jsii.get(self, "downwardApiInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="emptyDirInput")
    def empty_dir_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeEmptyDir]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeEmptyDir],
            jsii.get(self, "emptyDirInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="fcInput")
    def fc_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFc]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFc],
            jsii.get(self, "fcInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="flexVolumeInput")
    def flex_volume_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolume]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolume],
            jsii.get(self, "flexVolumeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="flockerInput")
    def flocker_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlocker]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlocker],
            jsii.get(self, "flockerInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="gcePersistentDiskInput")
    def gce_persistent_disk_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk],
            jsii.get(self, "gcePersistentDiskInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="gitRepoInput")
    def git_repo_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGitRepo]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGitRepo],
            jsii.get(self, "gitRepoInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="glusterfsInput")
    def glusterfs_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGlusterfs]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGlusterfs],
            jsii.get(self, "glusterfsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="hostPathInput")
    def host_path_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeHostPath]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeHostPath],
            jsii.get(self, "hostPathInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="iscsiInput")
    def iscsi_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeIscsi]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeIscsi],
            jsii.get(self, "iscsiInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="localInput")
    def local_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeLocal]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeLocal],
            jsii.get(self, "localInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="nfsInput")
    def nfs_input(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeNfs]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeNfs],
            jsii.get(self, "nfsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="persistentVolumeClaimInput")
    def persistent_volume_claim_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim"],
            jsii.get(self, "persistentVolumeClaimInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="photonPersistentDiskInput")
    def photon_persistent_disk_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk"],
            jsii.get(self, "photonPersistentDiskInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="projectedInput")
    def projected_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeProjected"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolumeProjected"],
                ]
            ],
            jsii.get(self, "projectedInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="quobyteInput")
    def quobyte_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeQuobyte"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeQuobyte"],
            jsii.get(self, "quobyteInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="rbdInput")
    def rbd_input(self) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbd"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbd"],
            jsii.get(self, "rbdInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretInput")
    def secret_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeSecret"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeSecret"],
            jsii.get(self, "secretInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="vsphereVolumeInput")
    def vsphere_volume_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeVsphereVolume"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeVsphereVolume"],
            jsii.get(self, "vsphereVolumeInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9ad3219a1d24b7fd5c05c049210d3663d5976fb7ad7db7e943afd946659666b9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolume]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolume
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolume]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__62d632dc3b60582a5d0165a76af6bf99fdfb76f155fdb9e32521b4ebed0f43a6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim",
    jsii_struct_bases=[],
    name_mapping={"claim_name": "claimName", "read_only": "readOnly"},
)
class DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim:
    def __init__(
        self,
        *,
        claim_name: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param claim_name: ClaimName is the name of a PersistentVolumeClaim in the same. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#claim_name DaemonSetV1#claim_name}
        :param read_only: Will force the ReadOnly setting in VolumeMounts. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf6e39560575b65d73188b25309438ca02038471b46c980cb8ad46fa8e2e26fc
            )
            check_type(
                argname="argument claim_name",
                value=claim_name,
                expected_type=type_hints["claim_name"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if claim_name is not None:
            self._values["claim_name"] = claim_name
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def claim_name(self) -> typing.Optional[builtins.str]:
        """ClaimName is the name of a PersistentVolumeClaim in the same.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#claim_name DaemonSetV1#claim_name}
        """
        result = self._values.get("claim_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Will force the ReadOnly setting in VolumeMounts.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaimOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaimOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af1d5a7ed0a121757d47833216d31e5b5b4b0b8578c4b16c01cc7f4cb73f8d34
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetClaimName")
    def reset_claim_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClaimName", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @builtins.property
    @jsii.member(jsii_name="claimNameInput")
    def claim_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "claimNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="claimName")
    def claim_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "claimName"))

    @claim_name.setter
    def claim_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7df2406ff0b3a42eaa8c6a6e3dce161ba88b7b19f86976e23530f34a0a699f03
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "claimName", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1c71b8d6e9bb8f770faf9bbaca3d2bbd201d0e73174196e18f61636356188f72
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0e4ab30dbc6b84016ee57666cf8705e21fde2c56ef6c632c564d3b373b8dff42
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk",
    jsii_struct_bases=[],
    name_mapping={"pd_id": "pdId", "fs_type": "fsType"},
)
class DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk:
    def __init__(
        self,
        *,
        pd_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param pd_id: ID that identifies Photon Controller persistent disk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pd_id DaemonSetV1#pd_id}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__88015965d2762a2409f41a96648bce6795480d4ca4ce5830ca76be91cc1f83a7
            )
            check_type(
                argname="argument pd_id", value=pd_id, expected_type=type_hints["pd_id"]
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pd_id": pd_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type

    @builtins.property
    def pd_id(self) -> builtins.str:
        """ID that identifies Photon Controller persistent disk.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#pd_id DaemonSetV1#pd_id}
        """
        result = self._values.get("pd_id")
        assert result is not None, "Required property 'pd_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type to mount.

        Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDiskOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDiskOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a898827705c07b2c9569f2536c08d80d1a66f5f7c8f89f5f2fbede8c4888b230
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="pdIdInput")
    def pd_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pdIdInput"))

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c890cfd76594d7a1662216bd36fafd2fe5b75dee476da74313ea8542b103a97
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="pdId")
    def pd_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pdId"))

    @pd_id.setter
    def pd_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__428ecda81f8821ceb68b544969e4af3e6186a0f1470f5775a8efa3fc75b276c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "pdId", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__908cb7c637be40ba66334de28748ea7907a8bbf1962f13db747fde0af7c918a8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjected",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "default_mode": "defaultMode"},
)
class DaemonSetV1SpecTemplateSpecVolumeProjected:
    def __init__(
        self,
        *,
        sources: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecVolumeProjectedSources",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
        default_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param sources: sources block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sources DaemonSetV1#sources}
        :param default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2446abed254e4f20b9b9c6eef30311930cebeb02b029d386d27289051856dab3
            )
            check_type(
                argname="argument sources",
                value=sources,
                expected_type=type_hints["sources"],
            )
            check_type(
                argname="argument default_mode",
                value=default_mode,
                expected_type=type_hints["default_mode"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "sources": sources,
        }
        if default_mode is not None:
            self._values["default_mode"] = default_mode

    @builtins.property
    def sources(
        self,
    ) -> typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSources"],
    ]:
        """sources block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#sources DaemonSetV1#sources}
        """
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSources"],
            ],
            result,
        )

    @builtins.property
    def default_mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on created files by default.

        Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        """
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeProjected(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeProjectedList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fe291b65d56c7f065fa84be01331e9a6b424f9418bee18a0f2bbaf0a44777435
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7aa3311ef382870db5f13b081ff4e165976ed119962959093cbad32df0671597
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1e32260f5d62143675ad604d68482d032548e172ece664037fb98ddead556810
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8c5ee6a702249d8682c95fefff79451d6fd3a6f32178b66f1ff0a78c87539fe9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e812708440d794689f4348f7347c04667666c495c027e38f54147fabc2dbf1a9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjected],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeProjected],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolumeProjected],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__73e6ab0d34b504ad5cbbafea31accc0f8737f11639b9186ff65f3eba9411e63a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d94dbd2ea0418e349ff54c661e33d51bb6ecf8099887adb0bbc18b0bdfe9dc82
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putSources")
    def put_sources(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecVolumeProjectedSources",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__62125f29416d8bbb334b6ccae14d22ed8af678711de46422400d570138f5b31f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putSources", [value]))

    @jsii.member(jsii_name="resetDefaultMode")
    def reset_default_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultMode", []))

    @builtins.property
    @jsii.member(jsii_name="sources")
    def sources(self) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesList",
            jsii.get(self, "sources"),
        )

    @builtins.property
    @jsii.member(jsii_name="defaultModeInput")
    def default_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "defaultModeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="sourcesInput")
    def sources_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSources"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSources"],
                ]
            ],
            jsii.get(self, "sourcesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="defaultMode")
    def default_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "defaultMode"))

    @default_mode.setter
    def default_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5eb7d6f18c17a71154a1eed95d4cee64436f0c4e761bdef50010b2a01f353e53
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "defaultMode", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolumeProjected
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeProjected,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolumeProjected
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bb33dda28c16f32f13d2d2ef20137214806c5fb533f320ba02d868f88eae8029
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSources",
    jsii_struct_bases=[],
    name_mapping={
        "config_map": "configMap",
        "downward_api": "downwardApi",
        "secret": "secret",
        "service_account_token": "serviceAccountToken",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSources:
    def __init__(
        self,
        *,
        config_map: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        downward_api: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        secret: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        service_account_token: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param config_map: config_map block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map DaemonSetV1#config_map}
        :param downward_api: downward_api block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#downward_api DaemonSetV1#downward_api}
        :param secret: secret block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret DaemonSetV1#secret}
        :param service_account_token: service_account_token block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service_account_token DaemonSetV1#service_account_token}
        """
        if isinstance(downward_api, dict):
            downward_api = DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi(
                **downward_api
            )
        if isinstance(service_account_token, dict):
            service_account_token = (
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken(
                    **service_account_token
                )
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5493f31ae29eebcbc40e102952475dbb80b0bb9879594a074ad2352ff9427650
            )
            check_type(
                argname="argument config_map",
                value=config_map,
                expected_type=type_hints["config_map"],
            )
            check_type(
                argname="argument downward_api",
                value=downward_api,
                expected_type=type_hints["downward_api"],
            )
            check_type(
                argname="argument secret",
                value=secret,
                expected_type=type_hints["secret"],
            )
            check_type(
                argname="argument service_account_token",
                value=service_account_token,
                expected_type=type_hints["service_account_token"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if downward_api is not None:
            self._values["downward_api"] = downward_api
        if secret is not None:
            self._values["secret"] = secret
        if service_account_token is not None:
            self._values["service_account_token"] = service_account_token

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap"],
        ]
    ]:
        """config_map block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#config_map DaemonSetV1#config_map}
        """
        result = self._values.get("config_map")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def downward_api(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi"
    ]:
        """downward_api block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#downward_api DaemonSetV1#downward_api}
        """
        result = self._values.get("downward_api")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi"
            ],
            result,
        )

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret"],
        ]
    ]:
        """secret block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret DaemonSetV1#secret}
        """
        result = self._values.get("secret")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def service_account_token(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken"
    ]:
        """service_account_token block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#service_account_token DaemonSetV1#service_account_token}
        """
        result = self._values.get("service_account_token")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeProjectedSources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap:
    def __init__(
        self,
        *,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Optional: Specify whether the ConfigMap or it's keys must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6d2c37bd49fc4cc123d19371744d7ddee7ef0c43d21d1f97317ed9e33c98a84b
            )
            check_type(
                argname="argument items", value=items, expected_type=type_hints["items"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems"
            ],
        ]
    ]:
        """items block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        result = self._values.get("items")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Optional: Specify whether the ConfigMap or it's keys must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "mode": "mode", "path": "path"},
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The key to project. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        :param path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__10503fdc8e5653e6005a58c7a1ddc78e8ba5141084ea0981eebc2be68087193c
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument mode", value=mode, expected_type=type_hints["mode"]
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if mode is not None:
            self._values["mode"] = mode
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key to project.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on this file, must be a value between 0 and 0777.

        If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        """
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """The relative path of the file to map the key to.

        May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__84efc4f49f8f4ced190f4df93dd91d4f39164de66203f43c24a8bc5a009e672b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> (
        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsOutputReference"
    ):
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2110de199c64fbddd319434a3d7f288017344d943163da8f669037e6e2d1e03f
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4dfa00089f4fef0a06568188757ce7083aed27ff83fb94b96497935ef2d3cb55
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0ef779634452507ee929392cf963572d3f98fd9ad01484567200f1db6075e54a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__86b2c2ba2756b97ac7cb65236afb7b955391c3678331ad02d9e65a4b61c76bfa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__07553062696f60966b41b1ef06fe469b4308ac28dfdba53d9b2a015524ace236
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc5b067e3466ca0e352bcf9276221ab00eef1c6f5160a481442c3b83ad8ebf08
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d5761d51b26aa935037bf6ea4816e820136df0aa5c8a051b5d285ed13f6d63c5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fc196a8d0ff7625098362058ec54ba395ce12fb762314b45d980d426bb5f9682
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mode", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0e8fddef2ce3455651ae36cffeb5be2eae4a6db168a7f0aacbb5b52d1a2d1c29
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3760d531d0f60dec5ecc1fe6fe53a5aee42624aaae05f6d9ec9a2180cd26d474
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ae68c37aee9045a58e51fca2ab085e319532efe1cfd9986ddc0529359bce8b9
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__55a04a4bdfbe48b62f3548b67eaab25d6e9e105c308b291e45447b71d6cd5b4b
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c763efd05f7dde480b34965da1aefd83e8b6a5da7f2ea9af338c6e55d52538df
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f23f8e642aa1f7a882b6601ac37538cab1de523aa8b81574c56a067801aa928
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af042122441f620d2939e666ee561a6094ff157c01e1f8722b5b6c98e3787fce
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__504ad88ce4f0f444a3731f613ea41026cf7c2ffbd01bc00091e927e1f4fb3068
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2a3ac5cef0f54b13678ddc245d8be23c3739f1a722644acca656c2629648b553
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putItems")
    def put_items(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7fea52d1fb0d3f36b637a4a842b4a331dabb9caf4662aaf9938f2f6f448c7ab
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putItems", [value]))

    @jsii.member(jsii_name="resetItems")
    def reset_items(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetItems", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="items")
    def items(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsList,
            jsii.get(self, "items"),
        )

    @builtins.property
    @jsii.member(jsii_name="itemsInput")
    def items_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems
                    ],
                ]
            ],
            jsii.get(self, "itemsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__362ffe44a1e3cea32ebfc5e67545930867b76fcd61a50af632c3997592734223
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d573b96dbe03800cd52a20b92d1e0256907e523b7a9c799e57abc7c0871eb11f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1af411bb49657b6210150171e994221f2709e405a247cb58b0b100561c2ee466
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi",
    jsii_struct_bases=[],
    name_mapping={"items": "items"},
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi:
    def __init__(
        self,
        *,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3752049330f207fb8d4b18813d047c1b5a56e54b657a6b2cbae39fef017aa3c2
            )
            check_type(
                argname="argument items", value=items, expected_type=type_hints["items"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems"
            ],
        ]
    ]:
        """items block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        result = self._values.get("items")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems"
                    ],
                ]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "field_ref": "fieldRef",
        "mode": "mode",
        "resource_field_ref": "resourceFieldRef",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems:
    def __init__(
        self,
        *,
        path: builtins.str,
        field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        mode: typing.Optional[builtins.str] = None,
        resource_field_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..' Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param field_ref: field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        :param mode: Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        :param resource_field_ref: resource_field_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        """
        if isinstance(field_ref, dict):
            field_ref = DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef(
                **field_ref
            )
        if isinstance(resource_field_ref, dict):
            resource_field_ref = DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef(
                **resource_field_ref
            )
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f6f110d6f8346fb338eaa85d8e93e89e336b56697034d44f53d1093a5f0a2e82
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument field_ref",
                value=field_ref,
                expected_type=type_hints["field_ref"],
            )
            check_type(
                argname="argument mode", value=mode, expected_type=type_hints["mode"]
            )
            check_type(
                argname="argument resource_field_ref",
                value=resource_field_ref,
                expected_type=type_hints["resource_field_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
        }
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if mode is not None:
            self._values["mode"] = mode
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref

    @builtins.property
    def path(self) -> builtins.str:
        """Path is the relative path name of the file to be created.

        Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef"
    ]:
        """field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_ref DaemonSetV1#field_ref}
        """
        result = self._values.get("field_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef"
            ],
            result,
        )

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        """Mode bits to use on this file, must be a value between 0 and 0777.

        If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        """
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef"
    ]:
        """resource_field_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource_field_ref DaemonSetV1#resource_field_ref}
        """
        result = self._values.get("resource_field_ref")
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef"
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef",
    jsii_struct_bases=[],
    name_mapping={"api_version": "apiVersion", "field_path": "fieldPath"},
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to 'v1'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9dbee94121c08de3c94a372ee16eabc79258c5c34cea24b8a4477b34672f9bed
            )
            check_type(
                argname="argument api_version",
                value=api_version,
                expected_type=type_hints["api_version"],
            )
            check_type(
                argname="argument field_path",
                value=field_path,
                expected_type=type_hints["field_path"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if field_path is not None:
            self._values["field_path"] = field_path

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        """Version of the schema the FieldPath is written in terms of, defaults to 'v1'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        """
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def field_path(self) -> typing.Optional[builtins.str]:
        """Path of the field to select in the specified API version.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        result = self._values.get("field_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b352a7f8f7729ad64ed2f73c0070a4b36ed767743d3dc7219b5b3c3ded6c4335
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetApiVersion")
    def reset_api_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiVersion", []))

    @jsii.member(jsii_name="resetFieldPath")
    def reset_field_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFieldPath", []))

    @builtins.property
    @jsii.member(jsii_name="apiVersionInput")
    def api_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "apiVersionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fieldPathInput")
    def field_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "fieldPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiVersion")
    def api_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiVersion"))

    @api_version.setter
    def api_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__52fb84b42397e7715d924f0ea7dde17a2a13596facff893a904e64ad30701b62
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiVersion", value)

    @builtins.property
    @jsii.member(jsii_name="fieldPath")
    def field_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fieldPath"))

    @field_path.setter
    def field_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3a10fae90379d4f6c3b53d0c48dbf7d42b3f8f5c25943b85bfc24d5a83c4e46d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fieldPath", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8d438a22377facc013d9c02a6ef4a99e31d59dfcb506bfbc3215c4279236ac15
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3b3302e9e6587ae5798b76ba81d44c5e117297ec5baf40b667d1f39339e710c2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__05c349fe11d80715a33914e72401bf03bc2a6526d7e23181dca2fb6a7ec4a523
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__23f264debb863af8824d6e421e99c2546cc2f4fd1fe061b845cb2723845d01b7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__30b38e21b4e682a70c4356736eccf300e573fb76db03f0174916d3f35b372767
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e6aa69140b8b83158191f121b970bcd6813b6945c3be908f80a2372e8b697456
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d5cb35a0a1723294fe0b83ae1aac962e35c34ff367591eec393a5f4d92e7c795
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c96dedd0bc38f0de08370eafb5d7bbf5b21c825198e1db21404a60f1ff8335c3
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putFieldRef")
    def put_field_ref(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        field_path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_version: Version of the schema the FieldPath is written in terms of, defaults to 'v1'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#api_version DaemonSetV1#api_version}
        :param field_path: Path of the field to select in the specified API version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#field_path DaemonSetV1#field_path}
        """
        value = (
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef(
                api_version=api_version, field_path=field_path
            )
        )

        return typing.cast(None, jsii.invoke(self, "putFieldRef", [value]))

    @jsii.member(jsii_name="putResourceFieldRef")
    def put_resource_field_ref(
        self,
        *,
        container_name: builtins.str,
        resource: builtins.str,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        value = DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef(
            container_name=container_name, resource=resource, divisor=divisor
        )

        return typing.cast(None, jsii.invoke(self, "putResourceFieldRef", [value]))

    @jsii.member(jsii_name="resetFieldRef")
    def reset_field_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFieldRef", []))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetResourceFieldRef")
    def reset_resource_field_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceFieldRef", []))

    @builtins.property
    @jsii.member(jsii_name="fieldRef")
    def field_ref(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRefOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRefOutputReference,
            jsii.get(self, "fieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRef")
    def resource_field_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRefOutputReference",
            jsii.get(self, "resourceFieldRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="fieldRefInput")
    def field_ref_input(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef
            ],
            jsii.get(self, "fieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceFieldRefInput")
    def resource_field_ref_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef"
            ],
            jsii.get(self, "resourceFieldRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__207a3da03ff45ad5f082360006c4d493c419bf321323b843fc26d7f1c76e4f60
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mode", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__df1bae3707066ed2d8f9fd1d663da8e1265d36724beba9ed0f8eb0099b92a944
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9d2de8fb4dd478832cf12066b3c438d4cc8316eb12096402c87bbf9eaa5ba664
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "container_name": "containerName",
        "resource": "resource",
        "divisor": "divisor",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef:
    def __init__(
        self,
        *,
        container_name: builtins.str,
        resource: builtins.str,
        divisor: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param container_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}.
        :param resource: Resource to select. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        :param divisor: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5e68da8e03916be7608164e0d9a21aab19573448b6efb1071d40cad6825dfbec
            )
            check_type(
                argname="argument container_name",
                value=container_name,
                expected_type=type_hints["container_name"],
            )
            check_type(
                argname="argument resource",
                value=resource,
                expected_type=type_hints["resource"],
            )
            check_type(
                argname="argument divisor",
                value=divisor,
                expected_type=type_hints["divisor"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_name": container_name,
            "resource": resource,
        }
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def container_name(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#container_name DaemonSetV1#container_name}."""
        result = self._values.get("container_name")
        assert result is not None, "Required property 'container_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource(self) -> builtins.str:
        """Resource to select.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#resource DaemonSetV1#resource}
        """
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def divisor(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#divisor DaemonSetV1#divisor}."""
        result = self._values.get("divisor")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__96b7982f896a3c6fdf9006e31a7702bac896549859e7e25923988a5d26bfbd0d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDivisor")
    def reset_divisor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDivisor", []))

    @builtins.property
    @jsii.member(jsii_name="containerNameInput")
    def container_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "containerNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="divisorInput")
    def divisor_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "divisorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="resourceInput")
    def resource_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "resourceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="containerName")
    def container_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerName"))

    @container_name.setter
    def container_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd8b0ec39204d21c293cee16a042f7d1183c739f4d7985569b55429caafbd442
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "containerName", value)

    @builtins.property
    @jsii.member(jsii_name="divisor")
    def divisor(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "divisor"))

    @divisor.setter
    def divisor(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d99aa81a0dde6812e73cc2dbcc3872399f7c68ca8bf6e38eccb1f6dd239e2c5f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "divisor", value)

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resource"))

    @resource.setter
    def resource(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6dc4f11af6fce6242c0210ff69cb71e5531f420defd34a16e4ca284b583d2072
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "resource", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5f4e373af9cbde9f611de5c6332b67d4756e5fb042b3beb14c89c04ffe44b534
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__33593d67a55fe594e4b7f2ccb74843b23d2f9cb5ea9c304c413d2d214048fca2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putItems")
    def put_items(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__00de0b95b0e4149906770cf508481285ad4998795b8f7f043a778f11d849158d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putItems", [value]))

    @jsii.member(jsii_name="resetItems")
    def reset_items(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetItems", []))

    @builtins.property
    @jsii.member(jsii_name="items")
    def items(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsList,
            jsii.get(self, "items"),
        )

    @builtins.property
    @jsii.member(jsii_name="itemsInput")
    def items_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems
            ],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems
                    ],
                ]
            ],
            jsii.get(self, "itemsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6f27bc4cba12b842416af17bac8265a0e6741a1f841f89d4aba74a784b7a72b8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1257e6c0ae9edd0b32b0bca3955598121f61ada0a15f9b75082f995c56e16d57
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cd68e6068662bb418bfdf7e9ce3704e3cdf1892ef642a23c87aaade1a5140681
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aa9ce3f04fc14289d78d327b47919be996154d91c62d5a4d15abf31d1b72c6cc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__483c8d70bcdcbbb600c7ca39d833a32b2c2bca021f2e51cb25d9af30af04f119
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__16e50a5e99531c06d749401423e8626922531d15afd3aab6997bb1e71b809815
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSources],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSources],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSources],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8d0c2e133680e9b19ebabc1913fb0395484462acb6aa1bb8dbc660af556a24c3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e67371597bb69d9f6c241cb5ff44f5957d3e0a062c0aa9292527182d58ee561b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putConfigMap")
    def put_config_map(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f1ce44d02b1a34eee5f397a63496e7b517d2c4d6879390bef86dac348b3300bd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putConfigMap", [value]))

    @jsii.member(jsii_name="putDownwardApi")
    def put_downward_api(
        self,
        *,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi(
            items=items
        )

        return typing.cast(None, jsii.invoke(self, "putDownwardApi", [value]))

    @jsii.member(jsii_name="putSecret")
    def put_secret(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret",
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4358a70949fbbf7f3593e052c95e17868a11eacb5167254db9b4e58c56958fdc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putSecret", [value]))

    @jsii.member(jsii_name="putServiceAccountToken")
    def put_service_account_token(
        self,
        *,
        path: builtins.str,
        audience: typing.Optional[builtins.str] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param path: Path specifies a relative path to the mount point of the projected volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param audience: Audience is the intended audience of the token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#audience DaemonSetV1#audience}
        :param expiration_seconds: ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#expiration_seconds DaemonSetV1#expiration_seconds}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken(
            path=path, audience=audience, expiration_seconds=expiration_seconds
        )

        return typing.cast(None, jsii.invoke(self, "putServiceAccountToken", [value]))

    @jsii.member(jsii_name="resetConfigMap")
    def reset_config_map(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigMap", []))

    @jsii.member(jsii_name="resetDownwardApi")
    def reset_downward_api(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDownwardApi", []))

    @jsii.member(jsii_name="resetSecret")
    def reset_secret(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecret", []))

    @jsii.member(jsii_name="resetServiceAccountToken")
    def reset_service_account_token(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceAccountToken", []))

    @builtins.property
    @jsii.member(jsii_name="configMap")
    def config_map(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapList,
            jsii.get(self, "configMap"),
        )

    @builtins.property
    @jsii.member(jsii_name="downwardApi")
    def downward_api(
        self,
    ) -> DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiOutputReference:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiOutputReference,
            jsii.get(self, "downwardApi"),
        )

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretList":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretList",
            jsii.get(self, "secret"),
        )

    @builtins.property
    @jsii.member(jsii_name="serviceAccountToken")
    def service_account_token(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountTokenOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountTokenOutputReference",
            jsii.get(self, "serviceAccountToken"),
        )

    @builtins.property
    @jsii.member(jsii_name="configMapInput")
    def config_map_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap
                    ],
                ]
            ],
            jsii.get(self, "configMapInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="downwardApiInput")
    def downward_api_input(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi
            ],
            jsii.get(self, "downwardApiInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretInput")
    def secret_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret"],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret"
                    ],
                ]
            ],
            jsii.get(self, "secretInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="serviceAccountTokenInput")
    def service_account_token_input(
        self,
    ) -> typing.Optional[
        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken"
    ]:
        return typing.cast(
            typing.Optional[
                "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken"
            ],
            jsii.get(self, "serviceAccountTokenInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSources,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSources,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeProjectedSources,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__875f727a3648b56f6e0f31a0f16c15d03c9d1831ee40610ade0ff81dbe5e18b5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name", "optional": "optional"},
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret:
    def __init__(
        self,
        *,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        :param name: Name of the secret in the pod's namespace to use. More info: http://kubernetes.io/docs/user-guide/volumes#secrets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param optional: Optional: Specify whether the Secret or it's keys must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6db7ebab488dae186540ae1b6b7b0abc0368907d632a40e9ee1a5df4d4a84bd1
            )
            check_type(
                argname="argument items", value=items, expected_type=type_hints["items"]
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems"],
        ]
    ]:
        """items block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        result = self._values.get("items")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems"
                    ],
                ]
            ],
            result,
        )

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the secret in the pod's namespace to use. More info: http://kubernetes.io/docs/user-guide/volumes#secrets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Optional: Specify whether the Secret or it's keys must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "mode": "mode", "path": "path"},
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The key to project. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        :param path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2d42af02d4208c3c730ac66b2e4557099a5c903a4204cb09b5da4f2a5ef26da
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument mode", value=mode, expected_type=type_hints["mode"]
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if mode is not None:
            self._values["mode"] = mode
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key to project.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on this file, must be a value between 0 and 0777.

        If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        """
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """The relative path of the file to map the key to.

        May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ee68c3308baf76e8ae3535e949bfcc90a6eddbac06776ec7547dc108ef494ff6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ad4d3d56cbf7cc46f88388888df351b24ab825fa4ef1cb187fd1c8d9a01d8406
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b6f4b60106733a59840dcc867176a9a2b51dd109527302a9dd844b52d849936f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__518b49cf42ae9271f74bd5041deb4ec72f6d3614bfe86eb69f98355dcdb244f1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c7112b557ab09a6514917b1f58f02fd59619365f6b1bdbe245d74702e7247e8b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems
                ],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d533713d522256900042cd44092bc9723e634a6a9f1f4e0a449e5bddb22cee04
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f44368f64835a4481b5afbb2ced5c4b403fe660761143dc800bd7960a436878e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d8ff6fcd85158347a675c7b0fc38b73202f59e68a7a22e7983894c84e17911c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d77466ba96769b4d8093c2137fe5756fa62acfb773474befec5a666d9a1b90d4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mode", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__55c768c72bf2ec6fe10d354f1082b9dd1ec5edd689ddc3d359b4839c77dfd575
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f5af92c944f949f22f53c83613865992225cc72cf6dd17173331505ee8c05245
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e68a1fc054ccb51530d78d87df40867ff4572e2706aaf36cc5cff8f41e081f85
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__787083a5c64e5805c8758eee281f0c81f72405bddfea80f79c21ce77f5848e0b
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5c54be15f6480a61352e59ba927df494586bd8a1145526f4e164c286441319b1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e631c4e0026e8f637b9c279437ac55db2a7f6a5a9b414c639db71686da8200aa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__01a991c6be56d512b6bdcb9efaac21fbbf3138d03586781b66a21499b593bcc8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret
                    ],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9dc7cc07aa327a46bb6deec218d743a06b74f3906015e4a66b195b6936063ced
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__81bb5c415549e34b2fc7ee837cd37ad6b5dd718cbe4840046dbbd6ea5a2c07bd
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putItems")
    def put_items(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4ce453ab111b09ffacda3c20550f1ff58bfb2be887b2de9f9753af94d6946a97
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putItems", [value]))

    @jsii.member(jsii_name="resetItems")
    def reset_items(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetItems", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @builtins.property
    @jsii.member(jsii_name="items")
    def items(self) -> DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsList,
            jsii.get(self, "items"),
        )

    @builtins.property
    @jsii.member(jsii_name="itemsInput")
    def items_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[
                        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems
                    ],
                ]
            ],
            jsii.get(self, "itemsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__389e8243bb9045ffe33a59164dc6999e77ab20e4ca47af1f8180f90e4c72d481
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__baf02f1be4ee850790b9a0ce8927cd1bb940be6d3915168d83a9f9eed596b537
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret,
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__80e54cc4d26c61814d86e87af7ec18616778fa45506fca75232b9c76a4620414
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "audience": "audience",
        "expiration_seconds": "expirationSeconds",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken:
    def __init__(
        self,
        *,
        path: builtins.str,
        audience: typing.Optional[builtins.str] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param path: Path specifies a relative path to the mount point of the projected volume. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        :param audience: Audience is the intended audience of the token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#audience DaemonSetV1#audience}
        :param expiration_seconds: ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#expiration_seconds DaemonSetV1#expiration_seconds}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97880a4766f0c2fddf1ae3fd7875b153d90a2ffc5d36dd5494ea71f84487779f
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument audience",
                value=audience,
                expected_type=type_hints["audience"],
            )
            check_type(
                argname="argument expiration_seconds",
                value=expiration_seconds,
                expected_type=type_hints["expiration_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
        }
        if audience is not None:
            self._values["audience"] = audience
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def path(self) -> builtins.str:
        """Path specifies a relative path to the mount point of the projected volume.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audience(self) -> typing.Optional[builtins.str]:
        """Audience is the intended audience of the token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#audience DaemonSetV1#audience}
        """
        result = self._values.get("audience")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        """ExpirationSeconds is the expected duration of validity of the service account token.

        It defaults to 1 hour and must be at least 10 minutes (600 seconds).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#expiration_seconds DaemonSetV1#expiration_seconds}
        """
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return (
            "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken(%s)"
            % ", ".join(k + "=" + repr(v) for k, v in self._values.items())
        )


class DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountTokenOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountTokenOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4debc9c96efa48f8037246980f7dbdc54c708dd35b112e06a99f5c71a3a5a1c8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAudience")
    def reset_audience(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAudience", []))

    @jsii.member(jsii_name="resetExpirationSeconds")
    def reset_expiration_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExpirationSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="audienceInput")
    def audience_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "audienceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="expirationSecondsInput")
    def expiration_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "expirationSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="audience")
    def audience(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "audience"))

    @audience.setter
    def audience(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__44659592ec45c984d6da3a13549949c43bf9970ce27dffb57c1b794762e5e388
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "audience", value)

    @builtins.property
    @jsii.member(jsii_name="expirationSeconds")
    def expiration_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "expirationSeconds"))

    @expiration_seconds.setter
    def expiration_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b33cd14212f6ae51452e731f60f3dc10d1e67ae90c4a9874cd5955f2301db50
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "expirationSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5f15f2c913bf84497afefd822112be0b50f7153b5242a679a4b26db52bdfbd3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken
    ]:
        return typing.cast(
            typing.Optional[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3abd6b23d1ded109c138836aaeebced5961097518af69f80654bbd08e6f142e1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeQuobyte",
    jsii_struct_bases=[],
    name_mapping={
        "registry": "registry",
        "volume": "volume",
        "group": "group",
        "read_only": "readOnly",
        "user": "user",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeQuobyte:
    def __init__(
        self,
        *,
        registry: builtins.str,
        volume: builtins.str,
        group: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry: Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#registry DaemonSetV1#registry}
        :param volume: Volume is a string that references an already created Quobyte volume by name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume DaemonSetV1#volume}
        :param group: Group to map volume access to Default is no group. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#group DaemonSetV1#group}
        :param read_only: Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param user: User to map volume access to Defaults to serivceaccount user. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__26727233098ca75f2f12b7a09549514b46dd22909591132d082083417b4f49d5
            )
            check_type(
                argname="argument registry",
                value=registry,
                expected_type=type_hints["registry"],
            )
            check_type(
                argname="argument volume",
                value=volume,
                expected_type=type_hints["volume"],
            )
            check_type(
                argname="argument group", value=group, expected_type=type_hints["group"]
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument user", value=user, expected_type=type_hints["user"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "registry": registry,
            "volume": volume,
        }
        if group is not None:
            self._values["group"] = group
        if read_only is not None:
            self._values["read_only"] = read_only
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def registry(self) -> builtins.str:
        """Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#registry DaemonSetV1#registry}
        """
        result = self._values.get("registry")
        assert result is not None, "Required property 'registry' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def volume(self) -> builtins.str:
        """Volume is a string that references an already created Quobyte volume by name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume DaemonSetV1#volume}
        """
        result = self._values.get("volume")
        assert result is not None, "Required property 'volume' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        """Group to map volume access to Default is no group.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#group DaemonSetV1#group}
        """
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        """User to map volume access to Defaults to serivceaccount user.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#user DaemonSetV1#user}
        """
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeQuobyte(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeQuobyteOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeQuobyteOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e529fc724348fa54e7b4bceca1cd3800cf458178de01cc851b89b5f4a6f73e63
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetGroup")
    def reset_group(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGroup", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="groupInput")
    def group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "groupInput"))

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="registryInput")
    def registry_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "registryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="volumeInput")
    def volume_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "volumeInput"))

    @builtins.property
    @jsii.member(jsii_name="group")
    def group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "group"))

    @group.setter
    def group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a033c182d17f8b479b108b81ea3cc801e37bc94a3a9f30273b01dcf64c8c3464
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "group", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf3622f56a2b87d321141393dce11e061f7a3bede29313a7080d0d4cd6484544
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="registry")
    def registry(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registry"))

    @registry.setter
    def registry(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8f5998605e15d229389d7c963fde30e83e1e4c67d8c90284bbea9b96ab1aafcd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "registry", value)

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4fb2ed812f30d069a089c6cea39a07487888bf2a4f4368677a3429a8cd75895d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "user", value)

    @builtins.property
    @jsii.member(jsii_name="volume")
    def volume(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "volume"))

    @volume.setter
    def volume(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0064c2f43509d09e1bf4021a01a9fa822b11d0ffd3dd3426de08ee0b03e264f0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "volume", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeQuobyte]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeQuobyte],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeQuobyte],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4e01c090dded1b117d6b805e9a4ef4cd6874a9ebb853bfa6dcd0eb1ba6a29e49
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeRbd",
    jsii_struct_bases=[],
    name_mapping={
        "ceph_monitors": "cephMonitors",
        "rbd_image": "rbdImage",
        "fs_type": "fsType",
        "keyring": "keyring",
        "rados_user": "radosUser",
        "rbd_pool": "rbdPool",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeRbd:
    def __init__(
        self,
        *,
        ceph_monitors: typing.Sequence[builtins.str],
        rbd_image: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        keyring: typing.Optional[builtins.str] = None,
        rados_user: typing.Optional[builtins.str] = None,
        rbd_pool: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_ref: typing.Optional[
            typing.Union[
                "DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param ceph_monitors: A collection of Ceph monitors. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#ceph_monitors DaemonSetV1#ceph_monitors}
        :param rbd_image: The rados image name. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd_image DaemonSetV1#rbd_image}
        :param fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#rbd Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        :param keyring: Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#keyring DaemonSetV1#keyring}
        :param rados_user: The rados user name. Default is admin. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rados_user DaemonSetV1#rados_user}
        :param rbd_pool: The rados pool name. Default is rbd. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd_pool DaemonSetV1#rbd_pool}
        :param read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        :param secret_ref: secret_ref block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        if isinstance(secret_ref, dict):
            secret_ref = DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca8b5c4e47ba0f1bd062f50e9713388ea848b6c605124e87330588daba551b5a
            )
            check_type(
                argname="argument ceph_monitors",
                value=ceph_monitors,
                expected_type=type_hints["ceph_monitors"],
            )
            check_type(
                argname="argument rbd_image",
                value=rbd_image,
                expected_type=type_hints["rbd_image"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
            check_type(
                argname="argument keyring",
                value=keyring,
                expected_type=type_hints["keyring"],
            )
            check_type(
                argname="argument rados_user",
                value=rados_user,
                expected_type=type_hints["rados_user"],
            )
            check_type(
                argname="argument rbd_pool",
                value=rbd_pool,
                expected_type=type_hints["rbd_pool"],
            )
            check_type(
                argname="argument read_only",
                value=read_only,
                expected_type=type_hints["read_only"],
            )
            check_type(
                argname="argument secret_ref",
                value=secret_ref,
                expected_type=type_hints["secret_ref"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ceph_monitors": ceph_monitors,
            "rbd_image": rbd_image,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if keyring is not None:
            self._values["keyring"] = keyring
        if rados_user is not None:
            self._values["rados_user"] = rados_user
        if rbd_pool is not None:
            self._values["rbd_pool"] = rbd_pool
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def ceph_monitors(self) -> typing.List[builtins.str]:
        """A collection of Ceph monitors. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#ceph_monitors DaemonSetV1#ceph_monitors}
        """
        result = self._values.get("ceph_monitors")
        assert result is not None, "Required property 'ceph_monitors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def rbd_image(self) -> builtins.str:
        """The rados image name. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd_image DaemonSetV1#rbd_image}
        """
        result = self._values.get("rbd_image")
        assert result is not None, "Required property 'rbd_image' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type of the volume that you want to mount.

        Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: http://kubernetes.io/docs/user-guide/volumes#rbd

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def keyring(self) -> typing.Optional[builtins.str]:
        """Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#keyring DaemonSetV1#keyring}
        """
        result = self._values.get("keyring")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rados_user(self) -> typing.Optional[builtins.str]:
        """The rados user name. Default is admin. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rados_user DaemonSetV1#rados_user}
        """
        result = self._values.get("rados_user")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rbd_pool(self) -> typing.Optional[builtins.str]:
        """The rados pool name. Default is rbd. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#rbd_pool DaemonSetV1#rbd_pool}
        """
        result = self._values.get("rbd_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#read_only DaemonSetV1#read_only}
        """
        result = self._values.get("read_only")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef"]:
        """secret_ref block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_ref DaemonSetV1#secret_ref}
        """
        result = self._values.get("secret_ref")
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef"], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeRbd(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeRbdOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeRbdOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c92692d0378b73673b9c3efd1147f44e868db8beae54c1aec02685bbda53fb36
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSecretRef")
    def put_secret_ref(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        value = DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef(
            name=name, namespace=namespace
        )

        return typing.cast(None, jsii.invoke(self, "putSecretRef", [value]))

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @jsii.member(jsii_name="resetKeyring")
    def reset_keyring(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyring", []))

    @jsii.member(jsii_name="resetRadosUser")
    def reset_rados_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRadosUser", []))

    @jsii.member(jsii_name="resetRbdPool")
    def reset_rbd_pool(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRbdPool", []))

    @jsii.member(jsii_name="resetReadOnly")
    def reset_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadOnly", []))

    @jsii.member(jsii_name="resetSecretRef")
    def reset_secret_ref(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretRef", []))

    @builtins.property
    @jsii.member(jsii_name="secretRef")
    def secret_ref(
        self,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeRbdSecretRefOutputReference":
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeRbdSecretRefOutputReference",
            jsii.get(self, "secretRef"),
        )

    @builtins.property
    @jsii.member(jsii_name="cephMonitorsInput")
    def ceph_monitors_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "cephMonitorsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="keyringInput")
    def keyring_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "keyringInput")
        )

    @builtins.property
    @jsii.member(jsii_name="radosUserInput")
    def rados_user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "radosUserInput")
        )

    @builtins.property
    @jsii.member(jsii_name="rbdImageInput")
    def rbd_image_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "rbdImageInput")
        )

    @builtins.property
    @jsii.member(jsii_name="rbdPoolInput")
    def rbd_pool_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "rbdPoolInput")
        )

    @builtins.property
    @jsii.member(jsii_name="readOnlyInput")
    def read_only_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "readOnlyInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretRefInput")
    def secret_ref_input(
        self,
    ) -> typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef"]:
        return typing.cast(
            typing.Optional["DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef"],
            jsii.get(self, "secretRefInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="cephMonitors")
    def ceph_monitors(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "cephMonitors"))

    @ceph_monitors.setter
    def ceph_monitors(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__221a2f71f7ca1ebe0c9a7c98baf5f9a89664f08fbd308fced67229a1f5abc338
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "cephMonitors", value)

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5fbcd99f7c5b94187615a42f6da70ad9a87426b1316a2d0db80079f858c1122f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="keyring")
    def keyring(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyring"))

    @keyring.setter
    def keyring(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c43de932f67fecc82f9fd18f2d3b2a3ad7cc620fed124dacd1bf1413cf01a87c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "keyring", value)

    @builtins.property
    @jsii.member(jsii_name="radosUser")
    def rados_user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "radosUser"))

    @rados_user.setter
    def rados_user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b3c581de1bba0eb6a2f52a0c1931131572e709174241a77ab03dc316d2b239d0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "radosUser", value)

    @builtins.property
    @jsii.member(jsii_name="rbdImage")
    def rbd_image(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rbdImage"))

    @rbd_image.setter
    def rbd_image(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__535b77b976772e16dede34af85fc4d9598a3e6511d8bffc98880c33c27eee8c3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "rbdImage", value)

    @builtins.property
    @jsii.member(jsii_name="rbdPool")
    def rbd_pool(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rbdPool"))

    @rbd_pool.setter
    def rbd_pool(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__adf704068e0ddd4fdd597ef527dde1a710f63b25df77543166a7ca9c8ff19715
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "rbdPool", value)

    @builtins.property
    @jsii.member(jsii_name="readOnly")
    def read_only(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "readOnly"),
        )

    @read_only.setter
    def read_only(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c4b7e09592d51a978262d2e1d37f122475edb199a8dd21a94820d4fb1edd4321
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "readOnly", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbd]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbd],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbd],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c647a0ed5409c692a787f540cf64ace1666329aa4cdbb5c364cd423e6fb0ec8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "namespace": "namespace"},
)
class DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        :param namespace: Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7676a0290165eca32d17ad4a73f5153238fd10bdb6ab2fa058536fdd9495817e
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument namespace",
                value=namespace,
                expected_type=type_hints["namespace"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#name DaemonSetV1#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        """Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#namespace DaemonSetV1#namespace}
        """
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeRbdSecretRefOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeRbdSecretRefOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0eca9fa0d2892a5af8bfad68c206ecdfe2309b26e3f7084f51211b51f89aa4ef
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetNamespace")
    def reset_namespace(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamespace", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="namespaceInput")
    def namespace_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "namespaceInput")
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__03210f4501f18b4b48ad178cd23d9953e4a4ff5fefa1ee6ea14f3e7a0026967d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @namespace.setter
    def namespace(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__546076714850c9ec82163b9348f9cd7b0c5bd1f515f3a5593c083402eb112ed0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "namespace", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b7a5a9f38f4150a95febeb344f6aee7e57649f86beea4f0b14ce15d4d74fa082
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeSecret",
    jsii_struct_bases=[],
    name_mapping={
        "default_mode": "defaultMode",
        "items": "items",
        "optional": "optional",
        "secret_name": "secretName",
    },
)
class DaemonSetV1SpecTemplateSpecVolumeSecret:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[builtins.str] = None,
        items: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "DaemonSetV1SpecTemplateSpecVolumeSecretItems",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        optional: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        :param items: items block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        :param optional: Optional: Specify whether the Secret or its keys must be defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        :param secret_name: Name of the secret in the pod's namespace to use. More info: http://kubernetes.io/docs/user-guide/volumes#secrets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_name DaemonSetV1#secret_name}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__eca1a4cba00976a4190cc3a797fd609484c6e506aa8cdb0d6605ef8209b9edc5
            )
            check_type(
                argname="argument default_mode",
                value=default_mode,
                expected_type=type_hints["default_mode"],
            )
            check_type(
                argname="argument items", value=items, expected_type=type_hints["items"]
            )
            check_type(
                argname="argument optional",
                value=optional,
                expected_type=type_hints["optional"],
            )
            check_type(
                argname="argument secret_name",
                value=secret_name,
                expected_type=type_hints["secret_name"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items
        if optional is not None:
            self._values["optional"] = optional
        if secret_name is not None:
            self._values["secret_name"] = secret_name

    @builtins.property
    def default_mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on created files by default.

        Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#default_mode DaemonSetV1#default_mode}
        """
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List["DaemonSetV1SpecTemplateSpecVolumeSecretItems"],
        ]
    ]:
        """items block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#items DaemonSetV1#items}
        """
        result = self._values.get("items")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["DaemonSetV1SpecTemplateSpecVolumeSecretItems"],
                ]
            ],
            result,
        )

    @builtins.property
    def optional(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Optional: Specify whether the Secret or its keys must be defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#optional DaemonSetV1#optional}
        """
        result = self._values.get("optional")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        """Name of the secret in the pod's namespace to use. More info: http://kubernetes.io/docs/user-guide/volumes#secrets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#secret_name DaemonSetV1#secret_name}
        """
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "mode": "mode", "path": "path"},
)
class DaemonSetV1SpecTemplateSpecVolumeSecretItems:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The key to project. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        :param mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        :param path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a294365d9b2b72725ff248ece0cd737fdd430c11f14fc9301559d84fb3ffb847
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument mode", value=mode, expected_type=type_hints["mode"]
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if mode is not None:
            self._values["mode"] = mode
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The key to project.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#key DaemonSetV1#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        """Optional: mode bits to use on this file, must be a value between 0 and 0777.

        If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#mode DaemonSetV1#mode}
        """
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """The relative path of the file to map the key to.

        May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#path DaemonSetV1#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeSecretItemsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeSecretItemsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f488d83b392fa45ca280db205ba20fe0b698cc95c5d5e2b87c169e0e6b1081df
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "DaemonSetV1SpecTemplateSpecVolumeSecretItemsOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85552faff57dd5306d2000b4181822845970c96635356c4ef29433d5b7cbb50c
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "DaemonSetV1SpecTemplateSpecVolumeSecretItemsOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__65074ecbe53a7f9dad0d78ed0fd2e61076b5a74e39662455c322b93fe8810635
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__687f9cbfb679fae60badd2403a3bab0283542924cc7ebca9fa36301f1c5fa145
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ff6a506376a5a5b704c28ed98764acdf6044eb16ad4638b9de6ac67bce67006e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeSecretItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeSecretItems],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[DaemonSetV1SpecTemplateSpecVolumeSecretItems],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f259aa666fa22e10b33d01cb3c31ab9c4b334b41105ecb8a23bd77d1c6f4c42
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeSecretItemsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeSecretItemsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5b58b98352a4fec47c785a2ddba7775d5e156a0056088a4f5e26c25735ad6f93
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__035dea3833d4b2e6197a643f1b8b3ae5ec6be994efdfce5c57fa7ba2405d7d1f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9d9fcf2afc2b5bfeb80b8dea69ca6c26fce43eb9cd390e7e74b2a10ef02ac810
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "mode", value)

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0715cc8a38577e27ca54fb791801f4681f0fffd3ef4df3bda57d866b9a17b242
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolumeSecretItems
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    DaemonSetV1SpecTemplateSpecVolumeSecretItems,
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                DaemonSetV1SpecTemplateSpecVolumeSecretItems,
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e76c847434a6a545745b9fa98e93cda79783331e3260990667edb5bb7ebed74b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class DaemonSetV1SpecTemplateSpecVolumeSecretOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeSecretOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6671069d749cac03986878a64150d6cdd53d4a09b1a95b525d3b16ba83ca53c5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putItems")
    def put_items(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeSecretItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a9d5a7f9ba240aaedd86a482a9c93b43f7e0ef247c3b37da7ec064d228860652
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putItems", [value]))

    @jsii.member(jsii_name="resetDefaultMode")
    def reset_default_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultMode", []))

    @jsii.member(jsii_name="resetItems")
    def reset_items(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetItems", []))

    @jsii.member(jsii_name="resetOptional")
    def reset_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptional", []))

    @jsii.member(jsii_name="resetSecretName")
    def reset_secret_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretName", []))

    @builtins.property
    @jsii.member(jsii_name="items")
    def items(self) -> DaemonSetV1SpecTemplateSpecVolumeSecretItemsList:
        return typing.cast(
            DaemonSetV1SpecTemplateSpecVolumeSecretItemsList, jsii.get(self, "items")
        )

    @builtins.property
    @jsii.member(jsii_name="defaultModeInput")
    def default_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "defaultModeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="itemsInput")
    def items_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeSecretItems],
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[DaemonSetV1SpecTemplateSpecVolumeSecretItems],
                ]
            ],
            jsii.get(self, "itemsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="optionalInput")
    def optional_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "optionalInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="secretNameInput")
    def secret_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "secretNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="defaultMode")
    def default_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "defaultMode"))

    @default_mode.setter
    def default_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b6eb35c556d23b12653a48457924d39cb86933d7c3c78ac20726552f758454aa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "defaultMode", value)

    @builtins.property
    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "optional"),
        )

    @optional.setter
    def optional(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e60854e71453cd7268cf32f9dcfa9e2a6d8d6c546a484be76a8d017c4cdf28e4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "optional", value)

    @builtins.property
    @jsii.member(jsii_name="secretName")
    def secret_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretName"))

    @secret_name.setter
    def secret_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f51441999e612da87be352d9cfeb2d94f84fe101e5c286a5cba4a4274c1b1ce8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "secretName", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeSecret]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeSecret],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeSecret],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c99042d4fd3eb1ab31aa21f8b013e6b797dfe23d13c6961c866390c70071aca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeVsphereVolume",
    jsii_struct_bases=[],
    name_mapping={"volume_path": "volumePath", "fs_type": "fsType"},
)
class DaemonSetV1SpecTemplateSpecVolumeVsphereVolume:
    def __init__(
        self,
        *,
        volume_path: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param volume_path: Path that identifies vSphere volume vmdk. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_path DaemonSetV1#volume_path}
        :param fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cdbc30f131f8a43de9f7ed293c0fb23c5f79e800f8762e284bd71b2b1ab685dd
            )
            check_type(
                argname="argument volume_path",
                value=volume_path,
                expected_type=type_hints["volume_path"],
            )
            check_type(
                argname="argument fs_type",
                value=fs_type,
                expected_type=type_hints["fs_type"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "volume_path": volume_path,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type

    @builtins.property
    def volume_path(self) -> builtins.str:
        """Path that identifies vSphere volume vmdk.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#volume_path DaemonSetV1#volume_path}
        """
        result = self._values.get("volume_path")
        assert result is not None, "Required property 'volume_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        """Filesystem type to mount.

        Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#fs_type DaemonSetV1#fs_type}
        """
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1SpecTemplateSpecVolumeVsphereVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1SpecTemplateSpecVolumeVsphereVolumeOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1SpecTemplateSpecVolumeVsphereVolumeOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__21f603c082b4fdee6c425fb2b782b35cfe19156a439cb371f5649f8e4232e8af
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFsType")
    def reset_fs_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFsType", []))

    @builtins.property
    @jsii.member(jsii_name="fsTypeInput")
    def fs_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fsTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="volumePathInput")
    def volume_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "volumePathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="fsType")
    def fs_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fsType"))

    @fs_type.setter
    def fs_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1eb424c9dda06f6100c97b36febfa85d285b65e0972f3a7aa8b9563fc22b80c2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "fsType", value)

    @builtins.property
    @jsii.member(jsii_name="volumePath")
    def volume_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "volumePath"))

    @volume_path.setter
    def volume_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d47e2516b385eee515075ccce0cc1daa311efef9c87e77158a0c3bcded0b0339
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "volumePath", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[DaemonSetV1SpecTemplateSpecVolumeVsphereVolume]:
        return typing.cast(
            typing.Optional[DaemonSetV1SpecTemplateSpecVolumeVsphereVolume],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeVsphereVolume],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2c97715d86f3c183507fd509797240391162961be887ab5aec6dafd451d5f40d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1Timeouts",
    jsii_struct_bases=[],
    name_mapping={"create": "create", "delete": "delete", "update": "update"},
)
class DaemonSetV1Timeouts:
    def __init__(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#create DaemonSetV1#create}.
        :param delete: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#delete DaemonSetV1#delete}.
        :param update: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#update DaemonSetV1#update}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3a42648b0b19c759f909aaacfa3b87095e6fadbfea265c9382efb9191e0aaea7
            )
            check_type(
                argname="argument create",
                value=create,
                expected_type=type_hints["create"],
            )
            check_type(
                argname="argument delete",
                value=delete,
                expected_type=type_hints["delete"],
            )
            check_type(
                argname="argument update",
                value=update,
                expected_type=type_hints["update"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if create is not None:
            self._values["create"] = create
        if delete is not None:
            self._values["delete"] = delete
        if update is not None:
            self._values["update"] = update

    @builtins.property
    def create(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#create DaemonSetV1#create}."""
        result = self._values.get("create")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delete(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#delete DaemonSetV1#delete}."""
        result = self._values.get("delete")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/kubernetes/2.21.0/docs/resources/daemon_set_v1#update DaemonSetV1#update}."""
        result = self._values.get("update")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaemonSetV1Timeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DaemonSetV1TimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="kubernetes.daemonSetV1.DaemonSetV1TimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f1251d9c4b61a19dcafb6b4c2f15a1528f16396a8056643510e2b27d05df696d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCreate")
    def reset_create(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreate", []))

    @jsii.member(jsii_name="resetDelete")
    def reset_delete(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelete", []))

    @jsii.member(jsii_name="resetUpdate")
    def reset_update(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdate", []))

    @builtins.property
    @jsii.member(jsii_name="createInput")
    def create_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "createInput"))

    @builtins.property
    @jsii.member(jsii_name="deleteInput")
    def delete_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "deleteInput"))

    @builtins.property
    @jsii.member(jsii_name="updateInput")
    def update_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "updateInput"))

    @builtins.property
    @jsii.member(jsii_name="create")
    def create(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "create"))

    @create.setter
    def create(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2b64c73c653502faf7451eab52d863a995ff1b056499316e7d66572feb86dd1d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "create", value)

    @builtins.property
    @jsii.member(jsii_name="delete")
    def delete(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delete"))

    @delete.setter
    def delete(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__73722cc41f590ae766b82f3b2f25d66910a802f352972f6aea56c3304905110a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "delete", value)

    @builtins.property
    @jsii.member(jsii_name="update")
    def update(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "update"))

    @update.setter
    def update(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__59dac94c852952e1e458eeec35be9a70ffe33c2802b99d33a06b2ea3de5853c3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "update", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1Timeouts]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1Timeouts]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1Timeouts]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0c36f1083409d13ea3d1254c73783650ed8da43bb950f0511aab420c16fe4a2b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


__all__ = [
    "DaemonSetV1",
    "DaemonSetV1Config",
    "DaemonSetV1Metadata",
    "DaemonSetV1MetadataOutputReference",
    "DaemonSetV1Spec",
    "DaemonSetV1SpecOutputReference",
    "DaemonSetV1SpecSelector",
    "DaemonSetV1SpecSelectorMatchExpressions",
    "DaemonSetV1SpecSelectorMatchExpressionsList",
    "DaemonSetV1SpecSelectorMatchExpressionsOutputReference",
    "DaemonSetV1SpecSelectorOutputReference",
    "DaemonSetV1SpecStrategy",
    "DaemonSetV1SpecStrategyOutputReference",
    "DaemonSetV1SpecStrategyRollingUpdate",
    "DaemonSetV1SpecStrategyRollingUpdateOutputReference",
    "DaemonSetV1SpecTemplate",
    "DaemonSetV1SpecTemplateMetadata",
    "DaemonSetV1SpecTemplateMetadataOutputReference",
    "DaemonSetV1SpecTemplateOutputReference",
    "DaemonSetV1SpecTemplateSpec",
    "DaemonSetV1SpecTemplateSpecAffinity",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinity",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermList",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsList",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionsOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinity",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    "DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference",
    "DaemonSetV1SpecTemplateSpecContainer",
    "DaemonSetV1SpecTemplateSpecContainerEnv",
    "DaemonSetV1SpecTemplateSpecContainerEnvFrom",
    "DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef",
    "DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRefOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvFromList",
    "DaemonSetV1SpecTemplateSpecContainerEnvFromOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef",
    "DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRefOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvList",
    "DaemonSetV1SpecTemplateSpecContainerEnvOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFrom",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRefOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef",
    "DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRefOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecycle",
    "DaemonSetV1SpecTemplateSpecContainerLifecycleOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExecOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartList",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketList",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExecOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopList",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketList",
    "DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerList",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbe",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeExecOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcList",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpcOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketList",
    "DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerPort",
    "DaemonSetV1SpecTemplateSpecContainerPortList",
    "DaemonSetV1SpecTemplateSpecContainerPortOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbe",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeExecOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcList",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpcOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketList",
    "DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerResources",
    "DaemonSetV1SpecTemplateSpecContainerResourcesOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContext",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilitiesOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContextOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptionsOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile",
    "DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfileOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbe",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeExec",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeExecOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcList",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpcOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketList",
    "DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecContainerVolumeMount",
    "DaemonSetV1SpecTemplateSpecContainerVolumeMountList",
    "DaemonSetV1SpecTemplateSpecContainerVolumeMountOutputReference",
    "DaemonSetV1SpecTemplateSpecDnsConfig",
    "DaemonSetV1SpecTemplateSpecDnsConfigOption",
    "DaemonSetV1SpecTemplateSpecDnsConfigOptionList",
    "DaemonSetV1SpecTemplateSpecDnsConfigOptionOutputReference",
    "DaemonSetV1SpecTemplateSpecDnsConfigOutputReference",
    "DaemonSetV1SpecTemplateSpecHostAliases",
    "DaemonSetV1SpecTemplateSpecHostAliasesList",
    "DaemonSetV1SpecTemplateSpecHostAliasesOutputReference",
    "DaemonSetV1SpecTemplateSpecImagePullSecrets",
    "DaemonSetV1SpecTemplateSpecImagePullSecretsList",
    "DaemonSetV1SpecTemplateSpecImagePullSecretsOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainer",
    "DaemonSetV1SpecTemplateSpecInitContainerEnv",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvFrom",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRefOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvFromList",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvFromOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRefOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvList",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef",
    "DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRefOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecycle",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecycleOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExecOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartList",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketList",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExecOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopList",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketList",
    "DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerList",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExecOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcList",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpcOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketList",
    "DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerPort",
    "DaemonSetV1SpecTemplateSpecInitContainerPortList",
    "DaemonSetV1SpecTemplateSpecInitContainerPortOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExecOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcList",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpcOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketList",
    "DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerResources",
    "DaemonSetV1SpecTemplateSpecInitContainerResourcesOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContext",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilitiesOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile",
    "DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfileOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbe",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExecOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcList",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpcOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderList",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketList",
    "DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocketOutputReference",
    "DaemonSetV1SpecTemplateSpecInitContainerVolumeMount",
    "DaemonSetV1SpecTemplateSpecInitContainerVolumeMountList",
    "DaemonSetV1SpecTemplateSpecInitContainerVolumeMountOutputReference",
    "DaemonSetV1SpecTemplateSpecOutputReference",
    "DaemonSetV1SpecTemplateSpecReadinessGate",
    "DaemonSetV1SpecTemplateSpecReadinessGateList",
    "DaemonSetV1SpecTemplateSpecReadinessGateOutputReference",
    "DaemonSetV1SpecTemplateSpecSecurityContext",
    "DaemonSetV1SpecTemplateSpecSecurityContextOutputReference",
    "DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions",
    "DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptionsOutputReference",
    "DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile",
    "DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfileOutputReference",
    "DaemonSetV1SpecTemplateSpecSecurityContextSysctl",
    "DaemonSetV1SpecTemplateSpecSecurityContextSysctlList",
    "DaemonSetV1SpecTemplateSpecSecurityContextSysctlOutputReference",
    "DaemonSetV1SpecTemplateSpecToleration",
    "DaemonSetV1SpecTemplateSpecTolerationList",
    "DaemonSetV1SpecTemplateSpecTolerationOutputReference",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraint",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorList",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsList",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionsOutputReference",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorOutputReference",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintList",
    "DaemonSetV1SpecTemplateSpecTopologySpreadConstraintOutputReference",
    "DaemonSetV1SpecTemplateSpecVolume",
    "DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore",
    "DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStoreOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeAzureDisk",
    "DaemonSetV1SpecTemplateSpecVolumeAzureDiskOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeAzureFile",
    "DaemonSetV1SpecTemplateSpecVolumeAzureFileOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeCephFs",
    "DaemonSetV1SpecTemplateSpecVolumeCephFsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef",
    "DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeCinder",
    "DaemonSetV1SpecTemplateSpecVolumeCinderOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeConfigMap",
    "DaemonSetV1SpecTemplateSpecVolumeConfigMapItems",
    "DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsList",
    "DaemonSetV1SpecTemplateSpecVolumeConfigMapItemsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeConfigMapOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeCsi",
    "DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef",
    "DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeCsiOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApi",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsList",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeDownwardApiOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeEmptyDir",
    "DaemonSetV1SpecTemplateSpecVolumeEmptyDirOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeFc",
    "DaemonSetV1SpecTemplateSpecVolumeFcOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeFlexVolume",
    "DaemonSetV1SpecTemplateSpecVolumeFlexVolumeOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef",
    "DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeFlocker",
    "DaemonSetV1SpecTemplateSpecVolumeFlockerOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk",
    "DaemonSetV1SpecTemplateSpecVolumeGcePersistentDiskOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeGitRepo",
    "DaemonSetV1SpecTemplateSpecVolumeGitRepoOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeGlusterfs",
    "DaemonSetV1SpecTemplateSpecVolumeGlusterfsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeHostPath",
    "DaemonSetV1SpecTemplateSpecVolumeHostPathOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeIscsi",
    "DaemonSetV1SpecTemplateSpecVolumeIscsiOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeList",
    "DaemonSetV1SpecTemplateSpecVolumeLocal",
    "DaemonSetV1SpecTemplateSpecVolumeLocalOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeNfs",
    "DaemonSetV1SpecTemplateSpecVolumeNfsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim",
    "DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaimOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk",
    "DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDiskOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjected",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedList",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSources",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsList",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItemsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapList",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsList",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesList",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsList",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItemsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretList",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken",
    "DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountTokenOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeQuobyte",
    "DaemonSetV1SpecTemplateSpecVolumeQuobyteOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeRbd",
    "DaemonSetV1SpecTemplateSpecVolumeRbdOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef",
    "DaemonSetV1SpecTemplateSpecVolumeRbdSecretRefOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeSecret",
    "DaemonSetV1SpecTemplateSpecVolumeSecretItems",
    "DaemonSetV1SpecTemplateSpecVolumeSecretItemsList",
    "DaemonSetV1SpecTemplateSpecVolumeSecretItemsOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeSecretOutputReference",
    "DaemonSetV1SpecTemplateSpecVolumeVsphereVolume",
    "DaemonSetV1SpecTemplateSpecVolumeVsphereVolumeOutputReference",
    "DaemonSetV1Timeouts",
    "DaemonSetV1TimeoutsOutputReference",
]

publication.publish()


def _typecheckingstub__bdf87e882aaaa889ed81b3c02ee15493ec662875fa634d633e3b2349d5f0500b(
    scope: _constructs_77d1e7e8.Construct,
    id_: builtins.str,
    *,
    metadata: typing.Union[DaemonSetV1Metadata, typing.Dict[builtins.str, typing.Any]],
    spec: typing.Union[DaemonSetV1Spec, typing.Dict[builtins.str, typing.Any]],
    id: typing.Optional[builtins.str] = None,
    timeouts: typing.Optional[
        typing.Union[DaemonSetV1Timeouts, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    wait_for_rollout: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    connection: typing.Optional[
        typing.Union[
            typing.Union[
                _cdktf_9a9027ec.SSHProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
            typing.Union[
                _cdktf_9a9027ec.WinrmProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
        ]
    ] = None,
    count: typing.Optional[
        typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
    ] = None,
    depends_on: typing.Optional[
        typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
    ] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.TerraformResourceLifecycle,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[
        typing.Sequence[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.FileProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.LocalExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.RemoteExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f57d7ec1e461b521aff4fd5c09fcd6b18a42142458c99092f59884959735d161(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cdbaa0bd30250376303dc754a961dd4c57407e9e61007cc3125e1ea35db179d2(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__27a15e0e156c16ea0494d9083f085edd123c5c3e0c12573c5e36803ba559947b(
    *,
    connection: typing.Optional[
        typing.Union[
            typing.Union[
                _cdktf_9a9027ec.SSHProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
            typing.Union[
                _cdktf_9a9027ec.WinrmProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
        ]
    ] = None,
    count: typing.Optional[
        typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
    ] = None,
    depends_on: typing.Optional[
        typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
    ] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.TerraformResourceLifecycle,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[
        typing.Sequence[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.FileProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.LocalExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.RemoteExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ]
    ] = None,
    metadata: typing.Union[DaemonSetV1Metadata, typing.Dict[builtins.str, typing.Any]],
    spec: typing.Union[DaemonSetV1Spec, typing.Dict[builtins.str, typing.Any]],
    id: typing.Optional[builtins.str] = None,
    timeouts: typing.Optional[
        typing.Union[DaemonSetV1Timeouts, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    wait_for_rollout: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2cd343ae86f2ef126cd6894822726942c4d49d197a63dacfc9d86d7a53427944(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    generate_name: typing.Optional[builtins.str] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d3006c862f51f00f5be736fbaf88b09d5b04133e095dab79579f25a59df48e3f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56c9de6f2b67d52bf391e8e64aa83a10635505e263a604db111d439c605045d9(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__799d57cdc71719e6f8bb0e1a2e63ff2792e18dc179098a8f95d11e13936d080b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__02fc12f399b252957b53537bd9d9044732df65508c3703fdd10f0d2da2556f0f(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__001f63b2aa37fb24edde93bacfc790c9b659d90b6631480cfc5656d976da98a7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b04d34e9b39a99f0854e0ab065a51ef0700f6566cdf8b378dd99f5e239bd436(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f648822835c7ab315a5a9682227b536e8e85b99614e6c097d40476292d4b4c1c(
    value: typing.Optional[DaemonSetV1Metadata],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2c2dd4db9b50ecedebab6ce23ba29de842ed2ee4233f3cd99c36d98a428c0502(
    *,
    template: typing.Union[
        DaemonSetV1SpecTemplate, typing.Dict[builtins.str, typing.Any]
    ],
    min_ready_seconds: typing.Optional[jsii.Number] = None,
    revision_history_limit: typing.Optional[jsii.Number] = None,
    selector: typing.Optional[
        typing.Union[DaemonSetV1SpecSelector, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    strategy: typing.Optional[
        typing.Union[DaemonSetV1SpecStrategy, typing.Dict[builtins.str, typing.Any]]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__86d4d2de0194aae4a8ff9ddd7ef5bc1bba9584146be0c624893e025948c781db(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__10aa235c91906686100bf3f8b5102aa125326a6698aaf5080fb50bcc8621a2e1(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__86a07c848ccbac09a945c431d80b89363330f95231993ef8ba78da1286acae0d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__da90b63f635d949178d81d73584ac7c8e321304dba0d80fda0f1b1f7b761f381(
    value: typing.Optional[DaemonSetV1Spec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c116c58e5d3eceda218a1bcd212f898078b47802578066c4a78be800cf4ea389(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fdd9effe98b473b7e97434ed037b29f4a282c74613198175621a400d43fd315a(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8a4fccae171fd98ab7d332172561725b53f05f921e827f4da730de4d7ede8ec4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6c17479f21754a2f1cd57e56578a5124e52224d394d1ede5d7c8fc17e476a670(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__491e7030b2eb8a6d3e98179a9cd3d041b3aa446f483c2c705d47f13a3b1d9934(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ede15fcac64afda970f9a193ae132b7dd442712b96f00aedf784cff0f9d1c0e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e662d92ee894672d217c81e2e96e8b9c833c9063d4ae2789e3a9f1d1d75c45f7(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fdcd686d680226aab1e9ee8e37b3395412f105c692a832577343837a5838415e(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecSelectorMatchExpressions],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1e6f1056578f3597e9acff6bb3fd86bee090ba620dd6c716ea8ec4969256f418(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6a22b1c83597a33ec4a0a4576efc0c34ec368f82b8db8feeb12830ef15a2fcc3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e2ef5d6446f963185b6265976d16fe223a4ade49b8bad36553babda7a93c71ab(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4db8fc3e55a3e99f1908f7e80520dbe05ae62b673840a1933efe498114274970(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c76841c53090df1b6f2ee1c3288f1fa279bdff14449f2063209c63e887825a3f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecSelectorMatchExpressions
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47a50c816db5b1d20bc76f873abe7b134d0414a1245a55570d082ede4a3ef050(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47856dc44ab561f53624c8269ad53effcee81bfb215df6d8ac06e7c4923f0537(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecSelectorMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__48ba1a8038e995570d4174d459d90e6822435039031e832e963c77a0af417a5b(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2e6a2f6e14d72230fc6a056f6edd404ee4791ec6bdc885d6575529197aacaf3(
    value: typing.Optional[DaemonSetV1SpecSelector],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7ddfafbc99809b8986501c897d7d83096d14fe82d8ebe5c7d025eb2922392b27(
    *,
    rolling_update: typing.Optional[
        typing.Union[
            DaemonSetV1SpecStrategyRollingUpdate, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7af34dabe55b2deb8e3437395fb3bc93740d16ff61307c34ee69347f3c2f3789(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__06492ccabcfd4c7091d0e3d3bb777ee68217fcebc6ddfa151e4bc9b30306e095(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b7f9a16b03863bc4b0dbcf6df9cb8d551cd42e707dd6a1354b9d572f3f278038(
    value: typing.Optional[DaemonSetV1SpecStrategy],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ddc69aa1277d9351d9eff2b09a3f53a01350eb37770b3f131756acf510543bdf(
    *,
    max_unavailable: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba460bb4d7a5523b6cb4eb44ddf0743eebcc204eaabe23a1b11abe78dfbd3b5c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c2ad9ee8faef2b7a1ecfd91e330487b6fddf45fe58a21520ed88a0cbd528b9d1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1dbc73c86c074e380c680808d11cc951abae384e64af62f79734267c7a111682(
    value: typing.Optional[DaemonSetV1SpecStrategyRollingUpdate],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e404f94331ac675682095a83814e96690c6e9649b84cf9639bdd38f4ba490e97(
    *,
    metadata: typing.Union[
        DaemonSetV1SpecTemplateMetadata, typing.Dict[builtins.str, typing.Any]
    ],
    spec: typing.Optional[
        typing.Union[DaemonSetV1SpecTemplateSpec, typing.Dict[builtins.str, typing.Any]]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__be5a863dd417d1b5880bffcd7ecd5fd851dcdad7f8af2c78d0573337343a14a0(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    generate_name: typing.Optional[builtins.str] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__75a23c8967a668a796b8621a35975e105fe7e2ebde913f3751fd1c9321b22059(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c08697ee1e2d8c356e9f4ddd913e601e0bafcab0f5df58ac6e487fdaf22a8eb7(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0a8da97cc57054b85fbe1d71bbe6f6cb2d5af910471e58980c6cbbd44b890c9f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__84358d7e0032c504f9b174d1785a1c2f82a7fa403483877060cb084f064a9265(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aa06747850d7f48e2ebdcd3095169e7ab584cdc011991c9d50a04b2ea7a12bab(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f08c09315c1a3e706b10adf0c5cdb94b4e7c503e75587a5ac01c275c4b4cd72(
    value: typing.Optional[DaemonSetV1SpecTemplateMetadata],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0931e46a1acd1b6f1a2543b8d315a5f806b98fa1e0e62f66e938bb968261543a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8ed53d36f21b25140267ea48e0c0a25804cca0801dd65758a5d0bcdafccdac62(
    value: typing.Optional[DaemonSetV1SpecTemplate],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__95511a398776317ea2907cbb20d3b7f6f6becb7daf23a5bcadf2bc1290af1a46(
    *,
    active_deadline_seconds: typing.Optional[jsii.Number] = None,
    affinity: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecAffinity, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    automount_service_account_token: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    container: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainer,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    dns_config: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecDnsConfig, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    dns_policy: typing.Optional[builtins.str] = None,
    enable_service_links: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    host_aliases: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecHostAliases,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    host_ipc: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    hostname: typing.Optional[builtins.str] = None,
    host_network: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    host_pid: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    image_pull_secrets: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecImagePullSecrets,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    init_container: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainer,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    node_name: typing.Optional[builtins.str] = None,
    node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    priority_class_name: typing.Optional[builtins.str] = None,
    readiness_gate: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecReadinessGate,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    restart_policy: typing.Optional[builtins.str] = None,
    runtime_class_name: typing.Optional[builtins.str] = None,
    scheduler_name: typing.Optional[builtins.str] = None,
    security_context: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecSecurityContext,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    service_account_name: typing.Optional[builtins.str] = None,
    share_process_namespace: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    subdomain: typing.Optional[builtins.str] = None,
    termination_grace_period_seconds: typing.Optional[jsii.Number] = None,
    toleration: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecToleration,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    topology_spread_constraint: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraint,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    volume: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolume,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__693cd2db5715b1b053e5e9228c51101a566d7aa64e97814ec4d066323bd0e168(
    *,
    node_affinity: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinity,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    pod_affinity: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecAffinityPodAffinity,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    pod_anti_affinity: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9349475339419afa4c75a269dd19e628e3821315740ba7358743aa269a61a9da(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cae1b019ed9c8ad4db95c9429ebb1918ab083e56501c75cfbca1fb0b88273deb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3280415ad842a946f6c371aebb444aed02159cfa03a05fd6f095d9df9e91a964(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0b603d08b74f1b63be048da7bab6f119ecbf7be7502d631851733c1a12bf8f61(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinityNodeAffinity],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4481b6bcb4f77a066eb24b820a4275069085fce0416a7d15620682b591c117bb(
    *,
    preference: typing.Union[
        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
        typing.Dict[builtins.str, typing.Any],
    ],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__48644923600d433ed7c6b0d8628371c449b6926953868cc79b75962f0ce3b672(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__964f0459eb09bd54107d69873ac00687f981da3958f7164dd9f02a6ed1611adb(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5793281831dba73d197eaa6d3707d81d452e6ac8e15adc001af20dd4a001e9ed(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__37f6b58b51960cbcfb1c64e9a6330448ff71a8768c9ae9eebe64ba943163554a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08d80a47e97cdcefdc9016cf1ac4d9dd243e0e6b1d6d142f0609c1975df948e6(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8733108ae58cf83da66a7017c25a586d06a487f713d9d6b6e28fb57f4bd42cac(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__61c18d6de823a4f1a90904ed2129ad75df0d9e1a471e67295f501289cecc31e3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b5f33e2744e129dc3f30b67d8416d64c4d2027b4767af1fa09d8e04b0da1c734(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a9b7624a4340ce70b063d88306cefbb90850d9c5046fd2ff830cc02f2998ddb4(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5d11a9ca10f7ef9cfc92a760aa472e8bb0783b90e0041dfc0f650e8da640854f(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__414be9fba4ddb1db93504bc1ea784587cb9920e8ba86fc1a66f2a0f5e07aaccd(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b472534dd33b457e0a55f4f7935e03229c66ccd9152d543f68d625cccb9f57f5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f501757831ef760b2cb5cad82482e3a1a53788502c548d5c35b22a2ea188693(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0c94e342023998f1ea04ddc81d22bdff0f95df5aea225237cbe109083a6211ae(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__61b89b48c0ee8a0d19175928b95a4c0ba8c73e787548f775d9f5a80436f7d1ad(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15e5ef957890721c90acc75ef552385f43d40f67559861608615724ed42498d2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__87780a562e13a483750d8f73c0c3d6c68f71c2e79af19b66a366ca0e1474c773(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e08d8417a2471595cd0f838df12c2e99ededda9ae4a5bc0393c2680c94568c90(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d5745c487a19d7e456b7dc5ad2f9c757f635142e81aa2fd2521472a05398793a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2d00a2aee68497c0ece82b33c853c5e258419ec4ff46fdcffa3b967078080e8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85bb17c0194033beb1e98da9f5cd6a59df31e3a880beff33d11f49c333b0e775(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b6be36e9d74f2a385ba798c60a48161a9070c440a419a523c8e472341783e5b9(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ae13f8be74d540ffa0fc4f9e28e59aa99ec0b9cee85a0481f2391015abc63602(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3ff1d821e9875b214d546ac3e7579948e5da0c3938ca9348bcbd93ecc1f16373(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__32377dc9813e151481b00e23926242ae69f87a1210fce83dcad422a034f27816(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__98e964a2e0ed29054d31cbb069f702c7d5964e1d37b96611a85c38127fae6582(
    *,
    node_selector_term: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7e69f4cb475abee38f96981d1ab7ec90a22e7131c1be24b64f36fbcddfbe884d(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7356d7680ed7ab8cfb880ad2817c6acc7dc99bc235bda9f3fd36a0a46c169eeb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__220fc297681773368f4aa80b9bb2cfff7cf8aa925eb3da1886df25078e0e2073(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cb9212d67bf4b6dc788c214f1c433f5af96d601012ac54ee004d21a8e0bc1295(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__98d5affcc4e04982b216972871f0fd75153e96366be78b03cd85804c03f9523d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1c7a303b05a21019893367f0fd87098bf16e57c9913c5966486a62d9d566039e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ad2a940a7bdbebdb44d2c3bb66129dd93567c4b0d7802127db9564d5136b3fa6(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__86eae4794968b54acf252457cb375d18cb9f68de2ece868455b8349c8a054635(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f4d3101ce921028d6ea6907d5405d276cc2e491eba9d57caf4bd788fc075330d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__60df4c55047d53a26465745e92cd602372abc184a11e3efe4ada16abf1a3b995(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d029328a5a06a8a8fd6d7429b10d25833420d1223c3056c43478de3eb183ac00(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ee7377e3a3d7dc7f16ed26d10ae8848af834e259840e70df89c44a613551551c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc79f216107f60551a601ddb8f64b5f1d8786a7737ab63ec4b5b68c7716c2799(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c37a87b5b866281dbd7bebe09acda7d3aa2b367a7235c15bcb8b97551f83c56b(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d21a259825801aa8dfc05e4e8b15d321ef3f4c01bcd1809c8670224e9fb98947(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d4edd2b18699ecacdae8a08a150615ab485f64f727455a59bd64ef7eadf4fe7c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__74b2d6713255dd6cf3734fc50f7c3acaa03ecac8ba5ba8fc374ed45c701af76e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__449b767986060950cb213b95a4aad380645c04a53fb35df11d966e06869e98fe(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__12facbb081ed7e22886f8129e8928b2eb1455f1a6111e029a756a35ee3ec2e54(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__62b44a9d0301649af28a13d17d0e715c14d1412d3fd9cfa04cd761ec59994de7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47b89b8c39acf9c9b17ed01c4867427204635a34a7dc5e3c2a7bf2f4a20d36fd(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2dd0c58ada56bb2770faec84ef6a02698c784e7f13c705275f5f77ba12d7ca0(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ebef385022fbbbf4d16b67af8dacb58d55fded0928d7b748bec62841a4d79dbe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9f8eb4b9a2a9154414374df2bb927c2c8f01291d26b2c1c141de7c7b3e60f767(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aac43114436d50b13744b3ce5397bd805824286039e763b2557dbe26b84a7f72(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__17a7140b297f53c313b1a9112f7fddb69dd23afee06e0bfa80a7c1edfa7f066e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4024630229508eda1049e78dd60f4afb4a3b35df45f5c4d3ff0ff5fdabcfc97b(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinity],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0dc4ab4df8c018cf6ac7e286465fe9aad94edc2012b548c811c3c1426c20b6ec(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1ccc7ee91db6eec86d475414f6815d3bab166e9bd76ed31301f5971aeffb73d6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bfdb0fa49ce5fdf34e13c204414b8de772d11aa67545de0dc57217431dd927ab(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97d199480ace5dcbe9d64454f61adac622c1338437ae89c7d336b4704458cda7(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__20699e3ac57af5bbaf5ef50f20a6678c3d7eeb35b6f7c64d41672466d53de60d(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAffinity],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__683ccf583595e019f8b20c7e8907f39d2d99424fc6f303fa9a52fe73b52df0ec(
    *,
    pod_affinity_term: typing.Union[
        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
        typing.Dict[builtins.str, typing.Any],
    ],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b54bd9a5e22f63b369af22a0548ef5d6af9c5920b757ee22bccebd6cfd57aaac(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fed7f274cfa8a211d9e9af0effd19792fd73c5e64658efa57c45522dad464569(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7f585b20ef6bfe65f5f610ff05571e6954c187b6ca65ae57c6de5c4535b25b5d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b3da42f3801d48b38e32941a3e9ca44618ec1e2d80879d5090c924b281efc425(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bec55d5badd9178b3e9db7dccf8145eea712c7826111609a3a26c97bcde02a8f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd0bcd0a9b8093c44b325e333e408476423ad66a67ecffffdbd5a3e16367ed19(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7aaa8843d68934439608a37fab967d71890f4f2b44bcbc1ad54d22756439948(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__26363e434c221232c422d7b55bb75f91f1d2d350e8f85f0e84de1ea747c97db7(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f9967821da1fb6593795280a347f68bd863eb617ac80c8ae9a1ad4a39cdcf616(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b0de723eac2f29674bdd102e3c45efe62f781f2d62d1c3184ee7c1ce9056e731(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6e80a2ebcd3617e6631991bc3f7317951b6a73f0c7629cb7baa44f22e4287f78(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3550241bd1f57c102f8b59e2b0ce79e47f81748de6135c3bca0e298463a5aed6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2d19ce578f24e54587d08a76e8810b1af16166e2fa6fefa9b8b7070afb97c82b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__836762c44c89cb2b94fdeb145dc27fdb8336e082b66c23699c2852a312f01c12(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a52ae74d5a348661bf59b8fbd9ade32c834218702fc40dfff2144c22507a2e86(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9d6ea088aab8ad7063ae4f1e2c6ab91be4203f3f867ddaf2c2653c1a8e94a67e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__48b303f8c80462f31a85bdda237d497ad57f73f1249e4720e91c0ce93f98138e(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__37b02f6fb468a29383ea24016698fdbef2463c6396b40591e10366172b3c4417(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c3e92acf9d9825d8b786c5798eca63282cd9f2e5b049987b5f121ce09a31fa6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0d0e27cec765b0399b857530fca9a5eb6226d87cf170faebbeea7a3c987ac368(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3014ccac2275b2cbea7614e43d11a8ea33aea7bcd5e1df11cc398eb16d463907(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__39a79e27ca34efe83b00d90340d638a20e90bdcd5153548ab11e1961e1061e43(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__04a325243f65ccbc152522902f1dac692e96d1bca68730ef728b9555d2626ce9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a26421182ab3a7bde5fce992e50c73547aa8362bdf84caf01330c81fb49b8f1f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e61d1cfd350a4b9a26458f1671098943d5c84b5bde8ed52bfa1d49b02c672dbc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d1c54d436ddccb4c55bf37b7319157d47f458dbe5c7945b1bc32835045a900b6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c2eecd491e4514496e36352afe6acf472c2820858156193ece1b88bac5c5ef25(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f0b8ad0c1215ba5b65b7417d000239c548b2ddb55aa952e1298ef0134f5c96f8(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__28669c48820bbbd83ef31be2192e91e0c87dac6bea8dd453174f825f9308d9e4(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__23b85596c92ae383416788c02eb3430a4d66632d88bd23307cd313543606c1d7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__91701043d1f724685fcceeb11ed9773a5cafc70384fa0a16c9e5973fa9132ce6(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b9d482ade1f51e41accb3a1640cb8b7a50a953a6dc57be73d256c4d89f21f68f(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__341ab9dd0b89052ffb0a0f64dc9c5c6e74561036b1097c5c019aa9a98d616caa(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a6b718047aecb82c276abbe49be4b8345af758ad3dd160513e6f49f82edd5a3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__235c35b9364efd295e24832f54340e0cdb0bd79d590b452044cbac22cd227f06(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c83f17fd203c2fd4be4f68f5f537e05668afe01d33cabe2bf395e5bcfffad4ca(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__94d3f60f3c892116e06ac37cf3cf504519298ee3f8d1fdf02d9dc6c6e3901655(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f4e2d3674904d2d64716c9fc6559592163b7ece719aa5a18b03206b74c37c55(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__adebf095bbbf71af062c42c048076c024492f9ba0c2ad29e7026f74f85175c06(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__25379c6f73a89475d88335a67c43b5037aea1d9ea5188f46032493441482f145(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b74982780e6c89fcba2dd83f91294c4eea7f95d40acfa7e699ed419612bb5a5c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9e065a8bf8dad6e652345fca28dcb8a925fd57df5ae6bd06e319170c12d89db8(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a99089bf6b68d132e5f26ed8a4eb08e352d2fbfd3396b6648f2d8f2a00c8b0fe(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__090b91a492bec277207ee6708cf4c992efb259bf47f6e71d1af5096b01acdd8e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__02f92cf39ee3dbbba4991ce96f8cf1a85f0a282c7a1ecdab47f67ce3f75ed283(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ad5fb66922406f566fa151f4c56ce1b4774e09d0d497e2bbd40db5c11891c289(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a3a88e3185adf47c9fb59922ce6392bcb565318d291415ea394150ed62101d71(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__99581151f58ade508abf70941081538ddbe480c76272d56e2a2f61bc6eb8285e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0d92a3eadf24838e1cf7d9c2ac09f9cec5663352d08bf5784299fa61cd9ed6a5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__53bc76c99f8174476a4e14953e5ea0a7b3238dd51e5d97cc39e450a49c9d8cef(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3d207529afee23225f527ba5da97484a5e104f26bc69e1fc2218ee0399383e0f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a9993f21da027ad4c629a7f578fb40b8f86b365b3a5f0c3ce9da4bae221b77d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc0bb5ac532a3504d18cebfa42d875fddcada78418396796aa078e877292ce66(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e66f8fb2591a4ae0322f447544a006a495a56c4d71500bc4a6ba206fe80d2040(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f9926943c32606c017fdf48e3cd7cd7390e60b4d1b8ffc44113f0504e58d00ca(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5346deaa576e6c0a0c2d4cf2b456c62b81d4c46ce5da0627078feba2684534c5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f514b6a21a5cf4589629c8aa9605f8e83ad6323e196ffaaa42ec868bbe265063(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0eeb05a1bca8b79a16f264741f6894e5fc5ad3a308755f360bd89216539ad87(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__556eb783908c24d5d1c716f02b7902cc903c59d381a9d18af4e72c47c80bf959(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9d03084f0c79844d11297b326c08f24e4b3d1079046b2bdb1be751976ff07143(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ec5332c289b024aac91482f330d8df7dcc0cb811d0d94359819a345a362577df(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__22e5c26c294d1fd7e7e300bc03c1e7fa0e7ffac93f9b5d63af9f995c97156882(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6a8b402cf6315ad8dbb1fca6dd3cba5ab585e9b99e4d254527a81f8e18181cbe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fe4cd27efaa147964e04a64e48c8978e185670f19e4d1aa87cb8533e30f393e6(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c36e343b81f3b92fa8cd82badc3e9ef778bdd9b64123ac68579e9daa3c770d9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9aa0d935d61b037f69c9c0cb213ce450f291c7486447ba8d0adaee3e07a5953b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__295fe58a681ab984dc2546312598637992b6ca33e1a92a1517c17f6b2a862ea5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a2b579f63a0fe6c4d8f0c02c758eaeed541a748ac9f80d3400600089e66d7d4f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c542da3731ce869f607b5110f6ff49391c4f9d962fc06853b10d3ddd3c5a2d11(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b838fc9d820901c1ec5fe10d26b453b44f887842555ccb74dc742e7386497ef4(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__17d5766887162741099e58178d165821cf34eb1d838e54b51803ff30c33d66a4(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e6dfba26c5aaadc1060bd22c21efc67ee03938e17c670c2ed6b891d55889665f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__37a87c7e899438ac6bd623e34287f50e88831d570d052c86203050d7819a3b20(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c6777f3b9c456f7753539214519f5fb88955c1f319d1fc42adeb2f7f57cfb88(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bc8f2afb9d584177fa02c7ebc93edec5fec13159582ef7976512f70a460cae4b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__75a3ed2d780683d3aef4f2f4598d1da4de7d6dc18a6dcc95961c3700ea310b7c(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aa28697668aef27546174527bb336f4780e24e2e336d93eccf802b1ad655d54d(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d7b878f8fe9a306a9997ceb2e9846d6d36241da090dde26530d77b2f46f0d5c4(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinity],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__202c1d8932c1173c227a8efd0835ac1e251e310c2790000acecd8382733d78ae(
    *,
    pod_affinity_term: typing.Union[
        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
        typing.Dict[builtins.str, typing.Any],
    ],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb18a1e3b2b6c762d44b4fdf6e11a4f9c4fdb62006b4392f78bbc0a8c2185145(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__57e6c51e30929df22cb1e2b92c361003051e6ee47b5493dfe91930d39a90b882(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7ba80800e4afbfdbc2c7d84db49837428f8e02768047810f3f101f5efc38cd89(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__31b3e2d81b3f30ae5baf421b426220c11cdb1c4aed17bf5a76f3e1df72c37e44(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6307ac995dfe829707c2db8c8f2db99cf959b9111e97ee9d2910d1601b1f80a5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8d7ef20e8cd8e05f13ae6952e6890a03ccbd7835d0ad42593194abd86d44f406(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4338ea6194b00e7d65de6f9812b3faedc850777498eda2f699b8903268cae098(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7d204b8b3ddd7fbaa72932d194a1b323a6cf9c83348e0b8c7f3da6f22f820cf8(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c3fa515dbeb12e890a794316a96905a5c63e96beabf972f42e734bf8aa54ed6f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c78ab39fb0ced54741582cbf8ba0d5fa175de95a77c15ad21ea244555962d33(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__955ad37c6d7e6439fda9868fa9b130a5c2008384813ea6bc7cb66545a60e0eea(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af62793ed72bf5b86b339f5883ccb7ef30ea6b9d132d298d02d60ccc11983189(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__279306b45dcddc5c28635641eb2180e29015c0003e322b34b6fe6d14347138b5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4502d3ee93e7c735b06424ea5475b1469addd64640e70117651f2018df3bf47d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7050e0030e4f05f50b4ecac8d765e9f481a378ddd44fa7e55233faac8e69b9c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__87fa116accbaa6acf7bd4fff1daa1eaa295aca1c18580faa279e64ff183f5e74(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac5f07a66082855b15e3ff0092dac8c0fa401834340c99b594fab7bbbee28acc(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0ffd6346a365ce46e90fd226b37af73c8259d7a72555aca5a527fba9edffa36a(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a8f1a5df501dc1ef26274a1d3e1775416526c1acb9aff35acfdcf5d383a0f47d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b0c4a86ff25cbe0e15078726a5f1f64a94db6a0de15d435c7cb950045b0c1ea3(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d18fd4c366a1ffc34c452214baeecab133b0e826d057cc4d317f1bf9493d57e3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7dfb83d68a00839ae61dc904c7eb1c50d717874d11528113888a8c9fa03b53be(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2737f4b1bb4e9fd10ce766783c5d9894b3725747f7ecb4102fdc234b2197d35(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b76bd930f7314dacdae789cb90931a01dd34f71b6c75e839bb17daf4ff8a7f87(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3dcbfda91df6e94d75d8f273a84bf4b42aab11ca0174ab1dfecd3a4fa62b4a45(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__66fabaf4866bf70650a56b388dff2ab8f7c0611c8e4a038b7752361d3d0ff517(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4cc0a20473e8c7b7d3ad2610032ba9c056f245558016250d805e51c5a1f56cb0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0ca3a70e7ba212ffd118f41b8f4d8f5f70290b3ea60e96aceafd9630cc04cb56(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f194f135b48ef850d185bd9d5118de130cbc828d1571188b86fdd3c80b0ce029(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3524447c655d499044e9669998414d5a0321ae68778234da65ad56247572cbd4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__45e5f69de422e2337c0d9642b1d86c022ce1ce0a238eea68c8e72c1a14e6161a(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__996a40af0ed844ec43c0e7412784044c7d79ac152be0de4b8f4a8d7fa5566ea9(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a49c9600d4cf899ee7cdcfd124fa759ff25bf9d9c8a6361bed927f11e755f418(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca44dd978ac223389a0fdb69e1fdf61785db27a71981073a461955cffe4ee405(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__daee4b73f1923d56334b37f6930bac6aeded421313b280fa4b7d6bc2b6ac50fe(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9255c85e601ca7a229fd201181af4c98e7c1bb49cc0bdaade37942233f0d7979(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7a3eae7260a1bf47074d663c1afedadfd6bb764f3033db81bf1f9cb3901b385c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a3480a16363e12ed8059f947cc81db5f4e295c949bb3b835f6c8a197b43e77fc(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__28ae3a989bac0fcf02e4e7214c33dbeeac97321c62e602b61b7911fef46adaae(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1051589d2cf10812c58bd07f71deb5e850eabb1878d39fe5f672934177a05d8a(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b67657810d1ebac73830012d327c46b4ab92da9a85eaa73914a59b71242d088(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__95d13cc517c9611cb59efe71b98ed3e73407892025e8b873b13b8945f33f25d9(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0a6eab0df4d93c6f3e2009eacb369df5a6d495feea9e7d92fbe6b2649d4a1069(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f78d2ecce548c2e5c766df42369f539460ba9a593e28f1b5c2e3dad66571ed09(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__453c7ae1f6f48ec8d61a36ede9b9a71bcf3e48ef74b4f1da9ca936b2c8861073(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f800581210f94200c1ccca754b8003b4b447463b0ad67b1b61cd7d88fee5723(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__58dd45f5b04e197487d09653d901086f5a1e0835cfe827929e31b47a0284197a(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7cbcb60eea602fa82eeb16cf33682d5eb81d807528c9acc4be4a402fb88e5488(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__34e480368893dfbab47f3275164ebd8be6ca4338cdf8f92b57f03ccf439ea135(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1981eaa0c28e90d95a9f8a66de2abc0c386abbadd5e38567cc7911f301787e9e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__36657ee9b373194e785596195c8da6a1a404dc4c55759fe644dba91cfc14db0a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2054135c343a3cbbed25157657d0a8bc2d3a93e7745ad1db84b8b123ed3f72c8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1274faed5135e78b39cd7160e1df2cb77cd8655041ab749382cf462d0b877db2(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__100873b00f8fd38fd4a7371a4360a61ecc7dc41b6f6896e03270a88d1ba229f3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c80c7a035c37dfd76f50768ddb04ab1d47d49219f3dbb0463fb9eff8a4a96942(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__644f225d13c08d8141c87d5705c8a23a9d68b3d5107d047d15066125c0a2da9e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c16b7db231912611ed79fc905879bd38edf70b0dca031a819e330b3e84be8af1(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0d539e9c0c1a7356646c265575351037f4edb88936b876fc363c0c419e1c8946(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__94e1f6d67d9bb5d0b3f373dd866d8103ea31a8dc1fc913bbe39e7ecc98ceef21(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9133d0dc71ae07459f13fe5b92b3a7c04754bad0947b7b41e7966625250ac680(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c9551b380c68a15796078a65694bf977cabd50faebad4dafc65f5bde76d0d65(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__177bbabeeb4a3bd7856e4da46e5ab4969e6d2698d9bd49f6640f0f3e12786c8e(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f4ebb4dc3b7c7728eb5471ec1fba9d90d934c599ee76bcfd10c06b24662819e1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9a35a86f18d2b5ef90091153f28085ec68e845f5b1cd295e688d596361c52653(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5be18ee90520e4c7c8508a0083c75443bb011522fe4854524940317fbe8398ef(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__197bda5cc37cc66380a7e2b8f532c791def73f18b7b6bfe16b0fd73ed839ff8c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd855e201dc3791102b29234e7c3ad11dc5c0b3ee985f5169186dac857764f36(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8a8f0bd15cfc341a5367dc41bba4cc7e3c65c70e444a4279c22a9b115c258aed(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__61106720c78944794b0b01e14486d154f307d2bfb1b069b8045a1e11152a06ba(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb2962da240fb191dd674ca81ed4020128933cd96dbc0d5d995d603c042ae3e6(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__875925dc5640eb411f6039839b6d19d56ee93b9393b3d0ebf8dafa5f030a0f9f(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4e5763d1f135cae22a775b55ebb09d79614c8d14a8c73430404a6d7295976c64(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b484be5da3f2041902baed765858780778bd6be08142114efc6c7ae0d4ac773a(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7f1e23571d5dc78f757d058844a17f40820de79a9bb372c6c8e8ae2b59b577e1(
    *,
    name: builtins.str,
    args: typing.Optional[typing.Sequence[builtins.str]] = None,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerEnv,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    env_from: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerEnvFrom,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    image: typing.Optional[builtins.str] = None,
    image_pull_policy: typing.Optional[builtins.str] = None,
    lifecycle: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLifecycle,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    liveness_probe: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLivenessProbe,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    port: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerPort,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    readiness_probe: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerReadinessProbe,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    resources: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerResources,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    security_context: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerSecurityContext,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    startup_probe: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerStartupProbe,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    stdin: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    stdin_once: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    termination_message_path: typing.Optional[builtins.str] = None,
    termination_message_policy: typing.Optional[builtins.str] = None,
    tty: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    volume_mount: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerVolumeMount,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    working_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__317eeede47caf294e5a3f9d1e4fa90670c965f6361a583e09efde41a7f1fde70(
    *,
    name: builtins.str,
    value: typing.Optional[builtins.str] = None,
    value_from: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFrom,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc2599c373376ebeecd86fc4011ca44be0f9b9e1ccf26417b98b48ff478466bc(
    *,
    config_map_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    prefix: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__124be3c899ccee8792872e7c7daf20653a8dae9c76dc401dc0edf51434e64e14(
    *,
    name: builtins.str,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d81a60599a76e3ebad73ae3a99e6c11be486dbe3e08f0b9acf72c80c5dc738ff(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__01d91428f5970c6b605c197dfa5900eee4d84eda44be6bcf0691b459fb306454(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__16b6c4044156e53b20afff85d4562542405db8fc9404dc1c01d5d1ed88decc26(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a111ec82199b2a4d57a4f594999a0087fa2ce466f85d0e437886a11a5c769277(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromConfigMapRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3cb1ecf0eb029f7952f3f3c392fe309f5bca542f71812a5640cd87296c5af2d5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__41f3edad3a11b4c51fd0384aa41f722ed6bb2b55a1058d1cba49f9a0d84eeab0(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__55a4cd2a625c11005a9ec7ce801b6595d73cca187bc66f988f118a06e069170d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4ce8a9962f21fe85fcf51177f2ebb7437683cc8701fd8a37e22606e2d8b20677(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8fa2a540363e9cc9a4bb69cdb57c97351b1d8c8c0c51ddbd04163ce91cd969e2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8596f0eb410b2f25ad5547b19287ef9615c5b1fa6cc6e5064d736e634aa52044(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerEnvFrom],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cddb463caf56f11db93f51cee5e88da790880cfd7f4aaecaf54a34f8cfb2791c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__db8bf7bd08f7bc826223717d31235a94e33a7c0ebacaf22ebc9f6038db45ed1a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d77c68f17a8cc7f8009ad08bf005849484c703f6b08d37f884a350af5c5e58dc(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerEnvFrom
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__295a950884f2e013c07cff618862d04016f9a9a2f5afd478e6e3379b1cca6f36(
    *,
    name: builtins.str,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__831f7d23347db4b1cdb888aaa6513fbffb3a1c1bc512ec0d84901a16e9db6685(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__33420a507753fc086aac3243bf3ab242705f8b75257841ccbded04ead64502dc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2ec4b56c94a524494c35859d8adfef43dabb97588a6e3338990bb697931d4e52(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d1a3ca4b8671bd8a09b7a7d16ba1887d0354acf4b58d25f1d364394e498f4dbf(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvFromSecretRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2158c05383f4c949c37197e454f3c83bcee8263f7e6fccdf5c0e7791392512fc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f7eb6cb8c87c5fab93b03f47547ac1ff6b6178a6c9efe5a52068bf496ade63b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2c04a75c389fd795f5d5b8876e93755c177bf031cd25ab7b1e4df1df7979a326(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b9a59d59890f2e7003b5711a8899f530734fdd005fec4b163cecf02440693f44(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__331a0e2e1a71aeb20dee17052301615a8af33a10d887ea5f8747a606ff3f4ccb(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__030cf2a68ef3f8a81dc724f9d377dc9217d27b147d6f4b8baa04d52ffbf9f7bd(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerEnv],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__938dfcc320da56173c597d742ac90706597b8bc6538fabf3fb46e8f846de33a8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2f85fd793705ba70959480c65e729c3e561cbd6316871dbbcd5ac2f754c68772(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c8748d2c2c8042b46e9deb1f5453c8c31e06dc880d2ccf21c3a89ab3954b8bb1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__148922255009adf20d12d6a417df686e4ac2ff3b20eea2ca4da6b7564996006b(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerEnv
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__275ca5d11f1eedbd55c469b0081bc9a30b40f7c03789de7979bfedc65337e69f(
    *,
    config_map_key_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    field_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    resource_field_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    secret_key_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2b4453660279294306ae9899d47e28c2a5167c27f2a6e0782b2b51c20342bfc1(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e3c3692de2163a2fcc8d0f800a324df1d65695b182cb4a0ab218f8c02dcca0bf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c651a607f8f331739bcfca39655c46a1a4f59c98c48e87f0bc13323b363193e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d5948e9a41cf9f2cd3a9870a0602a3e48acce3ed4ff12f972fa33a05338be5d6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6b2bda68efe9eead709f38e75db8751f7caa6839e1bb39b142c6145cb89fe077(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c51445799c65fe4e3cb143bf1d60af440da265d560ca674e17b1a28a5ee9c3e6(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerEnvValueFromConfigMapKeyRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8e16025ed1f4bf9b3e62f9564185ca0e99a4fe75ee469fbbb18db2f1dc34fca2(
    *,
    api_version: typing.Optional[builtins.str] = None,
    field_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c799bac0b8950fa1a2f9243bc293b54be3dae1d424f19b891f0ef92971490e2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c1025af248b8629d2e9159f831be6cf887d1ff2e6e892802295f428415643352(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb1ae160f19b9ad4f2f266115b324abb1c5bd1d48002c06b07f91369bdd94c51(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__93590e61ddfb3d8c9db53397a5c665ae0ae58a4d234cc0fcc1178df791470f01(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFromFieldRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__662109395a3bbc06a4a4a7614cda307f2157a0072672ddfdf57d7e58e508eb62(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8be1ab2144027c3aad284fbc1978c59b0b4fb358e8496d62be742ea402b84b11(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerEnvValueFrom],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f6cf030d1c5c9d7a62b4ca094a3b1ca34692263b20140353857065776ce6200(
    *,
    resource: builtins.str,
    container_name: typing.Optional[builtins.str] = None,
    divisor: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f76ec169d4ee25655431739a25a94adbc2eb718cf2bd025543531b707728d860(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a59b3217b773d7a277c9bf49a96012c320c066feae450acc52c526317ef9290f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6ab1aad8bfa602765ecc898f40ddf47ad23ab76ffe8131394c5a07f6ccec679f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__59b4c33f8b8e0946f48d85d2ac98589b20af60d861c60c9ebe49919fd4fff7a2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6738e8f5763e96fd868bbf8a881b5a4d45675fa698251a26f54813280663ab5b(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerEnvValueFromResourceFieldRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f5daadd9e696f07e4ca70f527be478598d7b7a0b22a6bb672d9e3648b56576e2(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9cb6bc6789454eb49be2ddbf724acb94375d75a4824dbddc668e360805289b95(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__66fd93d57fbf7d198b4e1dd55a747f7460cc0b8ffd06ec2f7902ddeaf0d2585e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bec3ea3cbd5b9ef7ae1782e2a071924b805640f6efa3f498959f683ab3675c74(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d8c39ae16c6e0792587f6a2586a1b63b74679248a8a85637f1051c1fb6760337(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7b7b80b24322f0b4124310efaa7c63f4b13947e070a8186005e611582553fd6(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerEnvValueFromSecretKeyRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6ad1354116c7f039792eff80d33e1268cb6da40c7ac9430878790a0ca8fdda96(
    *,
    post_start: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    pre_stop: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__70675043a63c8d8c371635782652436284fdc0c641ecf980cc9eebd8a6e0b590(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0e423abb8cdc581c3322a2c6c114f85582bffd25f9cc6e8bb0970a59b3086c90(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4529cbd2903fc43235874d0463e2772cd923b692c112b6c41d86b51793283c7b(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8515d8ffc73816dc0cf73414efc0445c19329574aff952e72678ca72dc6bceba(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecycle],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__61e70e375b24bf441756d1d91c411216953c366e3725eb1d9b29194f4527966f(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4385d70c70a556e1671a333e4619e244364d043f9d1cec9b2a26a5ce709035af(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__486c0ed6099f2501586535b7036f9c6ec74a37028a63c81ee354b4749a7255c4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d8246f446e01ec7d628c462deb0743846e06b0f2160f94f2245acc5210ba793b(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ead5942707e4545620f27592c43ef3b794c64420e7625f34afbfb147ac45a941(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8e358d049e5571afb6ef97f89cebc6b88db92e87c5bebaa2df2ec604e2bbd47d(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2663f3a8c572296ae29638573cde50912e9fc5dbafc2cedd8765eef4ffd1e7fe(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__917efeb0cd194fbd7e3e262b03b63d3d4922f5222e6c6c681a9450858b5de69c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bedbae2236caed4c8e78c283c51d63a65ea167e7615605d9bf886654e2acb1a0(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8a4532ec46a6c0fd2b130fa69cac000263a5949d438ed5ff099c3639f16c47a7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4604b684cd9bcd6cb26830475f80a9adafca0bbf451ee319656bab559f56cf4a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1010855027c1d716c3c825f54753688215b5315a441a5e2cc87b898c96658676(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9e7c3e4ca407ff31d7a485462db50eb24e7de99cf0b3bfd9830e33d9b081b2e1(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97932ffdf65e791cd834b332b20b6892f4735f33a078d1a2e4d937355f6f56ba(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc31b99b5c4ce90f15c3eaa3312151b50a0956b583573968fadf426a96141122(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac821fec7d4a475109acf99a0629139f5c7d43cf89f6fbfa2d30d35adf29f97b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__07e4f95abe119a0d3b18ed6799107b906a028f61f7cfeeca058345cfb6a0cb52(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__686914d053e47831f5829a90c2f6c5d48956678589083e36ae257f741c62005b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e693563e18e9e82361df9953bee0497367bcc4311a30a899b67f5740c2f66b34(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0ae6ce3e011923a57341a8355d7376936ea7d4368d6486e08c40029fdd45f77(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1938bc1bfa25f83e16ce4e23d84c3c81f12f1071654e04b3914b8e1a7e64d95c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__02ad808017f20683810fdc58b45dc5af57cf59cbd583c03259da2ef054ef70f9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f9fee8eb2abbbaffccf034ad6d4e7ed7f4c545eb7e2484e14bc8fe54c39f95c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1dbe27bcd107d318a378f7e444eaafb10c6d6f0b2c6a7c86e9f6e46ad3af4259(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartHttpGet
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4bea5f8023268f3b2f5efd38bc8ce6f2d5f01191bc77cc6500470a99a7aa2cbf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__def3e03056769d9550040aeb71dfb0cda36f851f1936adbc11270362c88bbaf3(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ea20dc11e98fbd27e560547695c9fc1473fa1de1c053a8738fbffe2b6c4e25e0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dfefc4ba89d4789bb804be425292528684aca6a90879f0e72ef52571e1e962be(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2909158d81998b76ef10b6cf69553f17ea7a7a5cf805a03b3a53287f79038bf(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__042360cf993ad5750d0a9655f9a94e6c78835ac2b484d35f4e352c8bcabbd092(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a8c14a5242b87fbaff2c24d8586c11e410323997d7b5da2f6c383d988590439c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__26a28c517cf6abe20402a0c7acdc02f1c1d29430448dcfcd5449c7b9f7aac8d3(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d49dade93422dd00ae1a59964402371fbdb16404bf09fa6b24fddda235e1bf7e(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStart,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c8b002e24223580645afaf370f927ccd648cc748a6e3390b711a880bd5762e0(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5c04207fbfa3e9af14890f544c0231f5349a1c6c1cf1be24e5aa1a9249fcec03(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8fa9abb5bccead026437a47bd0b0f214dc999f54b922ee3daec1123fa3b6efdd(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__31a456c981c71d73e228405310e1a88bc5d4c0af6bdb57089c8023f510995803(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d2aa078b5cd2f63f244553c1eba837e6d4192a72179b800b033082bc4f03d26a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__835197e8006c5f7ce9bc6689efbbfbb70c6a9c421b7430bfa9e7aec49d887b41(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b1c990b77410c46c2dc670c54994474df4648743063f25f221f435bcc991e499(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__928cf40c1fce2ce8a6517d3bf253f21269d010da94b4c9816281abbfe009bb96(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__78d515b3caeb3dd9b972a9cd1872a1c310fc959c92b48017051becb55f1f1410(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5f59c2d78cceff45e8d864a2e76910d2da4f69e299f89088654ae3dd02e286e5(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePostStartTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__507cbfbe1820c3f332878ca546154a5070bbc1c7d144b429813f0563509fb5f4(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__558fe00b8c0de2030787e0b9a1a517a23fa83f33c584fd1d41d67c55ce4db7d9(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2ffc0225a1c9d0ba9c69ff1f6bbc2bfff10b9885a7923108c657dbc6481bb635(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1117b9abc8a17c97d2e650870b98cc28e990c746b49b95e153dcc3ceccafad73(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e25ac151185095632e8001fdd5b79cfd0624ea1be43ee94cbda22fc5bb30451c(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8612c8c4b570e13649bc750e497ddc02833ec71bc1f4fec1230ff8a14994857d(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cd366bca4342dbf98bc846c4997931c042a57de4a954cac0f859564b41045ca5(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1aba151892b8f325ecd51d5584c2d748cb69d1f1c66bdf4f83c469936324b1de(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__26786e3f76f37fb65ac443a5cc8fbac2cd05882866ea384380e77cbedbcf00ed(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__67b232d53ad5f32371397963e264661f828319494de1a5f7d627086cf784cd46(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fc60cd9ff724a5185caf3e242a6ed07ee4d458a80908841ae17ae375d1903ad1(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__110b6aa4465f5189433d2a1e95cbaf12f07086a7f0cb5b45049bc8c59ac5379a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7aab91da869f3cfc508f2cef394c4173be8121d51ec107682646d27d2da94ae5(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3eda652fc2986e42f0f918dc1c65fc9a93c2900534ca942e7d613300c2e8dac0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d9ec9ee2b7170b28a1dcc37155a6f2724c0a5ce0a59288d8b552c7c9efab0a62(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca36cf45d58e67c93f81cd478aeac467f3eba108bf766eddc07b76e1323f3e36(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dce5e53c8b69c0179e39304ef3474b90e5d9169bd6f4b6ca2da2fbf095d97c6f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__154150826539d5de9a63303285b66c10cd830828d9f48c7501fcb57ea4414376(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b8d1c6834cf0aac1459243fdd433bced141666893a136a1cb1c1580825ba809f(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15403ece7b7dcc6ec66d22b22f32c6f964498324cdff8411f46d363bac5a64cc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b5c1a1a3086b6a6ff97beceb6d546eeb2516db2feaf6dd9c8c8524bf3b04c1ae(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e0249fe6f6adbfd39e0598e6174c309275f611e08511f92780d0cc2a041c61ae(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__04af64c37e4fc9e1b63beb27966a4092c286380ac279bc456a399709d72883e6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6131b951afc118c1502f5061c6c3d749b779e5012dfbb150ff7cdbb407b11b4a(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopHttpGet],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__243597c9056dcd0a7caf1d9b1b6b83a0fcc6f31ef619e3f09ccad415964fa564(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e77c62659fb08dc8b6b3abcbd668fcec30eb859c086227a1e92c54499de5a137(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__657aacd2a6ceae495117abbdc9fc4afaf371dbf0e9411a2e963f577a73f2eb4f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a2548d5850ae7323a42eedb50a3fc5e3c1d0ac7e93044f0842ff7ee8e00ceb94(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba81a8779d5746e5ed2a6524afccea6d62cf8533031099caccba6f11fc997a72(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0efacaad67a101ec9371634621c2376acf3186012bc7c1a82a0510c9fd257c79(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f4284b5a59dd6bcfd52cee622c2f1fc9bc84f6d717f5a87863c8a74a19b3df6c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__20f2c025baa5296bba7b3a7e09a60c7465a81c64517b1d3fbe3c103876bab676(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b03b8d135e57bf67371b318983af357f1d7e4f3680ef109c91e3a53a16811c7(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStop,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__73fc11a5c05fcee349b186e243050946ae9b0887a612a86ff40efa8563f209f9(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fe3a7a5bfa4ec9c2c8b1a3651d536233468273d18c9b74308c7c316ccd4b3aa4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__936dd1290170ee1a59bfc22f3ec35e784b81a2d6d933a2e5c78e82cef3dd3a3b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8adc8778073e3f5db5863f43bfae69765d816470a2309c4e085448b69b658586(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dcc36e8f9eeaf14ea38a9dd92fd26d1f4018e56915d6a682179a933bc0633d3c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__470e0d4b814d1fd028ae758a34e47b4db4acdbdf16615885ee5da94076ea885a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__50056b35d2d1f74ca603b53789943a20dbebd3831e58d78b329934675486cabb(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a649fa84437024fb050145312f1af3d888e8c85e6b5a8a2d7d659addafd7edd1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__015ebca9a2b2b1bac8f82418d89c3712390c0fabbd852b54e34ced4fda86c0a1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2d41076a348a622ce480256771b87d7ec0aa807da35b202bcec151eb2603397(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLifecyclePreStopTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b306404787adb025335a8d228e115bbb5a53ecb8a554f96f6026d69c8e653c94(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cb0db4d7c469ccc5df221fe203f4248e1462ad7a5ce64d1bc1d7406148b1ef74(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e51fa0fafe6fa9111c1e27beb4f6b11de555db10dc0bd0dbc6737108c25da83b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__294db7de8fe698a109b2ffa00fe8f404a9a997b4cc0019572f51c9646d830684(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f6350433424ec80844bee682c5f1eec1f09f356451dd5c5af645dcf9fa79980f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__79da1e0e71981e2a656f023b6a201246454f50b131f51e8d64e3e88761a27fd1(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainer],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dc7249cff440f505e95b4f2a5561ff2065ad9c15b40c9ffa95754c6aa64df005(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    failure_threshold: typing.Optional[jsii.Number] = None,
    grpc: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0be1a654f75f13325fdaa5f16d1db10731298e2e3b28acca568458212861e97b(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__576db149aa482042ec14bd5b4533e72b3f63704b28f841de8a9d00f985b3badf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ae024c2912524f59610fc3a31d4bf6722576962bf72ea309439f50d62324ff1e(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__51cb74cd7d530dc0ec87102aaa660951be6b29d9efbd5e03a7a705bda630e55a(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__23c5a6f69ddc2d9cf0b046b635ccf6ffc6db62a3a1caa6339750827c8a8bc138(
    *,
    port: jsii.Number,
    service: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__42f17f2239c1fc69262684363c50dfd1179c37460f9f71dbf05a8244c46b958d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__728165761d7a53b41c244567b276c62493dcb804a615cc430663be9aa198733a(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a0b7550a5ecbda41dd219e760fc61413f1757835fcdeb81d5f89ae0070760360(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7103e57b91a20eff307cdc74c1ce569bf4c68f64e20eb0b525886c8aac4bb060(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c421adf73c3e6e0d6f244a7ae5b28ec247e1ff27f92307698b8634cb0ffa4ba7(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f737125a9a0b8aa18578f1e18a1d78e1f605661d912b97544fd226b6ff154f08(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c25ac3b62faba601f4d5ccf61ebc1a38521ec3ede242b82998d3228e40af016b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__589802c073a4225695b750c1d2d59dfa94c92c8fd5eb76662fa3dccc2d369b28(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__96b752e699b8f8f9efefcea4d65fefc0e1e6e84eb56d5e938d9682b69f9d677e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2d5383fefc50a045d8951c70a0d83ab44ea832dd85ffc63b2d969434d3d59d5f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b09d70f7ce3e3234347c41fd7a8c6d6cecd53500ebd9666a08a6ba5f95256c09(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__17fa4e6ab61981d004afc9c5c54366c9e99ac23ac7a4381b9058579d62244107(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2ac188db8f13976d89dcb432855a9c5247dfe5fd55e553babf3a2f07fa029a14(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dbd1b833681e40d3126facf0e035779cc132e1c50b67febf058352f728ddfe8e(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8e2507fad11cd8ab14dad2ac2fffcf0fc746079de7ea9d11aa3386ec40353da7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__272196b00415dd3194dfe712536d47f5fb1a7d8544ea94788f7fa7ea24022027(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bbecf5ce49763969c246018ac15d9f87248e890fe4114a467d66b2be058c02af(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2836542dfe65ec7d691716163b900d8095a3c1d54669250bb5d8a59a8423f110(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__34331321b8cef98ed64fe7295b118ce3bb4d609cb63bb4daf70674126799ff98(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f35913ffea21e7ec6df38ed92036a55a78e272c2bc76af8317a8e44974e80b64(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c1bb355cab160540585c83799fee7e6aab1da50221e0b976c4b5f78b76513075(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a59709e75fe3098d177c0ed9895e2bc43901522affea0c1c4717872b1a35b856(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__28858bac9bb87f48d537711a70ee73d8d7a74a04bc7a24f4dfc38252c8025df4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__09d0061816afd77aca178f21ea19b470488a0b8c3ada646663ba155ab2075012(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c0515f6e1918c673fd8dffe959d5e6f53f464b3936f69b28485a718484d4b1ee(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c19aabd43a1960382fd0b8e2b586aacb961ada7548a18de4f829f9be2c5e3ea3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a447f33c6cb546b6e77b53e03c96bef1261e372123781c5113d10b5919995a98(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0c9c0c54427c37c6ad076d558bf78416c9a2bc45dbe28012bd439e7dd27e12cb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d169e16a9d9321f48d35761a4a2429a2a22ba3559fea021dad1f54ca2be5da72(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbeHttpGet],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__01d9d24743acc86ee530c45c55da9e34fb4e4184007ee8e2047cf4f33d9480fc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__137d78e44b3e483c04fb3014f2eed8b06473c5674297a479d2b176d69c5f5e39(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeGrpc,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d3ccd9c6516f85ec27cff72b76d9c438596c7758f927c3e74d08bed6f5f18775(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__490b66aac58bc9ea1ee447af1dcf8e1d0e931f38c1809f5f9ad1f9213b097413(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__70185ada5f430a700454cb82de654979fad806c2418fd74dc64a510587548942(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a99ae6ce44c5f67bfe61cbe29ce4dad0cc2e11219dbb833d1381e13aaad20e53(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0991eb4023d930f6e85003be1e03178f6c8ec0f72a2d18900520a6e492d3dd3d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2604ec37c5cf765db49f0321f5a19b20e5984f19477df03f934f1b32f9d5a8e3(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__136a58f8b00c763cf04cfddfef75065e029a39d87f56ae53865515eb21c85046(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerLivenessProbe],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f48518be4a4e11e46b2900e71bbfafd1fe10d491a95869fa6362d94204003421(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__263a28ec3135ff5b50b95b21575f135e593e2487f19c7f5a282e18cf35e610f5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5f97bea58e22a3323137a7624ece3086e1036e0efb8d4fecb1e11fd8de6066f7(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7914deccb804727ee9589a44ac7e8a0dc4bbd879dc4d2b665ef95c63a6b42991(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__78c2178cbeeb038ad7dfb37987bb794c898508f50d37019943bafb46ac7cd639(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__96586c4b2304db10c212120c648f0ba96182fc4fff9cb557468802518fcd65c7(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__150af953f02aa933535fe977882c691c8671c913a287bca9d43213c58b313e29(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a09230202b1ee41763d289925aaf390634512660fc5bb4dea51dd24cbb682cad(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__89db535aae1d13cb6a418335560a252e018a464571b50d19fe99358cade9088d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ea5a8b4eaa1d26078394f37753af1aa6df51111d5b83cd85e342b08e7da161e4(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerLivenessProbeTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__27b30c9a03231611caaab277fdeaba4f803f52e23ccf265d55eabb906dba61cc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__37eadce319e6787e2f3385376af58acac5e4bfcc1ee79d9267cb6593f80cd628(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerEnv,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1615c18efdceaa247d84aa616a7a4b7cc206cf7e05b0838ba1bdfe0538ce6f6c(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerEnvFrom,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aff4a832b50ba68fa8ab1b75df50eca8cb5eeaa904c2fa895c120507499e439b(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerPort,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__22693631977df2961de293fb25e7852f3eac308ede51beb42022533f15d981c4(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerVolumeMount,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e1d06865c21333b41920008d919efa4b90749e6eee73a8ee8d0d9c9a8cd302db(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4d5a61d4952794dc4a0ffe8cfc3c375926a745dd68e321ef73d3a3aeddbbff45(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7910347bac72c0f7a1db302d6cea376e1410e8109ddee06ca947c205f1a04dda(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6e27de6cb3cd9c3147802cae7fbbd77091dbb02e6204c6f29b5717382135ac3b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5c7b2bf693784e8a2135424d5d21195de1f323671eebef73a42300839edf96a0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__57552a5e0b81d607a5e139a7929b8f3a21589189bc023d7d3952ca25474dbe4f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d583ebfed958d72469295618c7f4bbcc49ef7857513a5033b289207f245648c1(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__76219ebe9c99c0596f6514b1e473a7d3f7d47c78b071ca12d6237eb7496f3203(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__86260db9ca11ce40ae76842f871602796f5dea3a176a808554608c31dbdb40f2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3acd08403567e6bd4db13686b36c3ee44f55ed23e394e0141c3bfa94a2ade70e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2c729df33c7eb6da6369865fb590ea3d227e58e9f22482cab4d917356928e4fd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9fcb2ad6e681ed26feebe0a0b401795e15a90609c4bbafd474fa29bdc89eff49(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainer]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__616ffc0874da60785dbf0860a6253d320403a8222cdcabe4481f6b41406309ff(
    *,
    container_port: jsii.Number,
    host_ip: typing.Optional[builtins.str] = None,
    host_port: typing.Optional[jsii.Number] = None,
    name: typing.Optional[builtins.str] = None,
    protocol: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c05b3b4406723b8984967d621d954991ee409351276779c40473a95899400ab0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d949de365b639cede158fc4018c358dc890de9250cffec59d4a51c598f1bd261(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__927be62e459bda8a8046f0fc0be8f787228c07f356f567bdce6cdb3455660fe0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e2100d953393027e8f67217c9ec93e5a7bf831ff9f8ae958adc7149addfdceaf(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__faf7d0fb1a1553bb6f9c38b3aecee00f29d90c61510ba5da872ddb1d934e845f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__441363f0af91427212c7d9ffd1fe3695bc1b3996dd1a5c6f591de759c2c57936(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerPort],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9ea9ca6f23ae4d761a1fa828fbb65251126e774b7457eb054b922b77eaa80837(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c8910e90a60c3377cbf8163c8cfc4d36a47e4bbbc96de9b640933d549e516159(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c58d70e40270628ccb81bb2a3e621ab1e3f510cc2481f348a01c953341cb6fd6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b4136b974ccec7ebcc5b2c39f2fc342e4e053199ec783834d256d7b455e3b9ed(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f85d9e8acce4f44fb0fcaabd00032ef05f8b01b5077a507a1e36c14c7bc8c1f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4ddee2f9e8d400793666455976575e9f309f819bf4ab8071f1809a7af2a8f7f9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__22bdf9500ecdf36fa4ce50e7cb22d7a3da8f74b63c0cde92656e1b366779257c(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerPort
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2d3d42d563017ca60a8f08f580575709deab6b84c23da8aa9d3d360d9edc0f4f(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    failure_threshold: typing.Optional[jsii.Number] = None,
    grpc: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9d18186967a9876bb2fba0b8547990b877e2a3ef2abf7bffc7a0344be483880f(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15f4f1fac7783eeb01fc288b82199d76662ac0e480ccbb62abe83571e5256a98(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__79197d1db1085bce8daa43326121541b88c60a0d4e399279051c7851b32f8224(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5f75166b018f040a7a949747b54e97b5498d4e96484fd9e8d8cd9b40af31261f(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__78bf26c4e4e38f4d520074519ea750f5a1e88bab65c839947d34ad636f89cff5(
    *,
    port: jsii.Number,
    service: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf1253b59f5108bb2855d8a3aa635ba13598c3c38665cd70a4211c9849648555(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__849e0238b8343a0836fa366f0061f4edf61ffdf43159403efcdc6ddb5eddb2e6(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6a97b9e98385d42c6433fda16dd62daf12a92589b37639441028a3bc8cb13bd9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c4ecd47bc04925cd665343e6ad82e00dfc36d0afb3da4262cff2cdb400ab51c7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f506dcb8f45b91bf639f29e366edd2cb288991a573098a9b853492079f22dbdd(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af2e058c46ea2adc009a23f8c6b853a589f4ae31b5e762be74d5d06e3b700591(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__efc3ca4f9cedc4dcffe341b957f26c9ba2148bee61cc6aa8162e4e5a36f9ca2e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1d1ffba3cde575a9179d02de724574e5f6cf2dfd0efb5bbe76ee4696437363a9(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b33088ab52809818076c4d292225b6acbdb8e0f6a825fb3d3ce490608d5837ad(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7e723182809765e7b7f0a3ce80f785e3dfb7626ee08c10f9a1a957e69a7bf34(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e4ee96931964abd7a6c8d2a462b3a04dd4c8f34f12cd4c8abdc075bba1f53c67(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8665fc78695243731b12a35456fa3c017ad6677c595992c5622c38d469d72910(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__11bd6f80e8131a8a9e625cfb3ad199a50288368cd6ea8e853ee52123baf3901c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2a8dfcba5daf52655a8843fc34332e446db5bf92883c2f9c5b9468191bb03638(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__96e243eb4aa85dee6062c2aa586b4bc58f9d4b942b55515493c7722ddabef192(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2dcaf742dc565c2d2da25f9af7fe6d1141ac75df352cff3b1220f8703a734eec(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2dc441089811b938b8c8f942e98f0edb48c1fcda635291e5ef8bd2f588a3a96a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2e1bb72921854295bf42e11640bedd45171bdef7fa187cc7359a439622c3845(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f6c93b38e51738a8bf281f40c048fc8e9796048ef88e3b7a45fce85e44632381(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__798eaf7261cf40c2c1075a0ed5bb896b9acc4fdda7ad52ad04d342040739a69a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__87ac7fd1b857778a580753d272330f33e13f4ab26ed4fd683ec2a94126689942(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__19d56bb922e3f8e7f3caaee96160989f5e100acc38c8c26a9608c735eb0b8233(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4fbed2e912dc379101f9b2304743096127d149f931bce2777bdebc2b16a7a874(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dde656cf4db19e729e91a21015082ba11196c59bbd5c65061917743e53acb18c(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1423e125d8d59651f3c02c17bf1d49396ec6e798d99ad58d225fb50c1ed48099(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__00023d1f3fef03fbc6160982c67515ad2505b44b739b1c2dad68dc7acfe06579(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__49625c15aae1cc598932cbffc5dd1f8193067cad6927cfd289a8f2cee9f14747(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d8f9d5815be3e60a6d2495a4644e8ee0c8daadab098ce742922b31237938b365(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d3a4fe6290020a880f774893dd7e9b1b830a648d391a1ec5daaa083cbfbda7fe(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbeHttpGet],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2cee60d3427a16eb3523b5502398f7758d55017f458dbf2d773bb1fc7901192d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__26d7d39ebdc0cc899bd09c0d5d95d8a6a8610945c9a79f00aec48cdbf8f62f81(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeGrpc,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dba8d41c960c88c772bfe5993815d99d08057397dc4b966fb8d3f62c7f475481(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c54e1850dbcf39e057cd0efa8975c81da6f2e52486f739303ca4464abee366ea(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e525b7169b5b67449c5f78aa784798f9ef444034e33d5213c144e3ebe127fee6(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c713a63b2ac1b2f41596969dca1c13f526a73fbd86384b27491c4e609902223e(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2fd83046a06c989ad5dd2ce93d4cbbe0e76600ba29c34735e358b6767d1da41b(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c08ac90645cc57d35a15436d9b4acb7906bd5a297c8d7206452b9df4e8c2e431(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__29d783e5ff084d665b42fc4e92ba051c4a865f7e58205a09b2190ddaecac8e16(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerReadinessProbe],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56a02d2d7d8368d2c64c643dd0c80d2de7c695b76ca364ad67a1145336fb55a8(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1c4a839b30637248ede25dafdd7abc4aad8e4b35fe826881dcfda0321cb6a369(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2c9c539b7ee00b5a8543b0769d51444ea35bc017c8d3882d9a0854eba307519(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e40040f3558ad34a9cc67c96b0728f6afddeb4b6b9080de05944890a82956b76(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c349f64fbb5f018998961349560429519f4f02bb45417651b1e225ee6dac6f9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c96d52bd585a269502c485c68a2a13f64732c8db58931b458e250c6d253c5d07(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f3d6dc59a3a23628c979635b9ec680a608629221a6b074fb1b0150c986404b72(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c36395078d585a9805f7840d3b13093c9048eb7eecc14d9c41e8794714c93a7c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2c58e23676d81ce4e0acab59591dda631ae3889f61dea22d8052eb7a1ba1c2fd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__927eaffbafb4125b14c805677619fbafd12cff10f87978903cf4a7b5eb0f4dd6(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerReadinessProbeTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dfd99ad4fd05cbc63937bbc7ac54db5d194e86c73b4d37896c47c607d91a1b0d(
    *,
    limits: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    requests: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cbd8d91a08dd5efeff9f78cf2a7dbfb3c2885cf2e0c3d2e5b435f1b3123787f0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__24f261bce5a5fde89278c3d980cd6bc16a8891a2cd3149b8c5e1e22d992d77d7(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__32e0e7a3e5839021458ffa8f5317504af76a4be6c33df698f347fa3c24766aa1(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f77ad9f5e7dc7ab8015617819291b9dd23c4ddc1b6dc4ed799d9093ec7c59b2b(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerResources],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__518185f360f2df4d4d87b4faa9c74dfe282c5249a68582547c46689720554f60(
    *,
    allow_privilege_escalation: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    capabilities: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    privileged: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    read_only_root_filesystem: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    run_as_group: typing.Optional[builtins.str] = None,
    run_as_non_root: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    run_as_user: typing.Optional[builtins.str] = None,
    seccomp_profile: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    se_linux_options: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a693ed89ece9d42b91ef90d7983927ecfad4bf9f532fbdd682d832c7b78bc6f6(
    *,
    add: typing.Optional[typing.Sequence[builtins.str]] = None,
    drop: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2d891034991f2de2f6a401f6c49cd22f05c44b4c1107e414ec72d7384ef28f8f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7f85c006b1e678ac9c90651a68dad15cf8b4eb3aac425207284d2e4051490f6c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd884d8ea0b9335314a688157814d0c976c16c44273656bc4f2f9b2ce1ad722d(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__611f499edb62944e16735bd43c9cb020b99d562d4843329c6139efbfca43664a(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerSecurityContextCapabilities
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac11491d3ef80f3985208a62b6b4890247f7c6b7ee0d631a7e0f09f4b6d12dd9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c8dd46d44d4f6529c58433d8c5968ff2336f0fe044664f2ebafcc83566493f1e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__14088fba1cb299a966a0bbaa60d314cd87c382b11e5ee32b03e12207a2f9b540(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__42eadb80283d2a19c12a078239288fa63dbd20aad0675e3aa59af4df4adb850d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b04ead63ec1b9d7a0d568a9a0e31ca6e6d438c33a2a4c05ffd1ba15e6466ca40(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b810a087cf6c9cdc42102e5d4dd93da057db2299ecb2287c3b925e5a6c204363(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0fcaeed301fbd05961f63fb6baabe83cc393e7542bdcfa2d6861103e45a9c37e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c5442683767d802fb5147165dd29d1ab1099c00ddeb404fde6993b060cb6bf65(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerSecurityContext],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f4c253f664ce8ddc354293a6c733421008f4e4eab66b4cecb7ac3efcffaf6ab(
    *,
    level: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5e78c4581e0fa27127f0c0cde779f650221463360166f538b46231a5bcd1565(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8c010e4b50f23e5d897382ceba9030de5525ab1215b8b790848e9bb272dbcee3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__afc536205fbb00260694d0e1d80610090c44e9c24b9859e1f6bd15092ba07d7c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c4f7b9d48f521b8e467af5c790b0faf026668bcca53c400e11640fb4f4326fc6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__76ba1b287dee30ee6b41253afa6f6098162c6ccecfb3372cc4b58d7686c7cac9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__222583675e51f77795f4d3aae943364147b109fbc7dee080d41e65c8fe55e77c(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerSecurityContextSeLinuxOptions
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__66331473248079ebebcfe9384471daa8e4b4dc82ddbca06fcf826092fe3a3f81(
    *,
    localhost_profile: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cb51ea27753f7d213fc1bc0a9fbda167a8b6e4a3eb45f7b596055f30aaf5eb4d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dda97c8576fcbfa48b30a0ecc27dafca813145de1f345fc20f8959296520ed73(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__972f32f7f0332ecea1aefa6beb9e25522987bb40640299ac3b577538c85ea05a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5a56ba71d9088b792b314dbb985793ea6f4c2d80306f63d84d35690693cbe90(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecContainerSecurityContextSeccompProfile
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0686c76df69356a06aaf59523caa0889c94331bb47b8c2923bfd3772c7bb5003(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerStartupProbeExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    failure_threshold: typing.Optional[jsii.Number] = None,
    grpc: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d370aaee037d1330656f7e1f77ae74a4f4f6942a9aa2c884f65205e6e843e6bb(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08172d40d6a61984a3c0cb4bf5e0fdac83d0e16aa33a14bfe15df050ae00f3c0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b4295bd2061841f932ce9fe13bde728c495524df6ce4710fc7e24256ea60f1c8(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b8d3638af6b9e77a8e7585ff9d7ee6f45be1de83f78063bed0b8787e34f5af7f(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__102ab253974859980ab7c9101fe1c6e219d409fe709255cfd69414d742221da6(
    *,
    port: jsii.Number,
    service: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2259673f5569f679719de458bc705f3d92fb5ee976b8074d83f1b1710f98da19(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__679e4e308fceb8554a99840bf020d097f94634c4665d75f53686840fcc79596f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6888ab33ab78061dd2a7004d4a7c870facf22b284a3288d9fe8ae7d41ea5159c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9872ea2713577634e25fbb6c3ef1974b709ae1d9277752eaf9eb3d0b031f9961(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3cb135e11077c90e706b588f055556e61926661d1d3aef50eb2aa4805a908790(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2017bd2ede0db7526c58f2b1e4abb41de3c27fce99be3948a7262302afe61a90(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dfef34e5850489bdcf69ed4ee02c3e3c87e26bfaa4bf8ca76494aef26f58d0aa(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ee859a0a7f80a4a334df8f2f7b839dc059e8df8a234802423eeac613ac07000(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08c966cf164b46f33c74fa4746d89f42e107ee7841fb6d4346a0a80b86f49a5f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__41becfedc60cfdea669bf0aa0cdb3aff1281d29bd8aadc872baa52de73ffaf50(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ab2b1406d56b53995db79185fe31fdc10e77102c899db8fe78d77dfcc0e8fb08(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__35eedb8c19b9986bdff1b50896fce6bdc2d1a5f32c927c50f168170289194482(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__809a9d909d6d90b49928bdef40be7979c86a302c355e7d3a1e454d5b9031d838(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9e26f64e6b97e2193317ec691bd5dae42388054e3a8e27f4807f62f3367813a6(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8aec937317e201496f152eaadce664370f52eec2275bdc9286c6f0be55692c41(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__41afa6f052496ea4657868b95d8ef51712175bb72f799d547213fffff37cbeaa(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__49c1b70c437352bfde61a24055cefeca0dd207eee180d04b6f7ca4e3994dd051(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6db51481ccd749a5a08e619acfe114d413826aedb8914c0b2977ec5d9a30f901(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f06ab158af086cacff0f9a17a1098e138557780d2f93a40950e1e2c020a9c19c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0d84e7a2ed4d88a0ac42f9897c1d9e99639ee760f063cc12110fd4fef0bc2f1d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8dd2a7ce307a39cf4e9065b2bd4522a8db1513563e505ba6d8d6815764873514(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1c4f141f5f54ab9aa4d9064bc4f8364124d7a7baef439f978f48fc462cca0a82(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__60a9fa0e1370e317382fefadc157e169dbdf92356ca630817019eef083423790(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__01a98f4072c9e12cdf29e5e75badf8b4a403684e84abe20f08065fc4d59329e6(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a8b087383d0f8efa177a693378bb849fc7e09b0bc10e1ec1169a7b831c2d71a2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3535c377924c0fa4b557559369aeccf1659846e8fc0435344e8eae8c69adf7cf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2b21d21335dd3d2231a3c3c9fe2339e2a5a7c3e5ca70aff2400e83ed978c5de(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c6a0c15d812a9e4c795ac69bdccf7da70e8c47968cd7d90d9b5305af9b9bdaf8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb1d7c10cca684845ce834f21ed550f539d2a9f0f9e9de7fdf4710aef202f82f(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbeHttpGet],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__719d6d1a567f58275bca9fd84a29a40fa2a811309ea050f3a36dc8cd2549b5a5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4956b7af80570296dc4cf609c5065834788d528d2ed12813f94aebdf3824dfb8(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerStartupProbeGrpc,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e6fec0c6fe2c6f9cbad91550f5a47ba74066633c349737202c00f9e69dc67f25(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__462dc7b51f867a6b03e48a0dda6f32c4fe45dfd4350656451155038a36ea80ed(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47f17ab1dfd1d026392cac698dfd312083843f78da483fe9936d1894eecdf5a0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__26ad2b8134268152d879e217f0bc347ef1a31a429572532d35ea25b8186a7677(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f50777ba38cb874e32ef0491ef82305ac6b828769a7454998b2b399fab934ed(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ce1de9616cc23078d41788fc4861ca34002c4698c4fae2c57ec6616fb0583ba8(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5b70d5da7a7d64cdaa5aa62d205e674ade422236611d1dbdff0440c1c9cf7e5(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecContainerStartupProbe],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ed90d1f248cb6929bf719bd1725dd6ef126dc5cfc7d47f8e79458064948798c1(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__55d18e77e480039b7ddb6aac4c5eb5b22b0c806247a3d07e5060860e2fb7fb4c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3e2e931671b2918aab50718c9e05c1906bc7fad81080364d73e54c0d95887aae(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9bca25a795a332419e34fde310313acbf2a97872d2317531bd6ea3545932d85d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__71bd74024f4fd12f0ed0a4c541ea24f774d8a2d56b2b84a2fac3d54685c9e508(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0c9582bf774501191c38e5584b28171153cc00f352829f4c01aea6d2b71f638c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac63ad4047c280993169946f2ca4b7c72a4c332de1da9bc10e517fccc4d030c5(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__35ee1a5ea9d3929074ed6ed8151cc002d49ba67e8ba8ed84b1264b58631f9d5d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fe45e74455d88bba4ee71c9c97c8b1c508200e48d4ebff45f065f18edb41176b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__808cfa80a7d87168d5c5f111750b18a21d64378aff44743fca4392e01b69ebe2(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecContainerStartupProbeTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bb9130d2175eae4ad951a9f597d0c1680d69f8f74ce48029150818080a7275a5(
    *,
    mount_path: builtins.str,
    name: builtins.str,
    mount_propagation: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    sub_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__df77ed64da9928593b60a560fcbcc86ded67e65f2e90205bfb81a808ff3dca8c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8eb47705ed424f64d9ea9b6121cd523f51e128a39c1b94c579072946c4936400(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a3a710f9726deb7d34399d0bfec45a1ad12481542f715a0a6156f90cc6f133ec(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__765a9a7e19133326f8197dda0c63a11a36b9d86cdbeaf61489359426e9250bc0(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__27bc8d19ac46619e5efdfc1ba81b3d67f8cffa147bf318ca9b8df8de281cb493(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__389a8cac35203e79781b49fbafdc4f0e477ba05ef1d461a51b6c0301c69d364e(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecContainerVolumeMount],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0111aac91c4177be35759907d4432c9dfeabb404c9026ac4d681fd3292d4bbd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d652daa13b9753654fb14f27beff3998f7157b31c4c16b9bf3b3af20e53e276c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b8592796208384b3833ca2bd0c5ee4f4e27e8500aaf2cad8d8647b3c31d81f2e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7087fe46b63179b450f48872836b9def0e0fadd46284d05a10c8ff0da04fe766(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bc8f21446c614a30587b1452bc6129f5d987f7bc43bce6a5588701731a351efe(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1de2d55bf2deee5e8351c4516543a9504b39fdd58607563b2b02d41fc5053fa3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__081c160e791bc51a39c7085461f4f96641de2dc098ec41732b8f296de9f8710f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecContainerVolumeMount
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2a082483dd52eadc6d84dc114466bc8a89748570fc786e6c14bf4916894ca99(
    *,
    nameservers: typing.Optional[typing.Sequence[builtins.str]] = None,
    option: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecDnsConfigOption,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    searches: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0761b9a1737c02d281a04abe1665c2f1dbd1eced3a95fd48a279461332ce3054(
    *,
    name: builtins.str,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5dd64d48e9eb871d3f32391eeaeef97879232c764b0b101b388021809b9d7789(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ecd9825258cd5881f8eeaaf2083d6de1de9df20f3e830dc1e5440ee05bb91fad(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d97bfa53e6c0b92be3ffa3238d302a8625562fd1ace1e0186a4c868a68870684(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2de9d9bd1f9d9dc22abf0377929562893257456a552f6aabdd3cc0780bbde1e7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dea6aff9140b93bcddbe6448e07c61bc8fccf7fda7538f91d790041113f9eede(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__10bc89f60c780d3b8073ad0ed7f4f54e597cf441f7e78487d402446542ab7c37(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecDnsConfigOption],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__84ce3480537ae7c99f82cc069f9bedb59110d99e3200d6957bb424127021f263(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__54e73f402dd652b0c9016dad7f4c0b3340708a2762772701cdc8adb841548e65(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b68ebf2ffc216b3704072180eeb57b795951d418423bf913fd048cf307083c46(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9ff272b8874e9d3822624caef2ef307d3af0119cb89ec37b96de8b3c4406ff61(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecDnsConfigOption
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b5d1690b8957d6502a2705c5e2d6d154a64e02f894ba03be7747381fac9c4274(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ed5311a45a7b3390752b1f6648a8e776b5962805a90966e4169ed01c61d2da7(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecDnsConfigOption,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__60ab48f47f49a3ea10ca630876b290eab77625655564ba483fbc3783dc503dc0(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3cac81acc4a94eef13cdb3475e48a47e453cf5f9e097d37f0abc876f54796207(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__82a54405b6f6bbfd5bf0d5bf082fc6a126d5dc0577902fa1f3e0861110da664e(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecDnsConfig],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__980b2ee925b2159ce34ea93f5171e660e2c11c0325c04ff771d5c24014c96011(
    *,
    hostnames: typing.Sequence[builtins.str],
    ip: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a83a918810e07df831463752019794c043a0809ff932bdf31caa0790215ae5d2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__efede7d0c401debfd27fb713dcad788e77ddea6939e19c60127ca8f29f18f0f7(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a7b16be4e663b6143c3798cbf81405f2591fa1a891c49249c9d5a82bafaa78d1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__956f429970c6472ed4181c9732870666c2d55d18f9af529b66f80a245c8ff888(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__81d703b04b5b6e6a98d362e0e9f88f6139b00c27cee2acd0357eeba8c780f984(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6b6a2ccd528d7a9c5d0755cb1f3bba90e2a661acda4d3e4c6f22a45dd4c5d60a(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecHostAliases],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__05a7352e6a4c64e768ff4af74ebd9f1a381c52e81eaaf598e8439ce8dede35b8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__234592446332326921339e6019575e435b5c54c73fdf9310f1489d20d00e3a9e(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__eafcd32bc455aeaca37b82c5043ebc85e00f1c107da788aa9c4db24f3e65a6a3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7315cbe4601e6792c93b3be6212d31efbfc7bd0c11ccc00fa782c1bb835bb1c5(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecHostAliases
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d8db5261f58d05ce8ea51f98d1ec6096a50b05c7b0d94bb7d5b244331d8c09a7(
    *,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e1596b5603430a9d803ba292c528cb4386bcb3b70c5177935b613ed698e11242(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb3071bfed5b9d8b34b0834c03fa1ef5201523a4fb1d0ad9d00e92a0e14065be(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__14fc0bff5c9fbcf3f51a5c53e7f257eb07e32d8408e70dda7a8c7674ec5b6725(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__98c8b7d81bc70b2e84f2bfcec8657d3696c8a466a9ac1e5d07cf91d9b4065d08(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0b3659faf8e4aa4011d99d76d1b3c5b59b53ecbd681a18b9c9c35357727e173c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8e940aae8094a9390c72856e7f2cb9cc8d625a248ae28412937e8acc2b27f472(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecImagePullSecrets],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__10427b4873fbe92c3863485e42f9a2bd575319f84583df53c1c5808530de9b4e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c10752078b55cd5fb103a7b14936a1590ac09055ce80ae62e6334ed95d72aed6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__31a9adbfc30a87d6a4a8a5d8559879b1b8938ce5f1f7ea5e71732b48acb51156(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecImagePullSecrets
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2b2a41f233e80a9d598e66e8b8fdfa97247ea2dfa29f42dbec16dfaf07aa710(
    *,
    name: builtins.str,
    args: typing.Optional[typing.Sequence[builtins.str]] = None,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerEnv,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    env_from: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerEnvFrom,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    image: typing.Optional[builtins.str] = None,
    image_pull_policy: typing.Optional[builtins.str] = None,
    lifecycle: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLifecycle,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    liveness_probe: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    port: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerPort,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    readiness_probe: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    resources: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerResources,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    security_context: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContext,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    startup_probe: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbe,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    stdin: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    stdin_once: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    termination_message_path: typing.Optional[builtins.str] = None,
    termination_message_policy: typing.Optional[builtins.str] = None,
    tty: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    volume_mount: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerVolumeMount,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    working_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a7179179f420ebce527f54da187da3e397ead8a41eb4d82321e9c96dbd4cb13e(
    *,
    name: builtins.str,
    value: typing.Optional[builtins.str] = None,
    value_from: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bfa795e62cb3b381316fda2404583ec895a8a80c45ce907b6c6c9b0e29d94f3d(
    *,
    config_map_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    prefix: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a4192759429e150eaddea7952b2e4b47cee782a71544b181aea315a0ea0146d(
    *,
    name: builtins.str,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__feed35e87f0ea794698ba78927fc230d830a1579c33b39c266bbc6ea290c4f7a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f0512f93a9943b4f5f3f56f429f5b8b59595975a66fddfd587c1532a0c9699a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__754eb4ba82832077cce6f150cedc882aae833bc8e257fd840c786aeee3f7172e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85e424dc410be4c0f5f374c5d97d9cc00268144734b92fce301e94147bb546bd(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvFromConfigMapRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e77ba9b33fa100e886f0fadcb735d75205d3448f8763899484dcd3197a4e8cf9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e2f863f228bf9f13d55cd52dc8d8ccc818a827ede88116be3f3784ee8eb53e25(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__60433d39fc6b5634defec69f46054e96137736474f84fece933044abbe8f1f1c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f04c699dda204ce2c885fe409f6725b3837dab5dbc95f4598ea80456eab43611(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6df76f8e93c7c94bc8946a977ecf5c152317c5d6e416405ac5771b1229414a22(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cd8fbb20f1f17dd4dda9b5c243fc5c7fb9f19564986057a4619b42aa0d4753ac(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnvFrom],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c88a2a38588a9726e8b6bdf8d42f7a72117007ff2836bdd91f5bfd52275511f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__abba38168f93b9e83efe3781967d2c0b2b6d184d37e7e27e0f975b22b3497ece(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4540f2224158c98cc3fd80f35ab549235c69ce58c6509a502296d3bc461fa0ff(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainerEnvFrom
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fd5e71cf85db640cafe50d9f62ed7c5979b768685d9b94ad63557e236859398e(
    *,
    name: builtins.str,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca92a17266f31d0f97bba21a535e2a55bc99a858ccd3944dab7a01ef9db1f66c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f36ffdbb8362f0a13c9f02b710014bb327775d3baabc92b165e2d8edb8dfb54a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2e0c3d7ccbf623917fc5e3deba0b15f1b1c8dcb4fdaec4e99ad43057d5c63778(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56e85fb1cdc890cb7647a835459929096c13914695f13bd966fbc71ad5483c74(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvFromSecretRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7d3acc3058bde3b7a7180ac977afc571ae2b49e65708af0700e810f1372df1cc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fff76ebeb69614cd34fbc6327c4f7ca8013bccf64607071b0cde51252f648ef8(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bc65fcec264127b0f5c89f73a67cceb85d1a364f827f92b20f6bd6dc4c2ee22c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3235e2a808b86086d6296757a533b272e94766b6c7d29aaa777b9c6c94abb9dd(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__626cc1b05282d33d7f93d3ef37df4f8668bce2f5ab5c919c27f7224df01f2230(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__07cb110ca8a43939f63fcef4cbbf6a5bd0d2594921343802dfe574e8faea51b7(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerEnv],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8242c0f786a70f39b5982cac6de56707c47008139eae498c0c45e9fd28251b91(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8725c5238ebd978e7b8bb3890cc3412d077b1f9ccaa93d96d325e5c912e9fa91(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1026242be2536362059bf20b14ef4f4540f9fdce5f1d8def2a69580e4f8da1a9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__71b1d6829f20796c07b4715ab5a380f1d203c96c59f3145c6a3e59c86e35202a(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainerEnv
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__815073e145edb2f36ba63d7ffa3b4bdb0362c40d3910eede4b7d14fa7a2e2064(
    *,
    config_map_key_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    field_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    resource_field_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    secret_key_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__851aeb83325004e6a711f860ee32f3e039abfd9f0fd3fc6288f9ed0af2c47a4d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9a4768322f02b24c583ccdf0190f97e6b06719636c6ba4e38724b648d97bea31(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__43a5a04f8538b432e3a702b3b6a093fe3617d72d1eebe6b11c50ec09c71d0491(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a83a235a17f0d403b298f8f5ab50e9ced23f6e4e5fc192d7fcce1df7da586a2d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__854f2730e90c874bb9d97897c231e062573fd79e69b73487912a482570cb8bd5(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__623759b2201e138f0a7da8f1a237790c475b9c21955b66acfe97d4a2aada589e(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d85d651bfe9bdc3c92e9d1853ddba98fe13bc2a51b180ebd34905b9c18cfefeb(
    *,
    api_version: typing.Optional[builtins.str] = None,
    field_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__49cf700f1abc5542a8b03ad8a7ecf987559c286f8aafbfac524f778ed83cefd8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__92b93249d22d2597f62d2303cd9b6a98d61be2de11f679522c89710830d32a8e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__42945c17e4cd2837def7a5abd6a7102f6919fd73c0c63ad0cd590b08ddfe49c5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c2777d6dba36b0ebeb891c531dfd6b379588f783e516306a1838f7570fce52f3(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromFieldRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a3a02523e9af29f897846a740b8f26f6f71a2dc7374b298ab2faa4c665b0da52(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__30066a807c79019cc62bdcb73e56e1865fc65836bdde8c607e4272c07513810c(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerEnvValueFrom],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__21deac683881dedca573caaf092cfb24d3ebdc3f7d8f519c1ebe8a07d3683c8f(
    *,
    resource: builtins.str,
    container_name: typing.Optional[builtins.str] = None,
    divisor: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fe1b32d1b30de2f948486c72c9ccde7af455ea2ca137cf38404b6e5aafacfa8d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__09faa7e6ffd7dd2bfeeec18c0aec3af8457557975600af831b9e509b7a8e0a2b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0460edbfaf26db4267e05d62d3eafaa48d06bce32c35feae1c3e4816da140c4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0def6816539344111162a5d9b15dcd79f35c9811b50e18fbe4e08a1474dbd211(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b941fdcd4c964e029d68e897d44b2d1d0c2961b21ca6c86f74228cce3ec80ab8(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromResourceFieldRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d6b251fb60015a450297feb4aaba4b64d2ba59968e18b386c3f3fb144349066c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cee26406bf55db3c444617774e6a4ed15d1958a050efe7eefa917ce7a562450f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d19735776bda5e5df2d8599d216dbe4089729b609784bd30dff044c3d9a62fc8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__93a3e0b709afb5ec4d4863a918244290485024bbfc43e43c874043cf797ecf85(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e7333970abf15ef5ab7a82dd6500184bebbc02d865fdc7f148797bd6971be3e5(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9136ffb8dde37b21da5d3a101dbd9b69654075d8c7ce03baf9152107484c84f4(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerEnvValueFromSecretKeyRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c8581cc53d8b4f2f9854dc25fa24037aaddb02f4c8045b3e0cc2c16e9538b7d(
    *,
    post_start: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    pre_stop: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c9f56fcdeba9a5084bfbcec56adf5ee107a2d8f32aed5ebcec03aa6659a3e539(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9f51b44b9015ab8933df76101b10c4353c45b1f1f2a8626395c247fc49f69fd5(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9a80aa2c913a03acc2a31da3b2806db1b6f6089db7a086c07643fbb25c22c37d(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__87576a03f310c15e18e7809497d006a6ba9508ad836d5b215297455da35fad19(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLifecycle],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca012f3a14ae2451bacc9ca4a4903a43c1ea3e08913a24b1a3b6d814391aab80(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__027c8a8be5f03b135db5b54c1b257398ab4c906e026a64cb58e22b50f153d41a(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__de3a79e49b3b1c127da016fb4273cfe41ed30a52e13e1e0b3b59ca3451fcf3c0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fcaa2576b766f444a448884e47327e35d3550516edb0c83108a5f576fbee5e62(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b7af6eb32ca4349391f0e76d86a906232dda0c7460233130af53809559be1a8f(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartExec
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__604cb5618d07046ef78dba4974e5071df7bf2f5cdf11ff55806c057e4ac8d311(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85638a0f7a2889ecfdcc52ca577ff92e7e395c0a6e4b9ad3522dc0f4f350d027(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9f3b3f35e454d7bb06a2764b64a9f64e2dd16013c44e4b14a1cf3984285414e6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b72b1a715d32033afc236934dab97c04fe75da879a1e3cc506c6da3e30f93de(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b022ed822b96ce08ddf8f75dc235c2aa56929fd3c3d604e6d8ca07303542247f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d6df7d25afcf8c16ccd024695a78ee98edc14bcbb9e6c09f5b839517fe2e06d7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f694166ecf21b51bac1836a1a1a661fc20526542a2345d3c3c5722606ff592ae(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b5ac1deced68ad122ecb39297465cd8556b45c5808c29ea6073c94604a9745ca(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a91cd2a55e37415b5bd73387a290a3b329747cdf0b1c651b8454a7aa060372b0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aada35cfc0c8a1ce025040b99671056e29fba08808f552ca561afa418be4a03c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7946dfa2e83f5fa070efa112e59650bcaa3f3150b592cad755f088d310af884e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__430934791023faf4744b922a4172d256c13a7444a6643bfa880d08aed5d73c7c(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5f2e711140fbce27f43e0b75dfffa9d308c087f3a180d3811a79bf507b2c0d32(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__11c7517835228c54c5e4c8797044adb938b478f8869fea5e49a7b04f82a4ed98(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d844bf9a610b783335658d25b4f901c19363a40ded026a8409c89adf115c5c95(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9a5d651179dc2a25f370e7940e4e91995171fba448c4405568890a8c21531e3d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__31b88c91e87e1c980bee17ee3e97144faa463fa18a22cd76865a945ee1bff2d4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08874e6a18f1dfc7b29a6916743acedb0886c5f9db5f8469a51c310a55754ff1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__751282e397bad8568c336187ac520ad209a14ea8ebed3cd8ae2918444b210aa8(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartHttpGet
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c5de61f3c114d9b698a960ff728515400162813b9dcd467b0f6926e53b902c1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__405010d38bb57d3da565e1fc65095e7c79cf8caa45ef59628d249663535c1957(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__36a58914be0a309c155b0f88a0a15ca2d2d16d898b15ad31a4aa23cff994a328(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__730fd0e57d708cd43ae813dbca2521b0d63a7f38c30ebd2e09d0ec7350cd6223(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__644a2ac8087893276748f4c77293ce1608ac802b013b0c1fbac6f4a65cff6cdd(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dbdfab0fbcb5dcfaaec4307706c0a4adcb874b29f395cc520f55fff76713ba86(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c0959e242534f2481337ab367af2c6e6efc3de2d3326646f008cf4f2b7e29ab4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2f2e9281824f819ddeed60b3d72a2ffca98a68e6467eb6100108a5ea8382ca0f(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__636a5a0638a904978d598768b359e26430b1b5c3c1564f313109c54dd74fcb20(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStart,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd1ab3a78718d6e367809c389df0fd5d8ab1244b5b76af6f72c9ab9a589f1e53(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__936151da3bc74078da43b41b243c01260d8ebfac321a56316277dba88e4e1a0a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__41932a71e89441cad0af001e9121b393c15fbc589e1c8516aa5b0a17ea296148(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3ff5dd8e84d7fa534583dbbf0729d9780968546c318f69699aae4eeb420992c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c7810c2aa38305cd55c63135abbfac4e20faaec1627152c881995c042351df9b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b9919d00ebf2923ecdc948897961ce0790b1691e55cb2a8eee006e884ae665c5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__61bd3ca0d595931f8c4fec50d3612bd491498b012dcf235aea7e29788bec3492(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a130293d53a8f61e746d50fa482629e2b45c9cde7c49f6dc64cfd8a6ff2b0b7b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f4b68ae21c7884bfd582e5eb487ff9c65e4924eab59dba780e2c09b16c5de376(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__210d15285c1d9e915b2c761e37547db74177b75916e9a4c874060b86a98fe898(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePostStartTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c7a6a4cf01bfa746f1d5fce3c4627319c00e2c1f9d049d187df1a872fe2c82f2(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3e05f309a17ee425d2da0990e10fffd5fe88dc6eb69129b7c5c229f6e1d68a1e(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e5821bf15edfb69ba83872c568b6b975c52fb4d90e87d55ee9bea6a31aeb7329(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d5599e8da8f43a1abbb6f7ac64c3a64132d651de12e18e35b44c059134afbb38(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__06b23318f1c401206ab7254289e6ef1df140fbb4454429ff492107e481ba4b8a(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopExec
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__68643bbfeb9a867d3e9e80607acf4c38d68a53c0866b50f703f9b58eb83ff308(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__690a2d9aba065d972aacf5b9efa3ae022d27639f39d39653cb012f0416fdb922(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56bce99f8a917b57e3aef35e3332b8a40e65e3f38e1915fcc20902e6bb0fd2b5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9117a26f77dc049f6196c2e03c3031b859002326aa9e45a7b76f94eac3d32134(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c81d78743dcd881ded8b77a649b8351af84639e1b25d70196d7e750154e32a2a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1365baefeb82c9c2d7082a35a28eb49422101d19a87af27cc67b764d70bfd86f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f19e6148b620ea88961923749af220f4f79b0b93ed0fd1372c2976e725be7715(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7591eb5927e879e0be1e9c9be1dc83a399ec146d24b61b142d34167afb7cef8c(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cbd3a2b2d3a90c8aa9370abb4447e6f95e6ca36d8bf4fe029339502665bbccfe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__987e599936585bc57eb5562ef21fbf7714833e83b6ffe5724dd16e4d17a403c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e759446242b3ed53e52c1c8d4376c3da6b2d45be6955a74781d07cf0be9b8c92(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba7c3a74e074d4a828afb4a60d51f972053a0245706ed7de3f11b0ff615c5c3f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2538d346fde778392e1486601b81dfbd605d837bc59d64effaaf220ac9655567(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ebca07d31bbc88bb6346d85a1ffea169bf6fd50039de175b195bc3e5a9a41e5(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7adf8a3d8167a83df725712089621e704df8f0430043f0510686d8a5cd9c61a5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6fb1867af6cecb2bcfeeec63c56bd1fbb6126e1d8c91111d517d8e2fe269b9ce(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__89616624acd45b43ae4360fb76f463fd1665dce2c7d6bf2ac05404164d86c81a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac2d527c657a3262492f52ab7df052279129e1dc945f6687fe5a716f3e4a33c5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd3878fd3e0f1fa4581edb2785af1722915fa95b800dc8ddcc8da1edf2da0898(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopHttpGet
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__854cac80f8c3403cf09c56c60e628590400adc3df5221a666d60a08ed5bdeaa8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08cf2ac9ca0219e2964078dbd2e471d561e362a8e4059a3c4605a3eb395bd943(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__55e6422de1bd15fe3e593f83a1b18bb557ae556a36d8689e7c85bb1bb8880835(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97ce0e8de32712795195fe9b66c391e7fd1168a47ac47e3e1890363f9952d601(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__46cc91d4b1fef7581d5940930dd6441c132779b2f40f3824071e0d36b7b87b10(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bcfe277e86049a9eff6af5441b861045a927baba73f27e141cf72fac0d6ca8b3(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__02edb612285733ca1e5bcd950a1f378a845d69fd5bdd10f18e8726941f8ffc14(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e1da2cdb15b7bf6d674e46da1f9339462705bf9de521559a7da9101887fc4b46(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__80d1977187a2e3ee7e256cb6074c2f4de8803a850dd7d5d850198eb72989937a(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStop,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3aff8c08a4071e29d9f5cbddeecfde02ae6f1fdc5d911a644fd0d121a010103f(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__58ee2b8359e099874a4e7ee31ab8f5d64a73ab425e91d527e244619d07b01806(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c2e637687dae7cf433aefb9d130f86742777b0fe8e1dcac5ac670b213368df1f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4758fe952bc7e72e20837e08cd885750336c8d3cc324b0f8a1e64c4a672454e3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__db58a5e1f75e6d2920637c3c8eb101663595b03a0218372648d366f284375df9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc747b9cea53be313f00f9b4ac9fc6a4ccf20e640700baf4df502651ceebb58f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf16c1be46cd59c038f66edb4ba7542f9f44ae56a4c42d7cba4a962b4256d75c(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0a46babefdea67c67063e23908cc88e94e56e237b2fcc115463153453c31ca74(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bf0744255d47f5ff8fdc3a184fd54a82c32157d81c36d1270ed5c66a247ff246(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c3e753ce67e5ec1f8769d4b14cf055efa45255c1fe838b269af5fd35b2ad3b2f(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLifecyclePreStopTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3b7ef341bdf751013f3d1934595ebef7a01ef9560411530d2a88440bfd7ac8cd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f5ff6716a1648e4b58c9a70b991ea523ac7003c527b9f1c4c68360973bcd85f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__da4fa82536beddb08b25f5bb8620a95f1610a2e54d23b579c81088e295a2b5f0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08cc2febb52c96bd1d1bd965bc596441b21b29ca4c154956499428243b4fbcaa(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f299a2c2ad9bc74d1adf0b12df497572d649fca93e5a447c53777a3c6395dc20(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__858e6465a8e7b878ebea8361c3f3903d34a4f86533ed8fe70c39e6ceade85c1c(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainer],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e7e57ad2b1f5b9b1cad00f2444cf1b0ca2973a0381123078a7e90f7159df9331(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    failure_threshold: typing.Optional[jsii.Number] = None,
    grpc: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2d7fd4d7c0dfbe0c90b354a956567e17ae7485054a52c74a025cb244ebf75692(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1aee2f8285a6d9b6aaf17423644d4b67b398f62a5e8697e6b55de4693333ae92(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0900a9e3262fcb1ab8f35d28da88bf74c104722cac27fe04190caa6ce85f7d1c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fafd6ecd9e9449f5b40dd469bec62a376b8e63fb01a3a0077d408d35b9dd7450(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c4d91b8352e3cf77a76b490cabf20616b63539dbe23bdfbf33b6d32857a32258(
    *,
    port: jsii.Number,
    service: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5a53903458f7419a1dbf4ffed3f8bc6df0edc42c2ae1afb460068ecc457bbb4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__313d47a4fe56a0198ace22d2974ff6a90523e3a8e3542257fdb30b72e5d4cc8f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__07d919e27d1f76c5a46631a762d2ed1e3030fc7bda1aa0e3e9dbf567c58ca32e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b7bffa88890dc0d9bedf859c99a293fdbd2a5cc91c46c7b5fb7a40d1e70039f5(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d4d44fe080a4e301543d17b5fb5301873e6886434c620c648f8664bace10c3de(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__587ebb8df0fe0b702742d8b70e44ecc49325470c615ac7bf80728c813325a131(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a24245e1d83a431c0c3effa6b0f14e5b03b9a0deadceba3419bbb128f71036b8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c50b65f855b858e787b80b2bd4992926ecd3f24494b76f02d2dc72fc4485161(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2ba6ad89f4c4e7c461b419f6aaf657dd4c19058f7a3c47f6043dfbadb3154341(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1e97e148ba3f486933a8e18ea8f1cbda2fe301f915d0bad7300a14b976c0df67(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d12bedea2baa0be20c282b0d4fb11fb9589d53721a5534f7f09851b1f13c597c(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4e3046107eff97325078fcd2220553be8e044290ef061aad62806f073a06fbcd(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__90ac009a2435f1542201b23acb8929bb95e49d9cc8c9456944ac0447ca1d5791(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8106d21ae6752daba5fc4cc5eeaa42125086f6206efe183bb0b3e8d9059f0d91(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf6dda14374afe46c5369105b45425886cfc835f3ba423471e5cb5a82bb4540e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5dba40eb0dc0293127290dc4314e906f1102151f13ebc08eacffbb93421d8cad(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3a1b2b0c455044fe36425c117bfc167688f66349842580a02a1c4c5c78a72415(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4e9a173d588bd4b08969f248cb314a8a5afaa0005499b20f41e9fff935593ea7(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b48130e147405f577b4dbbd11bffd7a7151528af0d66edad796bd9dacdb95502(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f67e82e45333f1cce21f9c615c01c03add62edb36f42baf979b831630bdf7cd6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d5a5567ecc9a39d7469e055f3b6e49e8603d1368c35b4d2147e058fd3b0342ef(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a7fa0904c93cb2a094eb0b8a10ee1b802b6ea74b9a9311e74b2c04ee8a59e96(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d6b3936387146c414380873bcd765bd119bda62f9aa1ac7e31eefb629102f89c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__592cdd3f076ffa44ab670e9f0e508b0572f8fc38358b4cdf0f98503242ef03d1(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__eda55fe149fdc36a8d16ca38b216abe68d97a0205ebb6d93feccdb9f26f4986d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a04724a8d6b59a66284e8aa130eb806d75d9714f78bda81b05d598fc3f92d910(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8f25cce749883806ac8a5a19959d1d958ccc5c851f7f6c2762862d52d08f5cc7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d05885ea50fa270bf8281c49de29bbcf2c4a8a5d2a17ee415bab930307fb2ebe(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9a5a6da788790779782f73f84ef17aa5aeaeab9ed23a250e37a4686aa394eb1a(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeHttpGet
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e7c89b5593bf35d13957c07a88e5e8185fd55be46d834cde9cda228838f28926(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f5d7b8618a96e51c5f8f2eeb1155618c8424e7415265383bd6c6399f70aebaa(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeGrpc,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d6921b75c6af87054694087148af68024c29442b52d6d85dc8c5d60c836a49a7(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ec9e2d10c41472acdfa07451eb4ac2f579d1f89cdcff6c134c3a19d3065ee087(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__026097f2a170fdb9c7272661f2684764da3cb7b6b57d2c0d3afc484584bdb16f(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3d6d4726c4e2190d0f246b415c0410bccf2798e1cb16990f240c7b23c9ac6d67(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5c2042d05788a5cf06de47cc6b25fd31787a6ea6e9457f9aab9fdb750c01a099(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__54db74dabf3f9b3f34060d24a6ff408e257b98ef35d995cc6a46f94eb1002665(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3d5e3b4c7026b9ccd1109d4244fab748c68ef7be61d5d82052dd33d415e53ca7(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbe],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__986631bcb6ff17f4565da34446c02a39ce4c101bcde57feb2a3624758e08d311(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__69f9f5a084f54d49f6d428924e187aacbac0e251c71815902b8566b7fe2dfef6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ce82b80473572f75403bdcd2610e3ab7af1cafed674a47af4f8460082b65614e(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__53ca3d513b27fbc9987f4811a14cbdef9c5b3452612dd2a62ab865d1604e3bf8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4500479777e007f013efb553508ca2e8a38f7218b0e254404e4d1136daf9e482(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__993bea385fd4b1890e37c3b3e06e6020924a38046e4e155268cbab59e3b66548(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ce6234414467d841f3f790cbb3399b5793605cb0cfbdb5aefd0be0ea42f52cfe(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__40ee5e87a1eb35a375be5e8adaec7b90d56366e78232e39ab9e0cc45af0da694(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fdfd8fdf1d7603a46c8034e51581bddb28f1d483b1966b373d792bffdc4e874c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba94039e0e4bc86030c78a996ccf528103c2777942409b4a4de475f326e7562a(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerLivenessProbeTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__854cf7aa98897d296f2373e491aab6e9a3c60db4081cba2a4ec409936c438557(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__07d7857081b540f58c5f58850d2bc8486a889fa5ce71d47c83b1691b6db3850e(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerEnv,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1b59b35ee7673b257416643b22fe3950a64166eff4e2962c4b847915fc1ec36a(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerEnvFrom,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__61e01d2188cf5ebaeb5f2a2f7355561894659ba72fd708a3e851082dc7521dbf(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerPort,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fd509c1fcf68507634825e9fe7f7fb28bcb45333ebfc1914d6a8dad66abbe979(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerVolumeMount,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2824307f8bc4f76b538891206546380645135c1d0ddf2d688ed25294a7a991d(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a2ce0a5f37087f9ae62070c47cb9f9ee1d361a56ec65593c5774095206a33b38(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f218a5bf50cacde4fdcb25417fdddb591a6bdab5411fccd5aae13029da45f240(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8c607d97a4150aa27747d42f75e86938d41cb525974b2b30912e5c5a9cc582c9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__393a2d38ddcdf3d807df1e58c13ff0b81c7f8c5dc14781dced9386a4fe74c333(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c6678d576a09a8dc48fcb6031cda0481ad3170d03759fe279ab3fe3f0e9d5988(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__66a74242eb3cfb9c4e124c7f6188937144fc95ac1fb7b0cedc94f671f1b4336c(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a7767b5e1f516a0e011bd61a76f3c7ef0fceabd463cbf5dfbf97f7c425a75e46(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a0c20f743230b7ec6a739363c57107fe05167bbaa86f3c8867dd69270dfa1c6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d87aab59538e19e73773bded1b5024ede285f7f9bf32fd336693838089e2c2da(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e33ee82219caabe10dc0b1c98eac9f639fbdfeda6fca009064b1af580aab330f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__38c583575043fd3a6856c74b390c7851eb37d473f159bec6e3afd3b6ad0de70d(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainer
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1ad5789d11179ba661fd847280ff9dbd59c7d67747a311e33ee3d2db28465159(
    *,
    container_port: jsii.Number,
    host_ip: typing.Optional[builtins.str] = None,
    host_port: typing.Optional[jsii.Number] = None,
    name: typing.Optional[builtins.str] = None,
    protocol: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ae211f36646aae53db0f7e49d81c14d04c787aa6bb65cc3c164e7e8891a47370(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ddf4dacfb48bfda9ba47b875c65add248e20374917df6b61e52f3b38814d68e9(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e725243fdcbf143445111045c223ced14ef316b1a6455e63ba36d52935e7893e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0e6adee863aace283ce066c57e8daacd0a9e9cf659009dec5424dfbf87d235aa(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f0aa6b18c5ee31f2a27b249571a98b067698002cd9553efd74557704abc050a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__276a1316148d20e30ecaffc762c855562f263f82bc22f71bf382b2b344716fc9(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerPort],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__934714bed8cf22e13dc16c851abb45be1e117d25c861cc5814cdc4955eb1d277(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ff56656a42302d817a67ddbeb3788b5e75679e12ed265d0f0710db78b7ef97d1(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6136021d64394be9722b7e141eb62adc2755ad529461fffbf16e8655136fe51a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__62fb9a150a54a99d68c4a5a328a9aff2fb8258f9a5b01fa5948c524ed6c6b943(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__43f4a5eeb264f4487379a2f75a387f0df6cd9c700fa8095aefd04c2c9dd3d7d5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c144e045907872e7d97c35a406d0efc17dd417f1306c4ba5cba1bbf170a991b7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d41680270daf614bff308943e659e7f5983973f1ae4bb4f99c19ecf335201169(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecInitContainerPort
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1726680c3329592bf514ddbc495487a8262216bf07ff610350f05de2aa563084(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    failure_threshold: typing.Optional[jsii.Number] = None,
    grpc: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d4afec3d0e2e0c30855c8decce6481b8c6b97d3da5455b4e370b5f2685f17467(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ebd0efde2edfc29be42a4229c9a809a5f64bcbb5015de1585f84f6afa1218964(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c619041f830ce522e01e5d4cd33ff96ee95753e91247e69a0a4c702c8812d174(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6eccf48b0639bc736a2f47ec8d4fa676adf2d90a0ec39468ef9e1bd00d216115(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__800a06f34cd9eeb96fbc604e82acf50fb3588025c6ca7c29c58578eff384c3e8(
    *,
    port: jsii.Number,
    service: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c063a4f39f600022449ad411cfc6c523f52489cb032b8eea18fe370785bb98c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb8a17da73f2352db2c484e0d9a7f4c98924828483383650042b9dddc390ff23(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a10c948e61a972f550e80ccecc9eb500cf0aae7853596dcac1c0a0091d4787ed(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97836ebba7bf79386144f75486e87afce51eb1631a191e66721a1ec7c4026952(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__37c97c9dedf3447d8ec1bd1342785c793d6f241fd63204281159e35b456bf2c0(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a6a92d7587235f8a43c4ac376216731109563a2b375230c3ca9def6c59bf3bc7(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2ba341613a7a7d0180b769c300af120cc393143f96810a00423dc34386c305b2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d6f5f18312e6aabc175541b9ca032dd2c1b4770a2625ed3f62263011ea3c2b00(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__64178ff47b245b3c2bd7d9851bbc2261a2a2d21c51b7959915a63c9a7b90c0ca(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__20c66fd0ad7b4b93331deede4547d3db0902fd2f1b8c20b3de05fbf5af7a8431(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7a843fefbf6f300663a6413737a2ad93b6f980f4bd07755a4ca79cfcea80269d(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__680ee0954269d0f4b93cbb8a50abc793d81a6bb363de988ec766bf45ba8a3031(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6b391c4ff97c43b986d9dcf0c8ef184678841eb940ad72242b31d87bceb78cc1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__700a342c6e5b9932e95b9a29ffeb6bc6a7a0a94c5c660f0f564e31c3d2659293(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e67675d882de7364f82a49e44a0fe32016d9ddeb7b3b6b71618e92eacf407143(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__854c70cfbba091551ffe9a95fb27e3c53ca53780ab7068084e85d480dee9f075(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__034e7bb08dd90db8d4c4ef0f946237df777920e44d7143396d950ce5a6f9c8b5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__831c4eb5256201365cfb4a82b3b6f19e1d8fdd48c0b91f30f3d41c798b95de2a(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f1d79874dbfc3c4b303646efd4b6231bbd05c06b94bf8b9f6302cf948012ce43(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1ce6a8aca4d4aaf89b1ea71478f6c520892a344ff8a3d06977969dceccf3eede(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bed137f1cb0f946bf27c4775c09b44ce1fcb30eb2e260f4e4049232738a9535d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__027cf02070ea30832942523d691f83c116df914517cf55299630591376ab8377(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__82207d98a8e94869de45a87d6624160190c3dd72fea6031465cc0546b728a0e0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7845bec2bb0fe3a48b55ae14a43a2dcc0e6c8f050cc10c479b7a16acaef9f044(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5dc3c663af4e5fb4d0903802059b1be6ddac53004d50585ce1d55c8dda19a1a7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1a008353858b7cc57b377d20bdda7767523928b5fe747fe16e89464607ba60b9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__656d01a61db3c58dca3b440b36982f440f517bc5a4668a1f124f5ff7c1b68f36(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ccbf24a557826a6048f87af8898c02c14278dd84b249b0ba9488c2f03cdbcf16(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a130f1fabed68f138a9791ea0d7dac437d37cd218b63e20306e065f86d8ff889(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeHttpGet
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e8cc38b7878246b91c56a6d73e246f3f7628b5320fdb1b5538e4c2832ad79b30(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__be3d6a8ca5d3c3eb08ad60ecfe3e0ee8af2758e94dde7047a350aef796e3d8c8(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeGrpc,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ffda6569d734ab79c4df4e5c3003a29461a77a910b2f125d47a74159f1271367(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e661d5638ee72c0df87e02bea8abdb1436f4e2c0af526e6b065131b3bb08a6dc(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6191a7294427529cabae25b5f9ab1d521779b887d1b85eb9d31770f8b634cec9(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f7c6fffab8a85905706b5b4e07d055641eb7e5257437f21ebfb2e79d89a5927(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__211e6720580e38cf8c2ab59669b0391de8f54bbfc5eb7c39d9756ecb7a927352(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__eb02921bafb719306d1143b102515bcb78dba1224f46aff2234124ffa018f1e1(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5bfca2c505fdc309dc3d825cc435d064a36e4d6f7591cb384b5204550fecb4cd(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerReadinessProbe],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__89e94b2411386f5d246c447e5a51df317b084b9c52f85cc3d788911dd8b4a5b2(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__16b05bf3709e7aff24b954039c91410578b1280322a58b311bed1d7698b5b669(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bf09d3e27138db25bb46e3d3acb884a503d1ef040c75e0bc952e5c32cb69e0a3(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__12298c5a43cb2596587bcd2b0b2d7f40b7f914bf7e3adff9909e1bd960779d8a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bc4cdd6f51d237e8ef7470d1cb363c708592ba42312b21319059d490bd93db3b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dee16be87d4d2db2dc614125f5bed06d2186f5c0133ff1049fb313b3daec27fd(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8f61fe095c38729b023c8a6a95a1a841d1f3d1a25cf5834f6d90ba3afe7b706d(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cec0f85ebd0da18e7799345fe3f5669a5063d5b4ed90080f680a48273f7ba4a4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f31d7c985cab5736f0e1ea5a4ceaa111206aa988e0e07bcaff7c7e40d49c24c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__261282eea9a1af17c4c429ad42c45287be1cef8ce666b5475178efa2bdef5333(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerReadinessProbeTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__04a6c3e5193336d21924c30cf372666fbe175074c8342ea230b6a8fc6b6f449d(
    *,
    limits: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    requests: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c100ed913c99c22089de35194bcf79e9f7a7bc11bcf1c86d9d818bb3868ffd11(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c1e34193c950cfbcecf399fdfb0ebb58e436cf05869c281f6793e96924da9f42(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e510abb3dcb6235448033c81f877431da8ca165bb6ad5a1547d41c1b117512ca(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__23f7c9b144fb89f8d7b47854e5c161829cc3e3f7e6cce3339a8197b0bc0fd445(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerResources],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__63fbd093abd5d824928f74e8941a04accc2ed9efe3a69d7889437d64a308a1aa(
    *,
    allow_privilege_escalation: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    capabilities: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    privileged: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    read_only_root_filesystem: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    run_as_group: typing.Optional[builtins.str] = None,
    run_as_non_root: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    run_as_user: typing.Optional[builtins.str] = None,
    seccomp_profile: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    se_linux_options: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__38eed2443450a9b898b945ccf8baa6e3bf2028c90b54f078a855d498c9782081(
    *,
    add: typing.Optional[typing.Sequence[builtins.str]] = None,
    drop: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f0933fee788811c6303a7b59fcfda86e3a5ba658a54447112e58a910c402885f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c9e5115ba1da43ffe6ed9c7b9f1636b0484f72f846e81a30fc538aaa4b33a9cf(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1408588916973ba23df1933c179a92875289ba74b31c9e28684fe486798bfd18(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__111521d4c3c657e5ac95ba893ad3ff6f19b2ac4f1aae4a6a5ef0004d542d62aa(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerSecurityContextCapabilities
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0b862239b66248201160e52b4d013434a228ef72c9dbad310e5e9b2bdf7a0b6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3b5b9b47f1d10bda4f85db0c598397d73f15a4fce909514fa9ffecdaf8c2d551(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c09d5ffef9817c6967ce547f4fafeac7303a80949dfb23fdf05c548a712475f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4873dce355576c1f28fc492dc0cfd87f6e0bc053c00eae23572a09c63cde3cac(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c582c386a7d162396b804aa9a7a0da91ba8ea598ab6568f621823a92fb4d86f1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__360119548124f6b2495ac118bf3d5e61e423c59f5a61f39579f562929f6b9c4f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ded8fb42b475bbc19dd54d3a6db2c122736a1a032f95bb048918a5338acb503f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__333c68661a4482576aef3f2029172d11eeb804005c9c302281969c5acbf3dbfa(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerSecurityContext],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__274910baae7287cc0520a0d0d113f9a44d07a797fb88cf091ae6ed721e3f0428(
    *,
    level: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dfa27a18bebf7ac681e00e2bcaa1a64f762b659fac6a2dab01cf3782d0a44a20(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d9d8e577729ce628e71294c5b6c3f7444214227bdffeb6c4ee04a28c86e88993(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__14d02ae606a0e33b55949da4634defcc854a11ec516b542ebc608e0545dbeb04(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d08a8343f25bf77c0f4c4129036677384dd9de9cab05232d11abd70c2fda328e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f61db6a053d0ac1a9afb215967bccf2bf9801ba55d6f9becd7c848e76b176478(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b3ac7914bcf77ce01d4e857b16fb4377a807e01638bf937225e88876906fc12e(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeLinuxOptions
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__24716d726e380d3258eedf27abfebc29f987d3ae6d524b5d258a0f34b6e308ba(
    *,
    localhost_profile: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__153989d69e6f89c6d37d90cb7ca0855a1b44ae3d49195b78eb0d4382f74c581d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__33bd43dcb18661e2397c8bdb155b032e6674a24189731de95285d4fe14811bf3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8dc982d50b332f563495f0005aa7324cb269b07184763bdae1dbf416acb30857(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__494bda2bd132c0c63044a8954e13613a89cd4255b90e6298e06a84654abcce73(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecInitContainerSecurityContextSeccompProfile
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a9b576b208feda386b346de2e296c7951d6a7d36614ecd73ec25c37568f07dfe(
    *,
    exec: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    failure_threshold: typing.Optional[jsii.Number] = None,
    grpc: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    http_get: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    tcp_socket: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4ad3839ff35b31d4c15b0e04761d359d956ab16545e9857986650548a6cb6fb9(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__53edcbafea0a0d52c11548314369d5de7372d0c6018b43e98741b166c03bd007(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__820590f03d66df17006a70ce5ddd368439a07b76e044eedd031b3a48c1b0e00a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f9688d568d82f10a303851d844d3e109865404fab421a77ea73c0c0debbe9cbd(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeExec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d4de413b88c671b6f90483076b229b3bca8bf2f8c98c73d9daa98c6d2b882db7(
    *,
    port: jsii.Number,
    service: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7cf2ba5dc928fd1c041381b8c7541ce30f70f74735a195ab65d4ba08613f9db2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5d3e9744458cfb40bc58ebe04d93c1aa99bf8f5e30f0d466e5a449f3172d4a81(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1b4ad3f547055509e29d4e051ff7e3b693ac6ddf31d06683ffb75fa598772dc2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5dc5d5f863e6ceb55919724f1bc98dd60d87b237b2cf55c5d825ba104ca2c043(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c12c07e93e216a99409297399933d2bc26aaf6cad575dcf97e72299aebae61cd(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a2303aaf07343248aa9d996d07a6c125e438dd5bdc4e85ded6db0f9dac2b9079(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8590c47cf61b1d954a8fccd0d1d376d48af52f028b3b3ca593ec7b9e87b3187c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ff96060a23e0a9dbbc11a9d0a9ba2017ead096e898a148d9c43b94f20692f883(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__00078c595e6ae1e369ea01b091ea28534fbb3f3bcf5be28927ebe17b1b44882e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__141c05c05472977f9c493f0d2dec5412203c960728b6645afd651b93e4c29edd(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6a006840f4f325eeb1cc5595865f503fcc01ec23f48b099eeba931557cf9ae89(
    *,
    host: typing.Optional[builtins.str] = None,
    http_header: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    path: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
    scheme: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0b03c65a2153c9b42b4be7371bb8016a328ef5e65eba419db22845ecf767b5b(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__25b23dc07fd4e698dcbff2a44525845bb2fb9b882e7c1ca407a6989e8bf1b345(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dad369352c8bbcd6e291361e6402485047b25bc453055ca41f3f1850d3b0d3aa(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d4d01c0624e8d064f4fc171cec4b86d57842fcf7c990288a53e10f7ba4009a7c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c76fe3aaacc274eafb0756dd2209eb81b347e0c2200b6c093fc375723626c9b1(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fd3a46cf54a2b54c2d9a291a7fce470b72d12ac52919c0f3743353984fef16fc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__54a9282a11dbedccb818f97fe7ba588d41386bb3eb993fa99706a100f24f47e3(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6756688116dcbc42ee2ddc32c63d6f89841b0aa0cfafa9c4e28b19bd13a65cce(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2e1004158347c69649175f3c32b2b7ec800bc0338df4155a2d3616dc60a0b08(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3874599a391e2f150aae95370a3a9537577666a2a2f7e9d455f25a484f61a2ed(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3bc9d8336710bbb53668a375a4aac26f3c882714a447bf6384c1301d9e0495ed(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__98f8731ff22a98a2b835f5bf31a454d30848922d9ae98d15854c175f1befc563(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dc41cd8d8308a921be38160fcf784095869b41802360a4d3e984d39ce74fd484(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6beed6d3a999c8be0d6660151468158e78e4070fe32ffbf242540b1d6075108f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5f65c4410fcc0ed289962a489da5ad42f5c14d544921a0c7b97daf295fd557d4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__03132e625427c825fd8466dfaab6f686a4f1b15260bb94469eb4b03f88ae3a94(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba4aef1f1d0b6b73bdac78d6c27de2ab525195b88f8f13c1f8fc4dd20ebe2c87(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9fe18c7f70195c330f982b464f00600d7017d0496f064298a02b1d6c1372fd4f(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeHttpGet],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ce4cdaaa80e66307db7e68b7b3b0f82883318f78e9e3d906a4098c5c7e6b5988(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ea01df1288cb13d49d4a18dd58c566076d39bd7c8a0a9721eb4b3a6a9b5958f(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeGrpc,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__256ab80d77a227a6144db2fb8c739c476b3feb18973d760336f4644a07be7022(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba874f9e3d396eea04980f5091019e47e6e3d88603e6c5c36283b9b85ecf5306(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fd920f06ceaddd956824ae31d5ebf332d1c5429a7b656aa6d97926fdd4e5d9ba(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f1ce391722ca94c3f7cc0916f619465bbbd6489a0c8375b10d0af875baf7abaa(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c6c7d07bed085bfb68690f5cfd0118092b3cb67c50c292eb642deabaa67f8c03(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cd3bf758c6bf2304b3073bb4829a43dccbb51521cff012710105fae05e118ce0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__666ea93d64efee713532c27b7733a3e9c72b4245298f838e28c00bd09e3dc7cf(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecInitContainerStartupProbe],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6e76d91931805ea8735ef1f2aa694099b7f5f108f3486ad3633c4075171f87a0(
    *,
    port: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9e983b87d437a8ba8f97d5775e6d4e6e15b622214d49227a448d8b894e1ba71e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__33717f621aceb37311b4aa6685752c09b474175d696671225913f60c1dd308d5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7ff3274bb707ce3cc52af6a6ca1e5a2116353a0b8c8bd81125ca92a0e6b3bdd8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b47f1757c27485405d7ae0c9863649a61ddf210ea2da4b31bb9af30aa0a70332(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__23b0440a287b4756ff9a88add16041090805e61c66705f7a9cf29dd68fa23753(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f2fb44ef306f17efed10f78ce770ade1387282562e82348ee7d82f9e6af7fb2(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dc08e289f1d6a748d39c2930475c6dc04db92ca55ce450496255a036b538d9ef(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2ef62da224d428cfbc0348d4f0a59a4074a22506a673809bfd77a2df71b3ebc2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__485fc0988eecb8bbb614effd5926b4ccc5d231c3678fcfb8fcdb586375b117d9(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerStartupProbeTcpSocket,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8813cf19a91fe5de5d32b7e5eb039f71b5e681025a3357d681cd2d188031c953(
    *,
    mount_path: builtins.str,
    name: builtins.str,
    mount_propagation: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    sub_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85af27f985b813ba883ed00e749e410308815ce6eceaefcf57a4829d6d8ce006(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6eb32c2edb759d466577e34c4858df8072cd4ee311bc656584b6991ed4d38315(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a04cb05586b543989d6c24807acd2cb15d3d4c8886a464973d04ebab8667eb3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__78f7b5a8641ed4cebfa5b8f7071f72e3212752b387b9e52e15bfc05b5eedbe2e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9fe95621c88b1c1b32d07bf3128f25f00e09b53ddb8e94e9189dddc9f9081c0f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47c4b630dc6b8e6b41abdf533bbcab9462d86872f389b95bf713072d28bc1345(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecInitContainerVolumeMount],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1048ee68cefa2a4dd94734b21ada9153b63fcbceb47177aa2736d3bbed29e679(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aea9bb0c9b2dcd5c0bea09595b6875f0b24c55a8e5628bc6eb6725a7936e3005(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b8c323408ec19f57f5a6c1ca985b1ed90d2390978b8639e55edb3663f9dc0c55(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3ba86f000ccfb8282911176e7829bdafd43ab3bcfa48c59316d6193a327580f2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__101a0951cde31ec001c9696792af16ecf08e8dbffa3f562f6fb24637e24b9aae(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bceb4f22715fc3f08b377e3ff570f44bd5fba52dea3fe1484aa87ee56dce3b0d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f044a352ca96b27278f7a72bbada81ca0d07a7389c40c47022197c0c0fcdb56(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecInitContainerVolumeMount,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2076b43c3195d2147fe494b784b1f18395c7318f56ba8012dffe8e42ac9443f9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8455cc713ece9596bb8eed7e1338283d8c99cbb20e4b853f14ab7ea0c16b9d3c(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecContainer,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__17d36a684e8d2db199138edd13b23ec96dab9db20765e2eb626f0d9459312d11(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecHostAliases,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__38a324238bc47959c6dd885ec42dbaea1000e71facdc529d97d5830dd9b65429(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecImagePullSecrets,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f952454d9e78c141e0e854cb8f0d09f0492011919341bfa5014a58809007dd5(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecInitContainer,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__23982faedf01448549623fe7223c1d91b2c08cdb51071c1910096382a7fadcf7(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecReadinessGate,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f9098517da1ea2b4fabd2813c387a1abe327f81477bc3b115ba5c713bd1b0c8(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecToleration,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d09d78e1478d9aaa6230c7bdcdb38af3b76821419e69ff6d63b8d332a513fb5a(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraint,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b6fbcf00ccd5ade73c1881058dd55e6934100b7a29a7d24bbaea9268221d1f62(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolume, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__559e03269dcc1784ffb65460acc211009ac8b1d55517721f538e3c06a7348b0d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8a96266cefad29d235366fceb6d4b0d5a642e8ff274c9a39b2b2ff66e4574448(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__588c2154320708d63e59a6126efac82eb404e41e54d177626d2bfeb09c0698ab(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08302dca5f63f1a967387bf9bf6a2eb1abca557ab24fb1982b6f6577119f5dd0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__de7fe3bb4f25fc7681fcb59686dba0b63dd51bd08b57fe33bd1aba537fd9e50f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4791fd3bf369e79ad149b824bff1673b1a0ea62df2e5d67b5d9e332575db39ac(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a26a380059ea8969fb86c55c487c4638d15267d7535a9e185e7d372156ac667a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b1ee71ea8636841196d41a6dbe187f61ab451d7463b73a221090859cb4da490e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__82dde566511be2179868a113b90c652ad573e8a41b2e40a971e1d6cc2bba869f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__043f0301234ee08c023c4c29ebd21eea4d5633f0e75c8f7a8944db5d4d575be1(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__244eb0a42e80c5849e34b11e630f3ceeeeaa16246d9cf52f588255e1dfec0916(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7b499e094ee7316e2d51f703ec39244e2494bd38555b7db131aaa3385a486969(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__46dddbed3f456858695d043a7e2264cea0f67bd68bff2bf29e7d1f182845090e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d10e874d911589032e5fb0a96662a147de6e03d9a43c6e0134a77e4c78d63d36(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0a4a0a91756a4ed533941cd3dad3cd0f48a39161aa5f8934daf482de0b55f7b0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__985505ec381e202db13870ce7b24bf5adff9a767a8a6a26e510d6408bcff83a8(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f5e8a18cb6b2c2b4241132b2fbe867f55a996b9b31fe01bf1ab51a81ca12d558(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7179f51d746220fb53656be243eb01011276e6ffd6b8b440f5c0a6093b47aa2e(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9b0fb85ba7416dc921a1a7236f9c639dbd1c3c70ea5d86b9996d052f159173e0(
    value: typing.Optional[DaemonSetV1SpecTemplateSpec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4e31565c3cfb158f201bbcf3bff50993a15c6e6f4ea5303320f9c9a81e0cfd07(
    *,
    condition_type: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ce529506e6fed9917a9206440fccf19d79c44b1e5be9f66d5ab768c828376b75(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c2c9ed47dd428fb85c68b4ab3b3ecb737b626bad8d33848b373c7a793f67ebaf(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5741c115b499767dc31d567234e9eb74f5eeb1cda2dfbedc66a0016a34177a2e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c26c067b6e1fa297749b5affb9194deb1f7232b1241a698dad0f479ded64576(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f6068eb0773db5754410902a561fd1a08c9f6fb81af4e3a73d25c320f2ca698c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__badca0a77f4e99a0d8dfa979034e0eac5f205684baa5fe795a291fc0e82f167c(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecReadinessGate],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4d4393f3de60d82daca69d0e670892abefce15664435c932418cb90931a87033(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0087491f5567377e6beb3f52c6bb89d48eb23808522da8c01cb3140e70b56c80(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c50d28919a10843b7ce1d05ed27877c432d82d5ea596d6cd14449f778896a570(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecReadinessGate
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__25a24d7efa59128a3f6df55a93601ba341be320362950983d55022d891d17203(
    *,
    fs_group: typing.Optional[builtins.str] = None,
    fs_group_change_policy: typing.Optional[builtins.str] = None,
    run_as_group: typing.Optional[builtins.str] = None,
    run_as_non_root: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    run_as_user: typing.Optional[builtins.str] = None,
    seccomp_profile: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    se_linux_options: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
    sysctl: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecSecurityContextSysctl,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf12c96da5f241660c2f734bc28e891c2829d0a195874fd5fc1544692eb25dcc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__33a646ebc2ec1177e7808bb7cc65d4ca71d489e9997176bdb1a71905ef4e752d(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecSecurityContextSysctl,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__afde25ef097d339155a4aea0d6c02cab6d3b87f1711a168fbab4d2c901007c2a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dc85967d76e01360523f07ea128aafdab9e8e201f50b7231574a465195805dfc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d880bb32f72adf197b8e7f189f0df7893fa2c5d15ecd6a40fe63a518974895dd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__65cff982e3f9111a11fd02cc31e90fa8d04c670261261d56b991e0994a07c119(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c2b0e540bac2839221bd088ea263d6fc74167aaa9d5b7953c3dd2732016b17e1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e28f1454c0fd771c12d8301e5cf2b842bb5ca125fe4776ad43b68fb05a328115(
    value: typing.List[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b84495a979b183f26e3212631b1f8d1f3578261466bfe35f1cc7f8cd1ec92ba8(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContext],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__561996b725a1f5fe36340c70d2429aca9b4fb37ea9b3d1674853ffd168f504c5(
    *,
    level: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__297ac5b668136abaa7f04f573694f3f3009c70726b979036a49f85ed9ecb3069(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__57e163bcdfe17f45913e3ed0b76cd5578f898e40b105fb49eb84773544ce5ea8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6be90aa7c8f76073a30c70edac0e02f8bbe6c0a5e8e8390f0cb262f2ef5f81c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4647b1fcbd237d2e78af0209fee9fc303bc6e1c7dc55d560838882b58808b5c6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a58bdff3cec61591d4638b2ccf7f5d2ae15a4930fb4823826e8aa8667fc5986(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af5d838405722dd2fe508359d721b23ae30bdd9ee2318997d3377f37d2343b2f(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContextSeLinuxOptions],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af316715c4ee3b50ef5724cd92d6315e5dc4714af2a56028e83873b0b0d67e71(
    *,
    localhost_profile: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__90c9ec9ea385c73bbf2490e98bcbf6c222177179e44f357ca445bd78202f722b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac31f0ff8b8d8d07df3342a139aad55f114e1ac7e6e83320733031a23541843e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56ace8af50e9e0efe632b9ca1e860cd882540fad8d864e17891aceb069b98ddf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__67fa70ce09dd3758325571198abbe85ce8041aad0e60760daf8425195ec6ac0e(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecSecurityContextSeccompProfile],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__14b767d4813dd9fd4b2128f334f4aca098d31eebdead2533eb6142866fcded14(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2290988818a82ec4b97ef79ad7b26e19a1ac7a7adcfdc9a739f6f956ad2e612(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b7063931ec3944ccf92c372c7106f879877769baf36dd0e276bfc6dfc6387401(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5707a2971ab1106334e5f0c099238ba54900e2f1bbb4a8de1177fb7260b8188c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ad1e777bbf4ceca5e444d8e8e9159af436c37587f4e8417b0fb9d818a7077dcf(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b0a969ca1c8a2299e397d75594670ea4687c21604dfaa4448a5421516865017d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bbab246f8ea62d991e7b56e17c03ffa589bceaf4f689656c58c484a69bb88206(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecSecurityContextSysctl],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dc725c6a06024b23ab78ba23eb1fc1c8af7ad606bb80745fb96021f009fab69a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__63042bf015e7dda16e3333e67a8bdff2f58c251f71eb955b57c35c2f083c1d6e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__27680014dcf85e4a3f8421a569d941c662042593bf0aa8ba94ce7aade4f6adf0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a7806c2fcdc24e18e49947c58c2657176856b98003421332c1d1c8ab0dd78630(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecSecurityContextSysctl,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7e46e5f6af8727a33a738e2746658878c99f2f34383dcdf693d23271b1f0972d(
    *,
    effect: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    toleration_seconds: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__18ff4b425b05766b4dff654c84442572668969de2448c171331b9b816d1ae131(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6431c2ca2ca6316082dd2c44d43357d27eda36b9cdf3ae92ba64ff5fb0bacf53(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f9e239f706520bfbc112d83472271318c2c564a7445fa84069079028362f3408(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e9d3976a0f27d54f383929b410d734efaee7cddb20a34529c3397b569df2d1b9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9f7c433c334a489aba0cc1a0dcbcc5aa4ba2f773e0c93780273d9b1ee3729e24(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__52e8a154eafc8721f655620d5f855faca799846b07349a092a8ff62cc3e83aa0(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecToleration],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e792c73e4ac56c5e32e31806e6112aaac86393ee5f6a65046de2824fcaba19d4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__87e571c407e04a65fc8f85d798cae2b8320f779ac163d6fd5270db8f8cd29360(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bf9fdb37997ce60b58b98c81a82d9ed9493357389ec09e93bdf5357dfef00327(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f28e69474d581cc9dd6955a90ebedb7587ae2605c2a265900cbbdcf82299bdbf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6c8ddd5882ef3b36ce5831210269c7033382eeef75b9b83add22facf260f7cba(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3cf22d4d102ef224d15fee2e188b184eef64da76fcfc4e4144f51fb5960c75f3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56093b63161922cce76b4b9dac22870e7a8381b107a17edbe0269ce0f2dda94f(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecToleration]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9946af7fdd14a637758c38973a9b0e91bb8bc14975dc12458cd6b9a5afc939c7(
    *,
    label_selector: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    max_skew: typing.Optional[jsii.Number] = None,
    topology_key: typing.Optional[builtins.str] = None,
    when_unsatisfiable: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d907a0924fee39c1dc56a5de289ec8810de198dd9918913081b84edaf93b42ea(
    *,
    match_expressions: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__939f4070a7ef9b041b64d1ecdc72c82efe112d0dfec27a9b025d310172a2db8e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8321f5a0a198b8bfe2a633911352309721ee7b7bde297f585e1e60188027833f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__93cd3c27f3cce9ca60f7f81ee0c81af7f06a57d9768b82f5bc644c8b35729ee3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15809b8931e241e11dfbc8f1f59904407f8e6b4fdc2e4e8dae90880f3274193d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__935f962a3504f623a741ebb8b7f7fffd279f821d1c4bfdd73ef73d61b0a0078f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__398aa9668bb9591012de705be31093ec5c238d802a72be2047bf298df1673662(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__be21bd956af383029f07d65ba7bc291b8fc30d7c0a05afb610fb7c8e10dc0985(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3b3c019f0af3d277e894f41293a5a3fce7ff7fc4eb8a828c7639a07bf475bd26(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a7585890e3ffd54e6500a7783fd4226082f5d68ee6772aaa7f743b78e0972ab6(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b59bcea9bad56c173679841191b382edc57372baeeae1229a35984cc0ffb37fd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c912c7c4a187f9ffefc7ea83b7e9aa093699095bffccd9c9ce11135f134215ed(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8f8d26cc1601a8de4451689f2acc11cd12a3918f082465a5f9efac416054a8f5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fd9aa0a9cd9d0a4540f2c3be85bc6e27b2179011aab19bdcc5ac9821ab5c7406(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e3d5a58826b0ffcd0e3223617d136e3de3df6be243779a8580b46117891b7a9f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ab9a7b0a3b59a0a21e5a5e58de20da255f12fe1e953111bd726c566833deabc8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ffc6a4e08be57bdab480017f5df3a8a66eebf146871ae955624ed0df3d9e24bd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ed23aaa456d1a329ec5db56b5d536efcd8d3ba234eac952374574c625dcb1cc2(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8203862bc5a7f1697fbd7e930da0ddeadd825dcd3cb123c74d66d49ede1f49aa(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5d97d944dc57fa43374e91bda5224280713579ca646804f719acb1a35ac36a8a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5085ab2792921a9f05ef0b6721a60b99ccb90ba7e5b13058327a909dea62bb6e(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__266117cab75c443e016ac5be1fe96d8d8be35cff695399abb7194722885d7996(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e334163b3d411a3f11e0d8bb22a6299a66416eb77491534343b54cf13b0cfccd(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2e2700ad81a4c167144fbf607c85c85f3ae8412636cf858ac2a45362eff8b70d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1955f697541f541bfc7c2e8c29d97b3b54d469a32cac0ff17faabb8319200698(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d20a329a46b959e5d32619b72bb0b1f644ba7a26a89934a1bb19dea172dc2157(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__190ecda199b744d1c001ce08973545f48488918ab1bbe447ef927d23e6318310(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e7e8dc03fc7833373be8d2106fcc0add90060d3488d7ec2ffd3e032461a37158(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5b4b292e83f9807441810878d44dfad191e73f16d27729d907d1d2fed356dbfe(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecTopologySpreadConstraint],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fbdf2a2624ee24cd61b0d497145044f7c2fc445ec95b641505ca29f7119daf42(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__65cacb67d1b01a257d24bedd425bd6f5ebe2d9820f02d2781039bfa0b2bffb70(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecTopologySpreadConstraintLabelSelector,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af82e8fbecca1451eb43984901bcc34a1c159873b385a8e96820c03b7612c136(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c5ffb607fbf48ac8d23415029f0816e8171558ec502bc497886efcc97fe57760(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac761509fb767535b1f1ec272aab4e2a674d1e851245dd26440ec3b62e4634bd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f432815bd3c6c3a15385f3cc9a220a42ad05681298276583302edb5912e293c(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecTopologySpreadConstraint,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6ddaea26d1f41d1995c97e0cab5a6c2c04a9833a0cf50fc1130352f65593a607(
    *,
    aws_elastic_block_store: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    azure_disk: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeAzureDisk,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    azure_file: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeAzureFile,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    ceph_fs: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeCephFs,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    cinder: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeCinder,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    config_map: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeConfigMap,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    csi: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeCsi, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    downward_api: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeDownwardApi,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    empty_dir: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeEmptyDir,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    fc: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeFc, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    flex_volume: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeFlexVolume,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    flocker: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeFlocker,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    gce_persistent_disk: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    git_repo: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeGitRepo,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    glusterfs: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeGlusterfs,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    host_path: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeHostPath,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    iscsi: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeIscsi,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    local: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeLocal,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    name: typing.Optional[builtins.str] = None,
    nfs: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeNfs, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    persistent_volume_claim: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    photon_persistent_disk: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    projected: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjected,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    quobyte: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeQuobyte,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    rbd: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeRbd, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    secret: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeSecret,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    vsphere_volume: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeVsphereVolume,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a3ae7730986d61f2c690fbeaa73e67e78d2b88797c2889630856872202b1af40(
    *,
    volume_id: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    partition: typing.Optional[jsii.Number] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__071d6ca6c1b0070e1245cc719cfdaf77d6802980e82946017e31ee60c86ffa0e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0b324083cca13c760916fc5b569cc850bff8ff8660225ca3490eca9846f8d76(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__25b00713d6e65377b0c027feb6d5a98055a2468ea6f87cce9436a774869f3415(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c19a8ecb58644da0dab49a321be5b63e85000fd86b082f93929ad9d971f9b49b(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e09e649620e4e2f64e021e8849d3a6d4f87382b13336b5a4c63fd17b7d709aaa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7df1a46d4c5341d1bd02e07ec82baffb0164455beb9d78746b1bc41971dcc469(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAwsElasticBlockStore],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__736eacd0737422fc42ec527366f007ad693727e17d4e8de1ca2e25bd3ec4eaab(
    *,
    caching_mode: builtins.str,
    data_disk_uri: builtins.str,
    disk_name: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    kind: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e87efd917b36571360ac8a21d1f12ad91e5da422aea91e7ed6544e5435d637b1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8733a9e1de36d4d356e69304e584f1e0a9ab2eca1251480a14f3fbcc70b57bca(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f1f96235187487fa0b2384b2f807de7302029e76a56c9bc8b5ce349ad3edbe1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cdd05b497986c6e5cc0f667561269cdf2601392799c080f9cad889d3f2355765(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__80dcf93c2b60494e3e62013bcd497bcd3aacb045de1f8391b7c0a46918518ad4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f8c88db39ce191696a736e488b4065ff82871f04b6cfd20a53983098ab2ca80c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b106b46fdf887da3d2418e154df91d6e6a603e0fac9a33a7fb75f428f37b4a33(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6bf6015326a986d0d9ecca089bcff3f7ab94bd6a7820d9190e9b9182060feb4e(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureDisk],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4bef08474b6118301118a33a10f7a7e1e8b79df6b19511e921f32f7cb09a0ac7(
    *,
    secret_name: builtins.str,
    share_name: builtins.str,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    secret_namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8d047e68cece4211cc0dd130ed568d6f9e6608b6c599290aded872775e89f6f6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8e677d6ac1413967d6b69165378dd0d84c781bd45bd2e2fd4ca5753e44e0a5d9(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__725aeb4bfded1a44a5c0037a061c30d1a3eb487f98294557b448b059c193cfc1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a769fb3294fba4c9ebf2f6e506b22aa0ce4a53d880615b474d0267b6604c1423(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d303b14d8d4578f6081c93c5eb3a45d773eea6d8baaf38c5d3d7bbe2d92cecf4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c3d1cd993a489ad0863f8d412cb320196cd3d70e0989f8800b48d9bdab51705(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeAzureFile],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bc94c88f8a9e2bfc70abae4d09fe7d344e0542fb11133252f624ea467268d1d7(
    *,
    monitors: typing.Sequence[builtins.str],
    path: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    secret_file: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2f92aaa6fbb3cb858b7e28011f4de8d1f6f8ab69e550a36d3d05be1cfd6b88d4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3613cb2b6a432ca7e05b85573e9f441ef59aa5bcb3d40b50f355dadf97881db5(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d236c69511e7acdb54a4903e0e8b578bdd6b97a86e239171713220ea95d23149(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7f768e2e0b89e350fc660aa48c688eaeda4c0e45d62cb0650be8cf7757413f65(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__baf244b7344f394a69afe41641c0b052a79a40adaf748d6344684c9062a982da(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4cf4c7c27d6e91bfe8df729276422f9ac739d5d731a43fd9858792f8229306c6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8305a90ec311791d6f8b58004a3e0e786e07cef8ea47b6088cf1763161f53d85(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFs],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e33cc8acb67923c903c8e2f01460236ad10cbb796b960ab127c70bc6e459d5e7(
    *,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cfe1d3e234be8ead05c6d954f857d8196b3c7cf67edecfd2595200a9cd668a73(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e3ca5db1e095131ac479dbdeb0fe8f4965d8744d3caf0599569890a2e11e4239(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__12a68556c0d50a510be0b095d61f428f74522857e64bc65990d40940f4a7342a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e1827c57b73322a704d3fccdedcff85c3f7fcd645b59d8ac6edc77c5b3e9b024(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCephFsSecretRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bc59bd2038ccc1cfcaa45a6e14291a5f16e39ac59de8bf3bb5604c14cfa8d484(
    *,
    volume_id: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__522c117e22e513fab39164b6b0ca8c794f75a2eecc96ca2ef80e515af7e51c36(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e15ccf9944b826f745225e0b0370995ab90ed5c74a71cde483b58f456ee073a8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97d0f961ebf520fdfc48325666c6e1fcf44c4560226eb65d6efced15de003f7f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7b3482be8d4857dc53526c1a99ce4819f8483e2e13e3264edd1c1f72316f36c5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a3669b29bd35b2e019b42dec263fbf136a54de3311a45326a7c7aaf68f720797(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCinder],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__98d2b0fda4d3c74fc2621afc5936443ea9f856b70a025c9072f201e03f89b84a(
    *,
    default_mode: typing.Optional[builtins.str] = None,
    items: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeConfigMapItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    name: typing.Optional[builtins.str] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0c2cbb7e0a9781f6fe55cfe86fcd2e3e995086a8a38f0025c40b4584464967ea(
    *,
    key: typing.Optional[builtins.str] = None,
    mode: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ad192594e8cfbced6e024816d7fde60e3770b21fb0938772ea012d2d327186bc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e58d48d887afe1802eefe1e5c687341bff36ea9e3083952e3ce65e9202637bc9(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__659913d755c34a69c3e63545b99c63fe5a10065023f9b17054d2da4632dc5efe(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c25f026afa3db43246142f16baf3f605769a2463be7c188bf86a16b04cad47e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1898a7c7879c68ab47b46c3584ed2a2b82959306eb72a00590445361caa0e41b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6d8866c68be981d9af0a71fd119097820038a18f0e2f77c8a2d16f6298366180(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeConfigMapItems],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c9c3560d99653be12e2bd4e65a3ccafa01db8265f5710a0b36064caaa5f87349(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ab45df4948a1e41d716d4b8228043d48e1fd3ec268796108d4ce46a40af3c7b7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3206cb6036fc37b746a38e01e83c38fdbfcc1a3e9bfa97bed305177e9f230126(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0eeaabf89b0d99de56cab297c74e67799b55501ad624a7ec3621d9ce198dbe95(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b7469d6e148bae40426b30a0648bf2545158f1019aa455130518e9a86a9f0a96(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolumeConfigMapItems
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__755ceb42f0833dc8d9b33bafb54635c25017641f0e6991318b4d9c5b7b1e6d53(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3ef25a49280bbb361afdeef3516f575a83db64ea4259a7d21a41cef72e6a9517(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeConfigMapItems,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__add20d40d916d2c17f4620e42ee28deed72f3df7a3252ec7f8a94503d8fe667d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9ed6c07f19e3b09c7134f572d56011a16a705bf0e21a0047f00580528c0a945c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6b5a6c7c3c575d83a4da5a4363198decaaa14683851d4a031a8a996ada6bb267(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e926f955a3db96f35cb1e41f50234e6d7fe32501492e54baf0e83d26f01765ee(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeConfigMap],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8853dca537727253d7604fab068dd7328d92271b458497395cf17744a4d238b1(
    *,
    driver: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    node_publish_secret_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    volume_attributes: typing.Optional[
        typing.Mapping[builtins.str, builtins.str]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a17e87722bbb0e0daa605be303de7f519182d8836b441da82c9390a2dfb4aacb(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__eb75743473f1b36ebc6a701d3c27bc0a6a3551273c34cbe3fdb0092d3de12e01(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c142dde5be471a1e87347ebfc3857dd06b6b860388aaa42e713185fee4550cde(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__63d7ce4595a4d7300c97e139e932626df6e93c19a67cd50e90455a8350f5aa91(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsiNodePublishSecretRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__616f7e69e17d954f81120a2484c42662d0b28bd3a8895149c5b5553886811fb5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5f320edd47397ffba43efdecdbb34c6cdfabca20d8e1daa42280a9f2bbd2d6f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__36345ca8310045545346fb02dc3483b9caa90db0620c874ae0fdf6aabd68a24d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__48b71f53ef90b5c25b8ec7d75adfe1a9bd5ce0cf9b75bf9acd25f59cbe14d106(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b1a113991cfc7070ae860ac8ee4adebd49b25347cf4f61eaa1920e285e3d0042(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e446d2b7846741be53d726476b105aa863bd2f9917cd9ab2d35f6cfba318a604(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeCsi],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b9249439624c50a7c2c12221fbb715adecbca1d4f121a69eeb584bf12f407a41(
    *,
    default_mode: typing.Optional[builtins.str] = None,
    items: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d5e49aa25881c89be9091ac8f4e15b9995825e98d35a22340309276217cd7a21(
    *,
    field_ref: typing.Union[
        DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef,
        typing.Dict[builtins.str, typing.Any],
    ],
    path: builtins.str,
    mode: typing.Optional[builtins.str] = None,
    resource_field_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a78bed222e39691c60d5b36bc901c5180cbd42b1167b794e1abf38331ed62fdb(
    *,
    api_version: typing.Optional[builtins.str] = None,
    field_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d3cf4fd34356abd2c3eee98f89cc1fbc18b4cd92168467e448dd89e5e0c80079(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__df118ff9b1ea08e936255277759e785db5e88aa259ea8d2d1e08de45e3291802(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__32a2fd7d5b27e9a3f25e67ec2eb04f7b49721afd4caeb33f6d9c65c8c4a74556(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f640c6c0e2bbfa467e5e3c85a6148cd49be7a5e08dad13c2b8b596c878de4d3(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsFieldRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__812128e875ef81324b015e051585721d5ce153accc906b1712666efea69508b0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8e1258b82e0c772ff1986cb5ebffecc9323c5fdb7d5d4d12b5de7d4328b75e70(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b1d736e5805850f412b7901155d19edb2f2e64c76e314d2bbd1d339a5f805185(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aa2b90ccaed1768986c4ba95bd067fde9ea29915c45a8e0a6e9ef3d2ead67de2(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1133e69a4d5b5effbaf0c2b50fec8fabaed7a2eb38ae145d29e68164e0aec1a0(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2d5781a4e6b82bbf8849f99d681f7af1f514e3469d56fec8edf139156f9dfdff(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9d89905e8d53f242a9137cefe11d8ea29cf14aa385b4edaf8cb97c216bc1e0d0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__46fd7e5333d6200acd5691b5b5fad43d8367fd6d5796292a4893c4d1ff2291df(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dfd59b7ed2439f8f57b15d92f544a592ed056b81ee1f9a97ce4699d1f2d0d12b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1b77caf4d44bd6c50c32e1e973dbdf9e0d47eea228534432306436318398f28b(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__79e6a59e9aba0734a0154c06e0b9d2c89859daf752da8bf46eb78de88bd20016(
    *,
    container_name: builtins.str,
    resource: builtins.str,
    divisor: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0ea759a21e220b72248d538c2681b70acb2d7043ad494c06816aec22b8325ce0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4d259df4bbe8904b1b3e56e5b088c760b31588264429835ae8aebfc0aec27726(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ea46a7c6e2947db8f46b118bcf11e7d78d2feb86c47e034b8af97ea745cbd351(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b72a479262be215eadb9800741adcbcc2993be5dd31961e33f6d7f9970560d40(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c9b4fc5c275fa5f99454ee55c61195ddfd8736a1ec517306fa70cc93b7af9ec4(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeDownwardApiItemsResourceFieldRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__adf813a67a57882482ed77a45005f493bb20716223a00838d8287f77691fa507(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__390b32e8b4083ec92d5d7d07820ad841431d88ce2790f5a6c16c9db01ccd4cf1(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeDownwardApiItems,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b76f07d24d1b530b621eea3a4ffa9f6accdcc271025112d0949a89f5f30fdcbf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__94ec7251a1f2867386443b7ef480078bc684441d138850171c30fdc0dc18fc42(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeDownwardApi],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d2f0a4c17e0f2e93533beb223ea460dbd106b425f2a8e9a11174ec5a846a9238(
    *,
    medium: typing.Optional[builtins.str] = None,
    size_limit: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__32b696cc695c2453bc5a0931398b7e77589fabe5d052308059e5617a87df234b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ff113b336c85b2eb1f72bd7cffb78b459fc6e28be785f5d85c05037c6957454(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c2cd09bbbd018fd505366278097a7b3cdf3428f159fdbf8c5e794208fc5847c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5cadf97fd9e493ef6f88bbf846f13acdb73e7f2eec461a2c54d62c7763d56eec(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeEmptyDir],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba3bcf3929965d4a6ccb07475298157f5e54ca15fd4b8e2d41597c84cbc89bc1(
    *,
    lun: jsii.Number,
    target_ww_ns: typing.Sequence[builtins.str],
    fs_type: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c1181254ac5985653bb325dcb9b3d5942aa55648473457c9b224015e0ff1a48(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__df02dc067c67544442acd4c7bd167d45b27295a7461d2a44d36ad0688e11f52e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__855a146010f81c28bf01b67f973cb6fce69fb0efdb757b997a7f5ad1e47b7be0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e131698e780f7aaa5635e128221b0c4b68d981965ba78a9f1b834c5b24160524(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__38eee4045e1dbf05ef34cd11a82eec81b27d80e05659fa681234d1556098ac40(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ec3c458118c771ca39c46f96ce0cdd4b630a965eb5a12a12365b2fe37bdfc2e5(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFc],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bab7905fa3a007110a64188c1f9e85ced87bc8c4779421903e36b04534047f9f(
    *,
    driver: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    options: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    secret_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__df5a6f2ffacaa392903461a9aa404cd95921abf7e18d2b4cbdb7d25218f8dc8a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__da948760d05705e941bde1a0f75abb027bb5578f8de612debcaa8b8a1d2510cb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cfbe88338d8afe262bc1bf5df1d9110c58ada100266a1af9bf6884ea1ce62770(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7667478e343151c79a8eec31def92e675a6c59c0b834c76e80bd815e07d52aea(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d4da89dc8b9e0da1c1b5087956bacde452eb0978228f5bb76932d7009bcd5d25(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__058542390a3624e33db8be4c1a7034c1433bd814364edd3640e44c6f406bb165(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolume],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aa805b8bf0ad4fa80068de6f0bc89c6587788aa623ef77b2b94a2e52a6282db1(
    *,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__52eda7f1f8c4df90e0057a6dc5fa1fab362c33a68642393f9c424469775d2220(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__208eb2016a8838082bf59ed7274192cdff4d133f7c39f053860bbe0631dd236d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b1a08ec1a5b3e58e1a23ff0571f62af5135a63c54ca43b8191753088ab99b409(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b0287504d4e020ce76c28f93d37fe7827b95317a3cd0fe6647631af75754865f(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlexVolumeSecretRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7f9a38d84ca44752646a47d5ceb06d3def6a1f5f9b3b0d823853a93e24dc096(
    *,
    dataset_name: typing.Optional[builtins.str] = None,
    dataset_uuid: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dd15e58670335882d4dd33b16825186d06458ba5beadb107e6cc1d5d031fd25b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b9d2cd6ec396043493d1373ef34a713555f8257585ba6de49b985e4b4c9905cf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1fbb85ccd8b137a0de2afc99c24d78eaf5accd83d95a3ac5479d4dbf8fbeacb9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5284833b83c54c3333ec05aea5df5f97df8e9d2f81879cb22f6d05eb63485c7b(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeFlocker],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c5ee2265b263485c889e1f665220f05f7786ea92b515c5625b893a00cf60f02(
    *,
    pd_name: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    partition: typing.Optional[jsii.Number] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a327fc3c8acf469b8c08ed3a4bd7d6c63f2dabefccc7658f76e8b34c39726238(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6ba3007404fc8408c6f657353d4ccb9d4bfa3fabdbff510c568c1eac56432fc8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cafa833a6a4559d9dfd0cf64926a0c4b2234ce9a4099b00c3accd18754cd4155(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b1c0810d130a9eecc2fefb14494fe8bc3c2ff4b2a6ae6fd8da5b9321144bce5a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__13df52d01a9fe0fa6748d4fe80c5773763222cc6c5236b50b7ad39c8090b7afc(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__87f6e952431668a95a6f7eef818040a550d39a142649fd2d31407c51c2d40539(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGcePersistentDisk],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8960dd1ced032c4e49b5b50860439fe71a227720afb605e43c3837b91fe25333(
    *,
    directory: typing.Optional[builtins.str] = None,
    repository: typing.Optional[builtins.str] = None,
    revision: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4eb6b094478b22a1aa0cdb5b7abd88be7b27e462c350e8265b67bf1b1409416a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a32d733ab7c4d17277498d518f0f14f79218c7f4128eb261ebfbd35e10f5fdc4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__341b487b605cf34fef9b2730e9b930bc79e30dbf4ae525af5d942c0009670983(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__861207f0f76522230df51a4a2945887384ac0cb7fcd1af28dc683db60ad6743f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f1a15272d1b67d4d72194bb3d8f50beaa6d0e752e3580726cab8cc055c027806(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGitRepo],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e0e2e805bd8f35fd9f9002a91cd3f20361188630f54638c6613dd1ece5076466(
    *,
    endpoints_name: builtins.str,
    path: builtins.str,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c473454ceff1b6bc6ac6d5d009bfeffddbcf2e2bc6a2b6cdc007c526a5110f8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1735044eeae33f19210bd3160cb6590772493c01a1feb800b4702de607f94ce9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e389c44e4a51811ae2723206d5a0edfd4dc1110192c21e6ebb2e845402f81add(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c5aa2ee32c545ab05e13afe7bb42cc1b0086c248d81d42371c9f4c82294b233f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d1e9d8cab45ec7f64ecda8134844cc93078f1e712e0411b9482d1b1d850be568(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeGlusterfs],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bb67312a65a9fdb3487efccd9e473768ed8a2829834b0819e1f41c91c18715cb(
    *,
    path: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bca35177d6bf9cfd3548b83b043a431545dcc9828b7b45ad46860859158ed06e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c85d4d18fc960fcecdec492ab773e07016d67b106e66214c7466bdd5bdd3c655(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__604638a20d43493c5ba5bf8c227fdd4c52cf0a50cd1c8cd760202798e53696e4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6858a16a2a6b6338ffda6629a7acc7a61593ea0993b6b34f78aab47b1fc46b07(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeHostPath],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d177f89bdcaf95ee00adcf80ce4272fba6049a3fff1eb29d8756cdb658b77f62(
    *,
    iqn: builtins.str,
    target_portal: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    iscsi_interface: typing.Optional[builtins.str] = None,
    lun: typing.Optional[jsii.Number] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9eebd0c39edf6c57c4f20e6408d189c983f33246b0fd42fc7ab89a25ae151c8f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba24ca5c918f3c627436b44b3e93a8033fbe68864e99affc00d30fadf7cdf9f4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fcccc408f43436f8020e4ed62072c770c929e8ae656aa262e6dfd267fb5e0be5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__196868eca1d53a24572344fceb4e4aa7017c1ebf377cb2b31d6a3830f1c67b22(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__19ac0545ba00bd2af119be7dd4d7beb04a0431c308aad75bd8829fd148839928(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__77fe5dff87b7639f9fd30f3ed94a35083a27169bf27c4c59d2c8b384682f4b31(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3b791222b335cd1aeee84c86127b25d5cd7d99c7ed65431db0a187e0bdbbe711(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4d04acf21ea28c1e3d6ff9677676980347d9add83ecc37f8756a7a55252c9d0e(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeIscsi],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__02e0f67c84db748d224e4ee091fadbc0c38e30ecd0409e6dd1239827d8ac86ba(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8964f16048920ff6d141f0709da0721e7d4ed03fc0365d289a891ca017155228(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e894cc34e7edec4857a9cbf9052eb85d1c8a8ab2c5c8bc97e47434162ece9b08(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f59d8796e68f9031a72e3906ba7b52949a52aa236c4bfff7c9499f1afdb69f7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__745ba0e96e6a6304e56a7ef98cbd57b691180a513168994e05c83dd923e2181f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7d454899559822542bb473d3de5f0dd86f29cf67e4bdfbc6755e5f0d9e6b6206(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[DaemonSetV1SpecTemplateSpecVolume]
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dc750ff7a935272686157b3a9d669600d5fb47dfe1e250bbcc95dcbbe22f4c4a(
    *,
    path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ba1eed458896fa41c5fe2a83095e1e7177dcbdacec594674b870685072d5bbd6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f9763d3aea04c14042da34256cb83492a1599b0e31dd66c7dfdd17f09120613a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aa2db6b8cbcc0283b324e174ec00f2d317d81a9ec4de63c15f089595c9a85a3b(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeLocal],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__13c9342b9f8155760b77183288a0342888cf7b542dea8898db1d4d565d70d3b4(
    *,
    path: builtins.str,
    server: builtins.str,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0dad8a914be304d45d843fec22d6617267d3a01a9ec7f916f70eecee9df17a48(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5dfb2468b4a884c3c6576c57e5b74dfc96ab47b6e36f94cbf9049a5088869b98(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1d2acc35d0f9e8298f1409563315edf1c9c2bd7b540d51d8f27fe54a6282f130(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3efaefd573325edf08e545c90e7ac1475077ec2e99a7b3970366fc86291e5161(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca8b06ce8f1bc02c661193e9aaf7ccd5b994be871a1b562a9e0541a132f6a89b(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeNfs],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56b1e48bc000fd89babb1ecff4f2b539e6f1f4d6e513580528cceb3e7a9d5e5a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__88a4e6815431239f5c8a8a2ce116052e5c1ce792e31b56a03fcacd116bbcf3d9(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjected,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9ad3219a1d24b7fd5c05c049210d3663d5976fb7ad7db7e943afd946659666b9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__62d632dc3b60582a5d0165a76af6bf99fdfb76f155fdb9e32521b4ebed0f43a6(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolume]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf6e39560575b65d73188b25309438ca02038471b46c980cb8ad46fa8e2e26fc(
    *,
    claim_name: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af1d5a7ed0a121757d47833216d31e5b5b4b0b8578c4b16c01cc7f4cb73f8d34(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7df2406ff0b3a42eaa8c6a6e3dce161ba88b7b19f86976e23530f34a0a699f03(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1c71b8d6e9bb8f770faf9bbaca3d2bbd201d0e73174196e18f61636356188f72(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0e4ab30dbc6b84016ee57666cf8705e21fde2c56ef6c632c564d3b373b8dff42(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumePersistentVolumeClaim],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__88015965d2762a2409f41a96648bce6795480d4ca4ce5830ca76be91cc1f83a7(
    *,
    pd_id: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a898827705c07b2c9569f2536c08d80d1a66f5f7c8f89f5f2fbede8c4888b230(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c890cfd76594d7a1662216bd36fafd2fe5b75dee476da74313ea8542b103a97(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__428ecda81f8821ceb68b544969e4af3e6186a0f1470f5775a8efa3fc75b276c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__908cb7c637be40ba66334de28748ea7907a8bbf1962f13db747fde0af7c918a8(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumePhotonPersistentDisk],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2446abed254e4f20b9b9c6eef30311930cebeb02b029d386d27289051856dab3(
    *,
    sources: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSources,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
    default_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fe291b65d56c7f065fa84be01331e9a6b424f9418bee18a0f2bbaf0a44777435(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7aa3311ef382870db5f13b081ff4e165976ed119962959093cbad32df0671597(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1e32260f5d62143675ad604d68482d032548e172ece664037fb98ddead556810(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8c5ee6a702249d8682c95fefff79451d6fd3a6f32178b66f1ff0a78c87539fe9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e812708440d794689f4348f7347c04667666c495c027e38f54147fabc2dbf1a9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__73e6ab0d34b504ad5cbbafea31accc0f8737f11639b9186ff65f3eba9411e63a(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjected],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d94dbd2ea0418e349ff54c661e33d51bb6ecf8099887adb0bbc18b0bdfe9dc82(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__62125f29416d8bbb334b6ccae14d22ed8af678711de46422400d570138f5b31f(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSources,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5eb7d6f18c17a71154a1eed95d4cee64436f0c4e761bdef50010b2a01f353e53(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bb33dda28c16f32f13d2d2ef20137214806c5fb533f320ba02d868f88eae8029(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolumeProjected
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5493f31ae29eebcbc40e102952475dbb80b0bb9879594a074ad2352ff9427650(
    *,
    config_map: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    downward_api: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    secret: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    service_account_token: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6d2c37bd49fc4cc123d19371744d7ddee7ef0c43d21d1f97317ed9e33c98a84b(
    *,
    items: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    name: typing.Optional[builtins.str] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__10503fdc8e5653e6005a58c7a1ddc78e8ba5141084ea0981eebc2be68087193c(
    *,
    key: typing.Optional[builtins.str] = None,
    mode: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__84efc4f49f8f4ced190f4df93dd91d4f39164de66203f43c24a8bc5a009e672b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2110de199c64fbddd319434a3d7f288017344d943163da8f669037e6e2d1e03f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4dfa00089f4fef0a06568188757ce7083aed27ff83fb94b96497935ef2d3cb55(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0ef779634452507ee929392cf963572d3f98fd9ad01484567200f1db6075e54a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__86b2c2ba2756b97ac7cb65236afb7b955391c3678331ad02d9e65a4b61c76bfa(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__07553062696f60966b41b1ef06fe469b4308ac28dfdba53d9b2a015524ace236(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc5b067e3466ca0e352bcf9276221ab00eef1c6f5160a481442c3b83ad8ebf08(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d5761d51b26aa935037bf6ea4816e820136df0aa5c8a051b5d285ed13f6d63c5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fc196a8d0ff7625098362058ec54ba395ce12fb762314b45d980d426bb5f9682(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0e8fddef2ce3455651ae36cffeb5be2eae4a6db168a7f0aacbb5b52d1a2d1c29(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3760d531d0f60dec5ecc1fe6fe53a5aee42624aaae05f6d9ec9a2180cd26d474(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ae68c37aee9045a58e51fca2ab085e319532efe1cfd9986ddc0529359bce8b9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__55a04a4bdfbe48b62f3548b67eaab25d6e9e105c308b291e45447b71d6cd5b4b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c763efd05f7dde480b34965da1aefd83e8b6a5da7f2ea9af338c6e55d52538df(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f23f8e642aa1f7a882b6601ac37538cab1de523aa8b81574c56a067801aa928(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af042122441f620d2939e666ee561a6094ff157c01e1f8722b5b6c98e3787fce(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__504ad88ce4f0f444a3731f613ea41026cf7c2ffbd01bc00091e927e1f4fb3068(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2a3ac5cef0f54b13678ddc245d8be23c3739f1a722644acca656c2629648b553(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7fea52d1fb0d3f36b637a4a842b4a331dabb9caf4662aaf9938f2f6f448c7ab(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMapItems,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__362ffe44a1e3cea32ebfc5e67545930867b76fcd61a50af632c3997592734223(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d573b96dbe03800cd52a20b92d1e0256907e523b7a9c799e57abc7c0871eb11f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1af411bb49657b6210150171e994221f2709e405a247cb58b0b100561c2ee466(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3752049330f207fb8d4b18813d047c1b5a56e54b657a6b2cbae39fef017aa3c2(
    *,
    items: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f6f110d6f8346fb338eaa85d8e93e89e336b56697034d44f53d1093a5f0a2e82(
    *,
    path: builtins.str,
    field_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    mode: typing.Optional[builtins.str] = None,
    resource_field_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9dbee94121c08de3c94a372ee16eabc79258c5c34cea24b8a4477b34672f9bed(
    *,
    api_version: typing.Optional[builtins.str] = None,
    field_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b352a7f8f7729ad64ed2f73c0070a4b36ed767743d3dc7219b5b3c3ded6c4335(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__52fb84b42397e7715d924f0ea7dde17a2a13596facff893a904e64ad30701b62(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3a10fae90379d4f6c3b53d0c48dbf7d42b3f8f5c25943b85bfc24d5a83c4e46d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8d438a22377facc013d9c02a6ef4a99e31d59dfcb506bfbc3215c4279236ac15(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsFieldRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3b3302e9e6587ae5798b76ba81d44c5e117297ec5baf40b667d1f39339e710c2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__05c349fe11d80715a33914e72401bf03bc2a6526d7e23181dca2fb6a7ec4a523(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__23f264debb863af8824d6e421e99c2546cc2f4fd1fe061b845cb2723845d01b7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__30b38e21b4e682a70c4356736eccf300e573fb76db03f0174916d3f35b372767(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e6aa69140b8b83158191f121b970bcd6813b6945c3be908f80a2372e8b697456(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d5cb35a0a1723294fe0b83ae1aac962e35c34ff367591eec393a5f4d92e7c795(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems
            ],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c96dedd0bc38f0de08370eafb5d7bbf5b21c825198e1db21404a60f1ff8335c3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__207a3da03ff45ad5f082360006c4d493c419bf321323b843fc26d7f1c76e4f60(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__df1bae3707066ed2d8f9fd1d663da8e1265d36724beba9ed0f8eb0099b92a944(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9d2de8fb4dd478832cf12066b3c438d4cc8316eb12096402c87bbf9eaa5ba664(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5e68da8e03916be7608164e0d9a21aab19573448b6efb1071d40cad6825dfbec(
    *,
    container_name: builtins.str,
    resource: builtins.str,
    divisor: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__96b7982f896a3c6fdf9006e31a7702bac896549859e7e25923988a5d26bfbd0d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd8b0ec39204d21c293cee16a042f7d1183c739f4d7985569b55429caafbd442(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d99aa81a0dde6812e73cc2dbcc3872399f7c68ca8bf6e38eccb1f6dd239e2c5f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6dc4f11af6fce6242c0210ff69cb71e5531f420defd34a16e4ca284b583d2072(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5f4e373af9cbde9f611de5c6332b67d4756e5fb042b3beb14c89c04ffe44b534(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItemsResourceFieldRef
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__33593d67a55fe594e4b7f2ccb74843b23d2f9cb5ea9c304c413d2d214048fca2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__00de0b95b0e4149906770cf508481285ad4998795b8f7f043a778f11d849158d(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApiItems,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6f27bc4cba12b842416af17bac8265a0e6741a1f841f89d4aba74a784b7a72b8(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesDownwardApi
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1257e6c0ae9edd0b32b0bca3955598121f61ada0a15f9b75082f995c56e16d57(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cd68e6068662bb418bfdf7e9ce3704e3cdf1892ef642a23c87aaade1a5140681(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aa9ce3f04fc14289d78d327b47919be996154d91c62d5a4d15abf31d1b72c6cc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__483c8d70bcdcbbb600c7ca39d833a32b2c2bca021f2e51cb25d9af30af04f119(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__16e50a5e99531c06d749401423e8626922531d15afd3aab6997bb1e71b809815(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8d0c2e133680e9b19ebabc1913fb0395484462acb6aa1bb8dbc660af556a24c3(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSources],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e67371597bb69d9f6c241cb5ff44f5957d3e0a062c0aa9292527182d58ee561b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f1ce44d02b1a34eee5f397a63496e7b517d2c4d6879390bef86dac348b3300bd(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesConfigMap,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4358a70949fbbf7f3593e052c95e17868a11eacb5167254db9b4e58c56958fdc(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__875f727a3648b56f6e0f31a0f16c15d03c9d1831ee40610ade0ff81dbe5e18b5(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSources,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6db7ebab488dae186540ae1b6b7b0abc0368907d632a40e9ee1a5df4d4a84bd1(
    *,
    items: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    name: typing.Optional[builtins.str] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2d42af02d4208c3c730ac66b2e4557099a5c903a4204cb09b5da4f2a5ef26da(
    *,
    key: typing.Optional[builtins.str] = None,
    mode: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ee68c3308baf76e8ae3535e949bfcc90a6eddbac06776ec7547dc108ef494ff6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ad4d3d56cbf7cc46f88388888df351b24ab825fa4ef1cb187fd1c8d9a01d8406(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b6f4b60106733a59840dcc867176a9a2b51dd109527302a9dd844b52d849936f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__518b49cf42ae9271f74bd5041deb4ec72f6d3614bfe86eb69f98355dcdb244f1(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c7112b557ab09a6514917b1f58f02fd59619365f6b1bdbe245d74702e7247e8b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d533713d522256900042cd44092bc9723e634a6a9f1f4e0a449e5bddb22cee04(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f44368f64835a4481b5afbb2ced5c4b403fe660761143dc800bd7960a436878e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d8ff6fcd85158347a675c7b0fc38b73202f59e68a7a22e7983894c84e17911c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d77466ba96769b4d8093c2137fe5756fa62acfb773474befec5a666d9a1b90d4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__55c768c72bf2ec6fe10d354f1082b9dd1ec5edd689ddc3d359b4839c77dfd575(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f5af92c944f949f22f53c83613865992225cc72cf6dd17173331505ee8c05245(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e68a1fc054ccb51530d78d87df40867ff4572e2706aaf36cc5cff8f41e081f85(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__787083a5c64e5805c8758eee281f0c81f72405bddfea80f79c21ce77f5848e0b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5c54be15f6480a61352e59ba927df494586bd8a1145526f4e164c286441319b1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e631c4e0026e8f637b9c279437ac55db2a7f6a5a9b414c639db71686da8200aa(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__01a991c6be56d512b6bdcb9efaac21fbbf3138d03586781b66a21499b593bcc8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9dc7cc07aa327a46bb6deec218d743a06b74f3906015e4a66b195b6936063ced(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__81bb5c415549e34b2fc7ee837cd37ad6b5dd718cbe4840046dbbd6ea5a2c07bd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4ce453ab111b09ffacda3c20550f1ff58bfb2be887b2de9f9753af94d6946a97(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecretItems,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__389e8243bb9045ffe33a59164dc6999e77ab20e4ca47af1f8180f90e4c72d481(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__baf02f1be4ee850790b9a0ce8927cd1bb940be6d3915168d83a9f9eed596b537(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__80e54cc4d26c61814d86e87af7ec18616778fa45506fca75232b9c76a4620414(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesSecret,
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97880a4766f0c2fddf1ae3fd7875b153d90a2ffc5d36dd5494ea71f84487779f(
    *,
    path: builtins.str,
    audience: typing.Optional[builtins.str] = None,
    expiration_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4debc9c96efa48f8037246980f7dbdc54c708dd35b112e06a99f5c71a3a5a1c8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__44659592ec45c984d6da3a13549949c43bf9970ce27dffb57c1b794762e5e388(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b33cd14212f6ae51452e731f60f3dc10d1e67ae90c4a9874cd5955f2301db50(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5f15f2c913bf84497afefd822112be0b50f7153b5242a679a4b26db52bdfbd3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3abd6b23d1ded109c138836aaeebced5961097518af69f80654bbd08e6f142e1(
    value: typing.Optional[
        DaemonSetV1SpecTemplateSpecVolumeProjectedSourcesServiceAccountToken
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__26727233098ca75f2f12b7a09549514b46dd22909591132d082083417b4f49d5(
    *,
    registry: builtins.str,
    volume: builtins.str,
    group: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e529fc724348fa54e7b4bceca1cd3800cf458178de01cc851b89b5f4a6f73e63(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a033c182d17f8b479b108b81ea3cc801e37bc94a3a9f30273b01dcf64c8c3464(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf3622f56a2b87d321141393dce11e061f7a3bede29313a7080d0d4cd6484544(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8f5998605e15d229389d7c963fde30e83e1e4c67d8c90284bbea9b96ab1aafcd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4fb2ed812f30d069a089c6cea39a07487888bf2a4f4368677a3429a8cd75895d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0064c2f43509d09e1bf4021a01a9fa822b11d0ffd3dd3426de08ee0b03e264f0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4e01c090dded1b117d6b805e9a4ef4cd6874a9ebb853bfa6dcd0eb1ba6a29e49(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeQuobyte],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca8b5c4e47ba0f1bd062f50e9713388ea848b6c605124e87330588daba551b5a(
    *,
    ceph_monitors: typing.Sequence[builtins.str],
    rbd_image: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
    keyring: typing.Optional[builtins.str] = None,
    rados_user: typing.Optional[builtins.str] = None,
    rbd_pool: typing.Optional[builtins.str] = None,
    read_only: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    secret_ref: typing.Optional[
        typing.Union[
            DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c92692d0378b73673b9c3efd1147f44e868db8beae54c1aec02685bbda53fb36(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__221a2f71f7ca1ebe0c9a7c98baf5f9a89664f08fbd308fced67229a1f5abc338(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5fbcd99f7c5b94187615a42f6da70ad9a87426b1316a2d0db80079f858c1122f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c43de932f67fecc82f9fd18f2d3b2a3ad7cc620fed124dacd1bf1413cf01a87c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b3c581de1bba0eb6a2f52a0c1931131572e709174241a77ab03dc316d2b239d0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__535b77b976772e16dede34af85fc4d9598a3e6511d8bffc98880c33c27eee8c3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__adf704068e0ddd4fdd597ef527dde1a710f63b25df77543166a7ca9c8ff19715(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c4b7e09592d51a978262d2e1d37f122475edb199a8dd21a94820d4fb1edd4321(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c647a0ed5409c692a787f540cf64ace1666329aa4cdbb5c364cd423e6fb0ec8(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbd],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7676a0290165eca32d17ad4a73f5153238fd10bdb6ab2fa058536fdd9495817e(
    *,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0eca9fa0d2892a5af8bfad68c206ecdfe2309b26e3f7084f51211b51f89aa4ef(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__03210f4501f18b4b48ad178cd23d9953e4a4ff5fefa1ee6ea14f3e7a0026967d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__546076714850c9ec82163b9348f9cd7b0c5bd1f515f3a5593c083402eb112ed0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b7a5a9f38f4150a95febeb344f6aee7e57649f86beea4f0b14ce15d4d74fa082(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeRbdSecretRef],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__eca1a4cba00976a4190cc3a797fd609484c6e506aa8cdb0d6605ef8209b9edc5(
    *,
    default_mode: typing.Optional[builtins.str] = None,
    items: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    DaemonSetV1SpecTemplateSpecVolumeSecretItems,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    optional: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a294365d9b2b72725ff248ece0cd737fdd430c11f14fc9301559d84fb3ffb847(
    *,
    key: typing.Optional[builtins.str] = None,
    mode: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f488d83b392fa45ca280db205ba20fe0b698cc95c5d5e2b87c169e0e6b1081df(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85552faff57dd5306d2000b4181822845970c96635356c4ef29433d5b7cbb50c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__65074ecbe53a7f9dad0d78ed0fd2e61076b5a74e39662455c322b93fe8810635(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__687f9cbfb679fae60badd2403a3bab0283542924cc7ebca9fa36301f1c5fa145(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ff6a506376a5a5b704c28ed98764acdf6044eb16ad4638b9de6ac67bce67006e(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f259aa666fa22e10b33d01cb3c31ab9c4b334b41105ecb8a23bd77d1c6f4c42(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.List[DaemonSetV1SpecTemplateSpecVolumeSecretItems],
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5b58b98352a4fec47c785a2ddba7775d5e156a0056088a4f5e26c25735ad6f93(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__035dea3833d4b2e6197a643f1b8b3ae5ec6be994efdfce5c57fa7ba2405d7d1f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9d9fcf2afc2b5bfeb80b8dea69ca6c26fce43eb9cd390e7e74b2a10ef02ac810(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0715cc8a38577e27ca54fb791801f4681f0fffd3ef4df3bda57d866b9a17b242(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e76c847434a6a545745b9fa98e93cda79783331e3260990667edb5bb7ebed74b(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, DaemonSetV1SpecTemplateSpecVolumeSecretItems
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6671069d749cac03986878a64150d6cdd53d4a09b1a95b525d3b16ba83ca53c5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a9d5a7f9ba240aaedd86a482a9c93b43f7e0ef247c3b37da7ec064d228860652(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                DaemonSetV1SpecTemplateSpecVolumeSecretItems,
                typing.Dict[builtins.str, typing.Any],
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b6eb35c556d23b12653a48457924d39cb86933d7c3c78ac20726552f758454aa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e60854e71453cd7268cf32f9dcfa9e2a6d8d6c546a484be76a8d017c4cdf28e4(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f51441999e612da87be352d9cfeb2d94f84fe101e5c286a5cba4a4274c1b1ce8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c99042d4fd3eb1ab31aa21f8b013e6b797dfe23d13c6961c866390c70071aca(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeSecret],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cdbc30f131f8a43de9f7ed293c0fb23c5f79e800f8762e284bd71b2b1ab685dd(
    *,
    volume_path: builtins.str,
    fs_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__21f603c082b4fdee6c425fb2b782b35cfe19156a439cb371f5649f8e4232e8af(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1eb424c9dda06f6100c97b36febfa85d285b65e0972f3a7aa8b9563fc22b80c2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d47e2516b385eee515075ccce0cc1daa311efef9c87e77158a0c3bcded0b0339(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2c97715d86f3c183507fd509797240391162961be887ab5aec6dafd451d5f40d(
    value: typing.Optional[DaemonSetV1SpecTemplateSpecVolumeVsphereVolume],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3a42648b0b19c759f909aaacfa3b87095e6fadbfea265c9382efb9191e0aaea7(
    *,
    create: typing.Optional[builtins.str] = None,
    delete: typing.Optional[builtins.str] = None,
    update: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f1251d9c4b61a19dcafb6b4c2f15a1528f16396a8056643510e2b27d05df696d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2b64c73c653502faf7451eab52d863a995ff1b056499316e7d66572feb86dd1d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__73722cc41f590ae766b82f3b2f25d66910a802f352972f6aea56c3304905110a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__59dac94c852952e1e458eeec35be9a70ffe33c2802b99d33a06b2ea3de5853c3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0c36f1083409d13ea3d1254c73783650ed8da43bb950f0511aab420c16fe4a2b(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, DaemonSetV1Timeouts]
    ],
) -> None:
    """Type checking stubs"""
    pass
