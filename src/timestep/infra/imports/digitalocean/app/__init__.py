"""
# `digitalocean_app`

Refer to the Terraform Registory for docs: [`digitalocean_app`](https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app).
"""
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import cdktf as _cdktf_9a9027ec
import constructs as _constructs_77d1e7e8


class App(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.App",
):
    """Represents a {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app digitalocean_app}."""

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id_: builtins.str,
        *,
        id: typing.Optional[builtins.str] = None,
        spec: typing.Optional[
            typing.Union["AppSpec", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        timeouts: typing.Optional[
            typing.Union["AppTimeouts", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        connection: typing.Optional[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.SSHProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.WinrmProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ] = None,
        count: typing.Optional[
            typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
        ] = None,
        depends_on: typing.Optional[
            typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
        ] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.TerraformResourceLifecycle,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[
            typing.Sequence[
                typing.Union[
                    typing.Union[
                        _cdktf_9a9027ec.FileProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.LocalExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.RemoteExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                ]
            ]
        ] = None,
    ) -> None:
        """Create a new {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app digitalocean_app} Resource.

        :param scope: The scope in which to define this construct.
        :param id_: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#id App#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#spec App#spec}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#timeouts App#timeouts}
        :param connection:
        :param count:
        :param depends_on:
        :param for_each:
        :param lifecycle:
        :param provider:
        :param provisioners:
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9719f48172aa2035f5d9938d6776537bfc7bd94d5f0cad4489626d8a62d17da7
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument id_", value=id_, expected_type=type_hints["id_"]
            )
        config = AppConfig(
            id=id,
            spec=spec,
            timeouts=timeouts,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id_, config])

    @jsii.member(jsii_name="putSpec")
    def put_spec(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecAlert", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        database: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecDatabase", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        domain: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecDomain", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecEnv", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        function: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecFunction", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        job: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecJob", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        region: typing.Optional[builtins.str] = None,
        service: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecService", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        static_site: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecStaticSite", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        worker: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecWorker", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param name: The name of the app. Must be unique across all apps in the same account. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        :param database: database block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#database App#database}
        :param domain: domain block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#domain App#domain}
        :param domains: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#domains App#domains}.
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        :param function: function block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#function App#function}
        :param job: job block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#job App#job}
        :param region: The slug for the DigitalOcean data center region hosting the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#region App#region}
        :param service: service block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#service App#service}
        :param static_site: static_site block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#static_site App#static_site}
        :param worker: worker block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#worker App#worker}
        """
        value = AppSpec(
            name=name,
            alert=alert,
            database=database,
            domain=domain,
            domains=domains,
            env=env,
            function=function,
            job=job,
            region=region,
            service=service,
            static_site=static_site,
            worker=worker,
        )

        return typing.cast(None, jsii.invoke(self, "putSpec", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(self, *, create: typing.Optional[builtins.str] = None) -> None:
        """
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#create App#create}.
        """
        value = AppTimeouts(create=create)

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetId")
    def reset_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetId", []))

    @jsii.member(jsii_name="resetSpec")
    def reset_spec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSpec", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(
            typing.Mapping[builtins.str, typing.Any],
            jsii.invoke(self, "synthesizeAttributes", []),
        )

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="activeDeploymentId")
    def active_deployment_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "activeDeploymentId"))

    @builtins.property
    @jsii.member(jsii_name="createdAt")
    def created_at(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "createdAt"))

    @builtins.property
    @jsii.member(jsii_name="defaultIngress")
    def default_ingress(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "defaultIngress"))

    @builtins.property
    @jsii.member(jsii_name="liveUrl")
    def live_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "liveUrl"))

    @builtins.property
    @jsii.member(jsii_name="spec")
    def spec(self) -> "AppSpecOutputReference":
        return typing.cast("AppSpecOutputReference", jsii.get(self, "spec"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "AppTimeoutsOutputReference":
        return typing.cast("AppTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="updatedAt")
    def updated_at(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "updatedAt"))

    @builtins.property
    @jsii.member(jsii_name="urn")
    def urn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "urn"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="specInput")
    def spec_input(self) -> typing.Optional["AppSpec"]:
        return typing.cast(typing.Optional["AppSpec"], jsii.get(self, "specInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "AppTimeouts"]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "AppTimeouts"]],
            jsii.get(self, "timeoutsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__25462453e965bf4db9f29422031d45d834c773a920451b794e537ca23137c526
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "id", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "id": "id",
        "spec": "spec",
        "timeouts": "timeouts",
    },
)
class AppConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.SSHProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.WinrmProvisionerConnection,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ] = None,
        count: typing.Optional[
            typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
        ] = None,
        depends_on: typing.Optional[
            typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
        ] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.TerraformResourceLifecycle,
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[
            typing.Sequence[
                typing.Union[
                    typing.Union[
                        _cdktf_9a9027ec.FileProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.LocalExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                    typing.Union[
                        _cdktf_9a9027ec.RemoteExecProvisioner,
                        typing.Dict[builtins.str, typing.Any],
                    ],
                ]
            ]
        ] = None,
        id: typing.Optional[builtins.str] = None,
        spec: typing.Optional[
            typing.Union["AppSpec", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        timeouts: typing.Optional[
            typing.Union["AppTimeouts", typing.Dict[builtins.str, typing.Any]]
        ] = None,
    ) -> None:
        """
        :param connection:
        :param count:
        :param depends_on:
        :param for_each:
        :param lifecycle:
        :param provider:
        :param provisioners:
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#id App#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#spec App#spec}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#timeouts App#timeouts}
        """
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(spec, dict):
            spec = AppSpec(**spec)
        if isinstance(timeouts, dict):
            timeouts = AppTimeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c779963e1fbb744b09c3c12e83b9b8eab3501d9a5e78f0f17e085df2e8dfc651
            )
            check_type(
                argname="argument connection",
                value=connection,
                expected_type=type_hints["connection"],
            )
            check_type(
                argname="argument count", value=count, expected_type=type_hints["count"]
            )
            check_type(
                argname="argument depends_on",
                value=depends_on,
                expected_type=type_hints["depends_on"],
            )
            check_type(
                argname="argument for_each",
                value=for_each,
                expected_type=type_hints["for_each"],
            )
            check_type(
                argname="argument lifecycle",
                value=lifecycle,
                expected_type=type_hints["lifecycle"],
            )
            check_type(
                argname="argument provider",
                value=provider,
                expected_type=type_hints["provider"],
            )
            check_type(
                argname="argument provisioners",
                value=provisioners,
                expected_type=type_hints["provisioners"],
            )
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(
                argname="argument spec", value=spec, expected_type=type_hints["spec"]
            )
            check_type(
                argname="argument timeouts",
                value=timeouts,
                expected_type=type_hints["timeouts"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if id is not None:
            self._values["id"] = id
        if spec is not None:
            self._values["spec"] = spec
        if timeouts is not None:
            self._values["timeouts"] = timeouts

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.SSHProvisionerConnection,
            _cdktf_9a9027ec.WinrmProvisionerConnection,
        ]
    ]:
        """
        :stability: experimental
        """
        result = self._values.get("connection")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.SSHProvisionerConnection,
                    _cdktf_9a9027ec.WinrmProvisionerConnection,
                ]
            ],
            result,
        )

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        """
        :stability: experimental
        """
        result = self._values.get("count")
        return typing.cast(
            typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]],
            result,
        )

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        """
        :stability: experimental
        """
        result = self._values.get("depends_on")
        return typing.cast(
            typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result
        )

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        """
        :stability: experimental
        """
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        """
        :stability: experimental
        """
        result = self._values.get("lifecycle")
        return typing.cast(
            typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result
        )

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        """
        :stability: experimental
        """
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[
        typing.List[
            typing.Union[
                _cdktf_9a9027ec.FileProvisioner,
                _cdktf_9a9027ec.LocalExecProvisioner,
                _cdktf_9a9027ec.RemoteExecProvisioner,
            ]
        ]
    ]:
        """
        :stability: experimental
        """
        result = self._values.get("provisioners")
        return typing.cast(
            typing.Optional[
                typing.List[
                    typing.Union[
                        _cdktf_9a9027ec.FileProvisioner,
                        _cdktf_9a9027ec.LocalExecProvisioner,
                        _cdktf_9a9027ec.RemoteExecProvisioner,
                    ]
                ]
            ],
            result,
        )

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#id App#id}.

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        """
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def spec(self) -> typing.Optional["AppSpec"]:
        """spec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#spec App#spec}
        """
        result = self._values.get("spec")
        return typing.cast(typing.Optional["AppSpec"], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["AppTimeouts"]:
        """timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#timeouts App#timeouts}
        """
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["AppTimeouts"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpec",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "database": "database",
        "domain": "domain",
        "domains": "domains",
        "env": "env",
        "function": "function",
        "job": "job",
        "region": "region",
        "service": "service",
        "static_site": "staticSite",
        "worker": "worker",
    },
)
class AppSpec:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecAlert", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        database: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecDatabase", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        domain: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecDomain", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecEnv", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        function: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecFunction", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        job: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecJob", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        region: typing.Optional[builtins.str] = None,
        service: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecService", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        static_site: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecStaticSite", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        worker: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecWorker", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
    ) -> None:
        """
        :param name: The name of the app. Must be unique across all apps in the same account. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        :param database: database block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#database App#database}
        :param domain: domain block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#domain App#domain}
        :param domains: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#domains App#domains}.
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        :param function: function block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#function App#function}
        :param job: job block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#job App#job}
        :param region: The slug for the DigitalOcean data center region hosting the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#region App#region}
        :param service: service block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#service App#service}
        :param static_site: static_site block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#static_site App#static_site}
        :param worker: worker block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#worker App#worker}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1b82fb39ffdc69d3d1d97267325ac05b7b7483d5f92437033f065d32d94adc21
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument alert", value=alert, expected_type=type_hints["alert"]
            )
            check_type(
                argname="argument database",
                value=database,
                expected_type=type_hints["database"],
            )
            check_type(
                argname="argument domain",
                value=domain,
                expected_type=type_hints["domain"],
            )
            check_type(
                argname="argument domains",
                value=domains,
                expected_type=type_hints["domains"],
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument function",
                value=function,
                expected_type=type_hints["function"],
            )
            check_type(
                argname="argument job", value=job, expected_type=type_hints["job"]
            )
            check_type(
                argname="argument region",
                value=region,
                expected_type=type_hints["region"],
            )
            check_type(
                argname="argument service",
                value=service,
                expected_type=type_hints["service"],
            )
            check_type(
                argname="argument static_site",
                value=static_site,
                expected_type=type_hints["static_site"],
            )
            check_type(
                argname="argument worker",
                value=worker,
                expected_type=type_hints["worker"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if database is not None:
            self._values["database"] = database
        if domain is not None:
            self._values["domain"] = domain
        if domains is not None:
            self._values["domains"] = domains
        if env is not None:
            self._values["env"] = env
        if function is not None:
            self._values["function"] = function
        if job is not None:
            self._values["job"] = job
        if region is not None:
            self._values["region"] = region
        if service is not None:
            self._values["service"] = service
        if static_site is not None:
            self._values["static_site"] = static_site
        if worker is not None:
            self._values["worker"] = worker

    @builtins.property
    def name(self) -> builtins.str:
        """The name of the app. Must be unique across all apps in the same account.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlert"]]
    ]:
        """alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        """
        result = self._values.get("alert")
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlert"]]
            ],
            result,
        )

    @builtins.property
    def database(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecDatabase"]]
    ]:
        """database block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#database App#database}
        """
        result = self._values.get("database")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecDatabase"]
                ]
            ],
            result,
        )

    @builtins.property
    def domain(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecDomain"]]
    ]:
        """domain block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#domain App#domain}
        """
        result = self._values.get("domain")
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecDomain"]]
            ],
            result,
        )

    @builtins.property
    def domains(self) -> typing.Optional[typing.List[builtins.str]]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#domains App#domains}."""
        result = self._values.get("domains")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecEnv"]]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecEnv"]]
            ],
            result,
        )

    @builtins.property
    def function(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunction"]]
    ]:
        """function block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#function App#function}
        """
        result = self._values.get("function")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunction"]
                ]
            ],
            result,
        )

    @builtins.property
    def job(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJob"]]
    ]:
        """job block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#job App#job}
        """
        result = self._values.get("job")
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJob"]]
            ],
            result,
        )

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        """The slug for the DigitalOcean data center region hosting the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#region App#region}
        """
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]
    ]:
        """service block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#service App#service}
        """
        result = self._values.get("service")
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]
            ],
            result,
        )

    @builtins.property
    def static_site(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]]
    ]:
        """static_site block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#static_site App#static_site}
        """
        result = self._values.get("static_site")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]
                ]
            ],
            result,
        )

    @builtins.property
    def worker(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]
    ]:
        """worker block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#worker App#worker}
        """
        result = self._values.get("worker")
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]
            ],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecAlert",
    jsii_struct_bases=[],
    name_mapping={"rule": "rule", "disabled": "disabled"},
)
class AppSpecAlert:
    def __init__(
        self,
        *,
        rule: builtins.str,
        disabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}.
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ec82ed85c3a33e2c09dd2fa5c47d4918f72627511d49328ba566d27c48b3d8ae
            )
            check_type(
                argname="argument rule", value=rule, expected_type=type_hints["rule"]
            )
            check_type(
                argname="argument disabled",
                value=disabled,
                expected_type=type_hints["disabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "rule": rule,
        }
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def rule(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}."""
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}."""
        result = self._values.get("disabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08514ffdb29365a085031be373e4d9bb023f828241b6bef50ae584ae455389e5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecAlertOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c1a9170daf7fca72e0aba8094a30605757459e36ae86fdea35bd51750778fa8
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecAlertOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cb19d3b3d493702bc9ae2f6ab79694f5e23da99b3326c03a2867ec8f8579c22d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__92a354fab1890a24acdd598f5c8b6ea19e727ea1303754ccbbbb29cb78e88655
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2cd9ad1b9d2c20682052d30ffd9b619714c2f79fa82d1b1242e898f95bcb4644
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a343d27693f0a90e1a98106534d1bf4899ce79292010e12c4dbfce5f0a190a71
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c337ecdaa0de661087b1e7efac064befe352080c42d92d7a40ef9a855a1e6cb
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "disabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "disabled"),
        )

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__543d9ec2e09b576f1c8d2fb0081faaca78f3b4a05234f811eb2f2f59c4bfef85
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "disabled", value)

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a8cffe9b6053184a9748da50fda5a2322578ecee660a5fc6a5d0b7133e28d72a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "rule", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__459d322eb90b8c00b0607ba22f19329272aff18b9521097116e4cc6e0c4dfce2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecDatabase",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_name": "clusterName",
        "db_name": "dbName",
        "db_user": "dbUser",
        "engine": "engine",
        "name": "name",
        "production": "production",
        "version": "version",
    },
)
class AppSpecDatabase:
    def __init__(
        self,
        *,
        cluster_name: typing.Optional[builtins.str] = None,
        db_name: typing.Optional[builtins.str] = None,
        db_user: typing.Optional[builtins.str] = None,
        engine: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        production: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cluster_name App#cluster_name}
        :param db_name: The name of the MySQL or PostgreSQL database to configure. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#db_name App#db_name}
        :param db_user: The name of the MySQL or PostgreSQL user to configure. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#db_user App#db_user}
        :param engine: The database engine to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#engine App#engine}
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param production: Whether this is a production or dev database. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#production App#production}
        :param version: The version of the database engine. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#version App#version}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__804a3918707e409695bb5d473660cede76ed37be4a7066c79971549c2750e2d6
            )
            check_type(
                argname="argument cluster_name",
                value=cluster_name,
                expected_type=type_hints["cluster_name"],
            )
            check_type(
                argname="argument db_name",
                value=db_name,
                expected_type=type_hints["db_name"],
            )
            check_type(
                argname="argument db_user",
                value=db_user,
                expected_type=type_hints["db_user"],
            )
            check_type(
                argname="argument engine",
                value=engine,
                expected_type=type_hints["engine"],
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument production",
                value=production,
                expected_type=type_hints["production"],
            )
            check_type(
                argname="argument version",
                value=version,
                expected_type=type_hints["version"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cluster_name is not None:
            self._values["cluster_name"] = cluster_name
        if db_name is not None:
            self._values["db_name"] = db_name
        if db_user is not None:
            self._values["db_user"] = db_user
        if engine is not None:
            self._values["engine"] = engine
        if name is not None:
            self._values["name"] = name
        if production is not None:
            self._values["production"] = production
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        """The name of the underlying DigitalOcean DBaaS cluster.

        This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cluster_name App#cluster_name}
        """
        result = self._values.get("cluster_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_name(self) -> typing.Optional[builtins.str]:
        """The name of the MySQL or PostgreSQL database to configure.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#db_name App#db_name}
        """
        result = self._values.get("db_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_user(self) -> typing.Optional[builtins.str]:
        """The name of the MySQL or PostgreSQL user to configure.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#db_user App#db_user}
        """
        result = self._values.get("db_user")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine(self) -> typing.Optional[builtins.str]:
        """The database engine to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#engine App#engine}
        """
        result = self._values.get("engine")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        """The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def production(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether this is a production or dev database.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#production App#production}
        """
        result = self._values.get("production")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        """The version of the database engine.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#version App#version}
        """
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecDatabase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecDatabaseList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecDatabaseList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__84a22d253fdf753bc1d945c991827aa8b258578592891b36e2021690fa16272c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecDatabaseOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6c4ff3130bb087c6d306c0d176bc4ffbb600d17ef1683dcb9222084ccde1c791
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecDatabaseOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__03f8cbaf4d909d7ee7015d28cd91b20be23382a0d67435772e08ada3d031e445
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ec75930387e5f163026777ad49a5bf25ff90e191f182e21488b63ae10ce84d6e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4dd22be6f85b84517b1d60504b882f26a46f11a321b095dde9d7fc37d858a7bd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1687e5582c12c262ddf5edc2e945f37de4fe27380c1fe800a3e1397ebf87b542
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecDatabaseOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecDatabaseOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__44db75570d6d5a036dca1087dd9694ccb54b5716054bf7f5c9467fc1f2bed0da
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetClusterName")
    def reset_cluster_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterName", []))

    @jsii.member(jsii_name="resetDbName")
    def reset_db_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDbName", []))

    @jsii.member(jsii_name="resetDbUser")
    def reset_db_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDbUser", []))

    @jsii.member(jsii_name="resetEngine")
    def reset_engine(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEngine", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetProduction")
    def reset_production(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProduction", []))

    @jsii.member(jsii_name="resetVersion")
    def reset_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVersion", []))

    @builtins.property
    @jsii.member(jsii_name="clusterNameInput")
    def cluster_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "clusterNameInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dbNameInput")
    def db_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbNameInput"))

    @builtins.property
    @jsii.member(jsii_name="dbUserInput")
    def db_user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbUserInput"))

    @builtins.property
    @jsii.member(jsii_name="engineInput")
    def engine_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engineInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="productionInput")
    def production_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "productionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="versionInput")
    def version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "versionInput")
        )

    @builtins.property
    @jsii.member(jsii_name="clusterName")
    def cluster_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterName"))

    @cluster_name.setter
    def cluster_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fa57e2dfb8fe8097c92a81e9d1869fd6ee0c8824b617963aac95c8d537fdb6fd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "clusterName", value)

    @builtins.property
    @jsii.member(jsii_name="dbName")
    def db_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dbName"))

    @db_name.setter
    def db_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9afd9e6d5b924bbccad5eedb713ab875a86a982bb818c91d25aade4231f08385
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dbName", value)

    @builtins.property
    @jsii.member(jsii_name="dbUser")
    def db_user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dbUser"))

    @db_user.setter
    def db_user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a97fefad0e6630a7005ea80dfdc59811d28385a9197a23cf90765d6d2ae995aa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dbUser", value)

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "engine"))

    @engine.setter
    def engine(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0b090f2979e3be7bed4605c291becd32c858482ad6109fe7ef91404bf2fea950
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "engine", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__136d8e358a956026ff9e84d6b9310885051fd2470648bc42c6f022e1e00ffea5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="production")
    def production(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "production"),
        )

    @production.setter
    def production(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__406ead2e00747d59251281a243b6ba00babe6b6b1cd0fabc632ef13d2e4ed75d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "production", value)

    @builtins.property
    @jsii.member(jsii_name="version")
    def version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "version"))

    @version.setter
    def version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dc0c68e218284c8b1fd2f2123a172c060e2ef6227abca7372a31c6c0b1a32b19
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "version", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__29b7117840a44e728fbf14edad792eb2d3d345b2b2d00a419d89bc95939c2b3a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecDomain",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "wildcard": "wildcard",
        "zone": "zone",
    },
)
class AppSpecDomain:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
        wildcard: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        zone: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The hostname for the domain. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param type: The type of the domain. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        :param wildcard: Indicates whether the domain includes all sub-domains, in addition to the given domain. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#wildcard App#wildcard}
        :param zone: If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#zone App#zone}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a0a95514109e9fb1e07266429b86e0b1b2a420182e790096cb1c80e9c9f5cebb
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument wildcard",
                value=wildcard,
                expected_type=type_hints["wildcard"],
            )
            check_type(
                argname="argument zone", value=zone, expected_type=type_hints["zone"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type
        if wildcard is not None:
            self._values["wildcard"] = wildcard
        if zone is not None:
            self._values["zone"] = zone

    @builtins.property
    def name(self) -> builtins.str:
        """The hostname for the domain.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """The type of the domain.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def wildcard(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Indicates whether the domain includes all sub-domains, in addition to the given domain.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#wildcard App#wildcard}
        """
        result = self._values.get("wildcard")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def zone(self) -> typing.Optional[builtins.str]:
        """If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#zone App#zone}
        """
        result = self._values.get("zone")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecDomain(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecDomainList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecDomainList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ffa074cdce6ada798e59060c6a188f430e2442c55eee8ec2b0c19ebdce07000d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecDomainOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__794214168f73fc57f76890397a2b117b802cd39f659758b8451eddb5b99d5fa0
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecDomainOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5fb0f930a614cfc7c8c4567083c2ff610dbc1976489651ad3db497c99ef704b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5c6ba64ca5a6a8be9e1f5d736b68c5846e88f4fc487dded0a082d9341a7567f1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__41b5740fcbc595d9df35321d5cf9d3fd9c8a3bb70a281255f3e050f7d603c8c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d7410ce653fd24cc7df485c05bd62af0b43c6488b2cfa09a031a12df63a75242
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecDomainOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecDomainOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9eba864c044fc064338347e23b31b68d111c88b4e100c274c68792d162fde44e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetWildcard")
    def reset_wildcard(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWildcard", []))

    @jsii.member(jsii_name="resetZone")
    def reset_zone(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetZone", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="wildcardInput")
    def wildcard_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "wildcardInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="zoneInput")
    def zone_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "zoneInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__624b63e3d3c1102b006b427c2dd7f2c5be0a0c7565f608f9339fbd00696cc34a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c9a0f02d7532f2a13486767e7baf24ebb2d29f4ff97a5006ccb863e52bc6b7ed
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="wildcard")
    def wildcard(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "wildcard"),
        )

    @wildcard.setter
    def wildcard(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1939fb1df3c517f5ed70af830ed75edeb1555a0053c157b12e815126b6f028e9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wildcard", value)

    @builtins.property
    @jsii.member(jsii_name="zone")
    def zone(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "zone"))

    @zone.setter
    def zone(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d663669895832d1dc718c326d048d85eb61a985a7d33ff8c5049d0d1b0b7245e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "zone", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__920f281cd80602722b26402cfb3e7b5f4a561a59093f66c9afee1f8c1b1a6e69
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3448b16d9cfd75574e259daa9e29e7357a98db7c1adfbbfb1372e7355259960c
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        """The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        """
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__49c0b9d31933b2374f58f4993803e5187c569aa0e69349d56479429c854d160c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0ef90e41c091f47875bb21b38c7400b382f48e542cd402a88c53931e67da78e6
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecEnvOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6c8f1798b396d4ba46fb42cee5ed4b94a35ad152ad413c41194744b14602e424
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d847096eade6f962244852701ab6315594a4c97a0f07bdefe866291bb237832b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d97fd5426a25ae09646da7c341f6334080bb24cc7be01c3c604cf6f7919a1aa9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2aef7dc475365d8dc024ab78cf6369d4af57fcae7de2472335b9759c99317085
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__86438fcee59fde0f4f4e3a3321a6908c3e85587d425703346a55c50cda36c368
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ef3a75d32d5dac35cd90aedc9140ff2891bb75bbef7031e3df3aa77c3b080e83
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__39a2a684dc3622746bb89ca0499ca4262e2b9c1b9c01071c4cb3967ed2192348
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scope", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9a4e8e6c16333841463f6b127d0d5d2fc4d969404f52aae64d027fcefed096ba
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc9d3432d58173aab9315d021a9d4fc8e5dbe51779fa1db75e837fc00d362342
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97f8448ae3d9db7b24c92a79d2e834236f0f3c8bf7dae209a15fa7f3a90454eb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunction",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "cors": "cors",
        "env": "env",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "log_destination": "logDestination",
        "routes": "routes",
        "source_dir": "sourceDir",
    },
)
class AppSpecFunction:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecFunctionAlert", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        cors: typing.Optional[
            typing.Union["AppSpecFunctionCors", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecFunctionEnv", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        git: typing.Optional[
            typing.Union["AppSpecFunctionGit", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        github: typing.Optional[
            typing.Union["AppSpecFunctionGithub", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        gitlab: typing.Optional[
            typing.Union["AppSpecFunctionGitlab", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        log_destination: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecFunctionLogDestination",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        routes: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecFunctionRoutes", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        source_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        :param cors: cors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cors App#cors}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        :param routes: routes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#routes App#routes}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        if isinstance(cors, dict):
            cors = AppSpecFunctionCors(**cors)
        if isinstance(git, dict):
            git = AppSpecFunctionGit(**git)
        if isinstance(github, dict):
            github = AppSpecFunctionGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecFunctionGitlab(**gitlab)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__525f9966acca88cf512b41751b1d59f0767ce801ebbe5dbfc12e6830b484279f
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument alert", value=alert, expected_type=type_hints["alert"]
            )
            check_type(
                argname="argument cors", value=cors, expected_type=type_hints["cors"]
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument git", value=git, expected_type=type_hints["git"]
            )
            check_type(
                argname="argument github",
                value=github,
                expected_type=type_hints["github"],
            )
            check_type(
                argname="argument gitlab",
                value=gitlab,
                expected_type=type_hints["gitlab"],
            )
            check_type(
                argname="argument log_destination",
                value=log_destination,
                expected_type=type_hints["log_destination"],
            )
            check_type(
                argname="argument routes",
                value=routes,
                expected_type=type_hints["routes"],
            )
            check_type(
                argname="argument source_dir",
                value=source_dir,
                expected_type=type_hints["source_dir"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if cors is not None:
            self._values["cors"] = cors
        if env is not None:
            self._values["env"] = env
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if routes is not None:
            self._values["routes"] = routes
        if source_dir is not None:
            self._values["source_dir"] = source_dir

    @builtins.property
    def name(self) -> builtins.str:
        """The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlert"]]
    ]:
        """alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        """
        result = self._values.get("alert")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlert"]
                ]
            ],
            result,
        )

    @builtins.property
    def cors(self) -> typing.Optional["AppSpecFunctionCors"]:
        """cors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cors App#cors}
        """
        result = self._values.get("cors")
        return typing.cast(typing.Optional["AppSpecFunctionCors"], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionEnv"]]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionEnv"]
                ]
            ],
            result,
        )

    @builtins.property
    def git(self) -> typing.Optional["AppSpecFunctionGit"]:
        """git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        """
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecFunctionGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecFunctionGithub"]:
        """github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        """
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecFunctionGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecFunctionGitlab"]:
        """gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        """
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecFunctionGitlab"], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionLogDestination"]
        ]
    ]:
        """log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        """
        result = self._values.get("log_destination")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["AppSpecFunctionLogDestination"],
                ]
            ],
            result,
        )

    @builtins.property
    def routes(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]]
    ]:
        """routes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#routes App#routes}
        """
        result = self._values.get("routes")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]
                ]
            ],
            result,
        )

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        """An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunction(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "disabled": "disabled",
    },
)
class AppSpecFunctionAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        disabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}.
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__143e3ca6aac49eadbd075154e477f46a13154364bc4e84774f7521f00d6b9431
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument rule", value=rule, expected_type=type_hints["rule"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
            check_type(
                argname="argument window",
                value=window,
                expected_type=type_hints["window"],
            )
            check_type(
                argname="argument disabled",
                value=disabled,
                expected_type=type_hints["disabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}."""
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}."""
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}."""
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}."""
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}."""
        result = self._values.get("disabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__039eef56c09a8b874b5085d2c4484b368f506ee512f08e0b3740d20dbe7adf74
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionAlertOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3ff42bf60101ff0399bc892b3277be7ce8d4042f2ef1d9a3bf5090581926b182
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecFunctionAlertOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__46da9eb6d97064e216efa20e3da83dafee9de8bf20dcedbade6ff0b9333cff98
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__232c2bf0222ec236dda02ca4c120453164a2c8c2547a93616993ad0fc2cfb260
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4967c800ce0d72644d288a755103967bdae87b87914ddb142f06feb5d0e5ad6c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56f5b5eae0d4dad0bac1aee3cbd270e191420b8b36b8dda7e1634df27d14bb5e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8164affd75077e8f0de62b087ae9b1182ab2b33adc8b950a72abc631fa64c012
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "disabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "disabled"),
        )

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cb2acd9804a502c965ae5d912e759529b68a8495d47ee44b6178e5fc2f530f8b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "disabled", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__be7b28e578f671068f1fda271449cae7bee8049ae11fc21f537987884589ec15
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8769a0d23971bcc76ab4d236a4d90eac45ba3e4f531debc3f86dd5e1545091f6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "rule", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__db8e51f26ef172b0e655317f4cc2b171acdf5b890b2364e2d51f28cdd0defe23
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__afbbd96dd643cb031d86f90d56bb643923a0a59ee25edd11db1fb63012467e76
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "window", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b0ee4f59e39d16e75b06c1d29021a655331629369ae8aef5d797de243d8f34af
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionCors",
    jsii_struct_bases=[],
    name_mapping={
        "allow_credentials": "allowCredentials",
        "allow_headers": "allowHeaders",
        "allow_methods": "allowMethods",
        "allow_origins": "allowOrigins",
        "expose_headers": "exposeHeaders",
        "max_age": "maxAge",
    },
)
class AppSpecFunctionCors:
    def __init__(
        self,
        *,
        allow_credentials: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[
            typing.Union[
                "AppSpecFunctionCorsAllowOrigins", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        if isinstance(allow_origins, dict):
            allow_origins = AppSpecFunctionCorsAllowOrigins(**allow_origins)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5e408f6ba122ddf6ba19e76ee017a841c153a01468c0cb0b67a28ff3f5bd6656
            )
            check_type(
                argname="argument allow_credentials",
                value=allow_credentials,
                expected_type=type_hints["allow_credentials"],
            )
            check_type(
                argname="argument allow_headers",
                value=allow_headers,
                expected_type=type_hints["allow_headers"],
            )
            check_type(
                argname="argument allow_methods",
                value=allow_methods,
                expected_type=type_hints["allow_methods"],
            )
            check_type(
                argname="argument allow_origins",
                value=allow_origins,
                expected_type=type_hints["allow_origins"],
            )
            check_type(
                argname="argument expose_headers",
                value=expose_headers,
                expected_type=type_hints["expose_headers"],
            )
            check_type(
                argname="argument max_age",
                value=max_age,
                expected_type=type_hints["max_age"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_credentials is not None:
            self._values["allow_credentials"] = allow_credentials
        if allow_headers is not None:
            self._values["allow_headers"] = allow_headers
        if allow_methods is not None:
            self._values["allow_methods"] = allow_methods
        if allow_origins is not None:
            self._values["allow_origins"] = allow_origins
        if expose_headers is not None:
            self._values["expose_headers"] = expose_headers
        if max_age is not None:
            self._values["max_age"] = max_age

    @builtins.property
    def allow_credentials(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``.

        This configures the Access-Control-Allow-Credentials header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        """
        result = self._values.get("allow_credentials")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def allow_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        """
        result = self._values.get("allow_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_methods(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        """
        result = self._values.get("allow_methods")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_origins(self) -> typing.Optional["AppSpecFunctionCorsAllowOrigins"]:
        """allow_origins block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        """
        result = self._values.get("allow_origins")
        return typing.cast(typing.Optional["AppSpecFunctionCorsAllowOrigins"], result)

    @builtins.property
    def expose_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        """
        result = self._values.get("expose_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def max_age(self) -> typing.Optional[builtins.str]:
        """An optional duration specifying how long browsers can cache the results of a preflight request.

        This configures the Access-Control-Max-Age header. Example: ``5h30m``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        result = self._values.get("max_age")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionCors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionCorsAllowOrigins",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact", "prefix": "prefix", "regex": "regex"},
)
class AppSpecFunctionCorsAllowOrigins:
    def __init__(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f1428671654e83ce5ba5594c3eefe8119fecf7d0980c6d551be82117c8a895dc
            )
            check_type(
                argname="argument exact", value=exact, expected_type=type_hints["exact"]
            )
            check_type(
                argname="argument prefix",
                value=prefix,
                expected_type=type_hints["prefix"],
            )
            check_type(
                argname="argument regex", value=regex, expected_type=type_hints["regex"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact
        if prefix is not None:
            self._values["prefix"] = prefix
        if regex is not None:
            self._values["regex"] = regex

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        """Exact string match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        """
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        """Prefix-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        """
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def regex(self) -> typing.Optional[builtins.str]:
        """RE2 style regex-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        result = self._values.get("regex")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionCorsAllowOrigins(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionCorsAllowOriginsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionCorsAllowOriginsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15e07c50d27d6b1b498bce703c3aec295d02238298e49d7a52e091e667ebb439
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetRegex")
    def reset_regex(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegex", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regexInput")
    def regex_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__52be6f401e908d761d34557ef6b54792edfa2fb336ec752d6165cab092915d19
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "exact", value)

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2c3cff0688eb2247d4ed132a7fbbea95e0d77ac04083c3ca0b009402f73b8048
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "prefix", value)

    @builtins.property
    @jsii.member(jsii_name="regex")
    def regex(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "regex"))

    @regex.setter
    def regex(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e56cbe488c39d9738553b6e6baa69442046145580f0ca80d06ba5c4117027c5d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "regex", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionCorsAllowOrigins]:
        return typing.cast(
            typing.Optional[AppSpecFunctionCorsAllowOrigins],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionCorsAllowOrigins],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4375f86e23242a19f5e9a5df5a1e5a12afce98e354333f8cc7206e40d7aa28d3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionCorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionCorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8f41864b6291c61c8aec764f060118c23260d09cde7bcf8016dd53d541d89b9f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAllowOrigins")
    def put_allow_origins(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        value = AppSpecFunctionCorsAllowOrigins(exact=exact, prefix=prefix, regex=regex)

        return typing.cast(None, jsii.invoke(self, "putAllowOrigins", [value]))

    @jsii.member(jsii_name="resetAllowCredentials")
    def reset_allow_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowCredentials", []))

    @jsii.member(jsii_name="resetAllowHeaders")
    def reset_allow_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowHeaders", []))

    @jsii.member(jsii_name="resetAllowMethods")
    def reset_allow_methods(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowMethods", []))

    @jsii.member(jsii_name="resetAllowOrigins")
    def reset_allow_origins(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowOrigins", []))

    @jsii.member(jsii_name="resetExposeHeaders")
    def reset_expose_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExposeHeaders", []))

    @jsii.member(jsii_name="resetMaxAge")
    def reset_max_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxAge", []))

    @builtins.property
    @jsii.member(jsii_name="allowOrigins")
    def allow_origins(self) -> AppSpecFunctionCorsAllowOriginsOutputReference:
        return typing.cast(
            AppSpecFunctionCorsAllowOriginsOutputReference,
            jsii.get(self, "allowOrigins"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowCredentialsInput")
    def allow_credentials_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "allowCredentialsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowHeadersInput")
    def allow_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "allowHeadersInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowMethodsInput")
    def allow_methods_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "allowMethodsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowOriginsInput")
    def allow_origins_input(self) -> typing.Optional[AppSpecFunctionCorsAllowOrigins]:
        return typing.cast(
            typing.Optional[AppSpecFunctionCorsAllowOrigins],
            jsii.get(self, "allowOriginsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="exposeHeadersInput")
    def expose_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "exposeHeadersInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="maxAgeInput")
    def max_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentials")
    def allow_credentials(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "allowCredentials"),
        )

    @allow_credentials.setter
    def allow_credentials(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b380c83f9ed466f1a572b4bfbfedfe3495bfe6ae548dbf49ba5ee5af24882a0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowCredentials", value)

    @builtins.property
    @jsii.member(jsii_name="allowHeaders")
    def allow_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowHeaders"))

    @allow_headers.setter
    def allow_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5b4eb0cb2c20ff2cfa51a4be56d267df20de07879622e980ff622c5611a88e3a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowHeaders", value)

    @builtins.property
    @jsii.member(jsii_name="allowMethods")
    def allow_methods(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowMethods"))

    @allow_methods.setter
    def allow_methods(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1297f31f66fd6a622ef06619d954d34264c065461cbc0f9b4b225aef3c806ad1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowMethods", value)

    @builtins.property
    @jsii.member(jsii_name="exposeHeaders")
    def expose_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "exposeHeaders"))

    @expose_headers.setter
    def expose_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4428bac869e13b208783747b4444c1655f9225e6c518c91c8c7a4d7d37edc6f9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "exposeHeaders", value)

    @builtins.property
    @jsii.member(jsii_name="maxAge")
    def max_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxAge"))

    @max_age.setter
    def max_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b07059acb73695e81334f100b8e9e14b841e9de619875b625ee2db352de2cb0a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "maxAge", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionCors]:
        return typing.cast(
            typing.Optional[AppSpecFunctionCors], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionCors]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1bdbe0b6c8ef7977a56de07d83c980cdbcb773d376810727fb9a8646ec960145
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecFunctionEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__af94710578d3426c78190364e5810cdff1b3a6eaa6837efc4418e25bf83ea1c2
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        """The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        """
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c6ddbaf2a0340f7f2addb8deb47d7b3cd84aa03fdd0accc7f771f23c8cc558c
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1ab057e86169f3fb2b500254944b2faa259a2169a5b198d2fca8f334df10b3ba
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecFunctionEnvOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5699b64ce2e0910d54e80b76b3d6d7ad5e514fc208e912646d944457a47ee3cb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__680a11658c56b2b6b6453e019d45db6b132d1bbd18bab83cadde2812f84af35b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b649b64de73ff87426c3469e9e680297883fcc657e910311626646a084c719e2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4ccbb821e84609b883c58195c776fd85a14472d8d1ea6b307076c722dce1ccb0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8008a9e8c2aefca9e9aa25cb53631c842e46fc6d4c7a39a5927ee1066c4b5a90
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d74d127b2b73def9daabc71008f267fd1a9417f422ff50048c4ce443c80e2cfc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2bb5c08dc1042dc4c18b70dfb4f957911c3db22e74a6682f39f19a6cca202140
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scope", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__82757b89450558d5f9762be7afabbfafb50a206e0012bef3ed1ecad247f23a94
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3059b1eaee6ea047170a6b0314f3672aa7aa7fc29a797240138b8b165769e38c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__49415869a5c9d54dfe64a83b98f14cb7af2b07826da26cdfb43189ab808f47e2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecFunctionGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__221635171c00a66deb1f01fdd951431a67f6ff6d470933cce4e81d6ec850cb04
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument repo_clone_url",
                value=repo_clone_url,
                expected_type=type_hints["repo_clone_url"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        """The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d013edb8871edb48e2eb7bb4d7250029113755161e0807d2839d3013e8073b10
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput")
        )

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4d9bdf584b5f05d5a1b5ab9927ec881f1899343e83cd87f526772a6ffbbb8a47
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d3e2f358443402bdf1c55d2e946deea3edecdc779f94949f3dc8159f65a15b9b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repoCloneUrl", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionGit]:
        return typing.cast(
            typing.Optional[AppSpecFunctionGit], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f17578b946bcc3ca90f13e90fd90e62110d0285466284fce70a7cb8bb189ea3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecFunctionGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__88d863275bccaed956728532b717debe2ae77a1edf58892ab6d085156ba84b75
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1c11c685804c14fb8d7eb317734dad37d85d25edc651f05639f0abf43fb88a83
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__078baa9b95c8cc1cb68f721979a39d3780fba4367c146f5ae6aa53aa542452f0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5082aa677781d03642318655e8e64e93221979e76e0ff1f03dc74036e9389618
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1549fc5705c4600cddcc136f34948e715be0b4b41d20ae93525b6534e2bfd3d0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionGithub]:
        return typing.cast(
            typing.Optional[AppSpecFunctionGithub], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bbc866ffdeb1f227d75c240e77fb4e21c84f4f7c3e553b87832e99f161254e4f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecFunctionGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7c3b6bb8fa457815dda961523dbce54696cb0f816f45d6af02b3610a27563c36
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__12f98109dcc3cf74b6f0e0de1300aa919560e06c0d092e0134620b0f39744cb5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ea93dc866f6317a67c6081c695a27d9b705c902ad37654e11332c4d109a41b6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__01fd76cc7ec23b1f3ee6a0e0517bf3c5885cc87776cb9cf0e68b1a8665a632a3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5634589332fe9fe635d549626750a3c287ad15cc80491881d024f157d82578a9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionGitlab]:
        return typing.cast(
            typing.Optional[AppSpecFunctionGitlab], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5fa0c67cc34fdf4a9111ab5584ccc83372f4f2d98d020df9994584f7342833d8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1dd5216e710ffaaf201a9cbd4938f3e1a4387737a57e9a4896d7c6d2e1e0cd22
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d15e4780fa44e7e799a2ac4ae8178e17f04c8a8920c31273d55ee573b0366106
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecFunctionOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a412a35cad2b82402ce06596c0d056780b88c7a8c81adaa9bbb4cd8beb9034aa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__acd15799a49d492555a7c58010d7c1e3774c40167d3c30ded26046f5a252575c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e6fd8109c8068b1d23cf81d8eadbb8956f281018bd6ff585836b24d82f7ba746
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__700e548177b0e91284d4e403d33b5789b9c9dca87c27ff967cd21948f091d220
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "papertrail": "papertrail",
    },
)
class AppSpecFunctionLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[
            typing.Union[
                "AppSpecFunctionLogDestinationDatadog",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        logtail: typing.Optional[
            typing.Union[
                "AppSpecFunctionLogDestinationLogtail",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        papertrail: typing.Optional[
            typing.Union[
                "AppSpecFunctionLogDestinationPapertrail",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        if isinstance(datadog, dict):
            datadog = AppSpecFunctionLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecFunctionLogDestinationLogtail(**logtail)
        if isinstance(papertrail, dict):
            papertrail = AppSpecFunctionLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dfe075f8a06b478a90191a318e9d1f24f6cf5be3766abe9a1d7082a8ea9dc353
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument datadog",
                value=datadog,
                expected_type=type_hints["datadog"],
            )
            check_type(
                argname="argument logtail",
                value=logtail,
                expected_type=type_hints["logtail"],
            )
            check_type(
                argname="argument papertrail",
                value=papertrail,
                expected_type=type_hints["papertrail"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecFunctionLogDestinationDatadog"]:
        """datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        """
        result = self._values.get("datadog")
        return typing.cast(
            typing.Optional["AppSpecFunctionLogDestinationDatadog"], result
        )

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecFunctionLogDestinationLogtail"]:
        """logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        """
        result = self._values.get("logtail")
        return typing.cast(
            typing.Optional["AppSpecFunctionLogDestinationLogtail"], result
        )

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecFunctionLogDestinationPapertrail"]:
        """papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        result = self._values.get("papertrail")
        return typing.cast(
            typing.Optional["AppSpecFunctionLogDestinationPapertrail"], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecFunctionLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8192b195c034b5f8867de43a7d87b2f47d1d08b3b5f7ff9a1f753651f2fcfcda
            )
            check_type(
                argname="argument api_key",
                value=api_key,
                expected_type=type_hints["api_key"],
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        """Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        """
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        """Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d6cc99b83fa835e5aa9152e8114f8b0b33675ac6d42b783f922a202a062e0b53
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fced31af0cfe57ee3d9291c634d66eaf19bd0b37a42f4886af3bb49980a662db
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiKey", value)

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__75d6217fd33a1d36b2abd1daa6ae41043103dfa1ab2bd6e8261323819f56d512
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecFunctionLogDestinationDatadog],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__50fd2f2eef61729b62ce3b67ef445d90362b46718ae3530cc8d60b434c68d816
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e91034db952403acb5c54ca4e125ba12803cbccc0e843daea17573cb266ef189
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionLogDestinationOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f60da452eddd5ef33e3065fdc7fb6866c58828ee02afeb771cd7979f57766a8a
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecFunctionLogDestinationOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__50574085086a9e59dcb19fe0c16cfea66b670d703a31257d408a230cc9ec574b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c3dcebae90e65ccc615a90273dd7ca081eddcb364980dbf055c6b895168cfd90
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1fde8b655ea4883e27a56a2d555315782df427683d1c7ab0360c70d5c7fd6578
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecFunctionLogDestination],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e1a6446a8c015a75ce3b7140d09ca8dc4b87ea547137b353bdd0107ea25f7e7e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecFunctionLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b72858795d854a40729964ca2e6092e34ef03a952a8e034ae5a47b0e295f6401
            )
            check_type(
                argname="argument token", value=token, expected_type=type_hints["token"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        """Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__68c31a59f7d2d70d71f0181f5f3d4e6a772e16b5a2fb217868eb0657e1f2ca04
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__44cdd71ad157c468618942f810a8a52ec7e157b96d2df3656983c7d1415ce1ae
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "token", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecFunctionLogDestinationLogtail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__286468fc19f48a926bfd90e0fb2c082b8c1f98041aaf8c66ac1e7addd4a3ec5c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__56b4a95f444c34bc85e340eb17948dbb8dc770f4a6a7f41c7af1701ce666e722
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecFunctionLogDestinationDatadog(api_key=api_key, endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        value = AppSpecFunctionLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecFunctionLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecFunctionLogDestinationDatadogOutputReference:
        return typing.cast(
            AppSpecFunctionLogDestinationDatadogOutputReference,
            jsii.get(self, "datadog"),
        )

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecFunctionLogDestinationLogtailOutputReference:
        return typing.cast(
            AppSpecFunctionLogDestinationLogtailOutputReference,
            jsii.get(self, "logtail"),
        )

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecFunctionLogDestinationPapertrailOutputReference":
        return typing.cast(
            "AppSpecFunctionLogDestinationPapertrailOutputReference",
            jsii.get(self, "papertrail"),
        )

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecFunctionLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecFunctionLogDestinationDatadog],
            jsii.get(self, "datadogInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecFunctionLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecFunctionLogDestinationLogtail],
            jsii.get(self, "logtailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(
        self,
    ) -> typing.Optional["AppSpecFunctionLogDestinationPapertrail"]:
        return typing.cast(
            typing.Optional["AppSpecFunctionLogDestinationPapertrail"],
            jsii.get(self, "papertrailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__642eeca52178449887b09e2c25a985a38e07046e8ccb6ffca2072370def4d5d0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15a885846594c2ad1bd27b17194bcc4167cc6bcd540ea4327b618996db97bed6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecFunctionLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f5c2cd5e2992724cafc2f8b1a4308888e4cf5176699803440507f16b0e71907
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        """Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__76a21ac0626870a2de9243ae9e97e5a6097b677f69e6fd10853e3e15fcc67c86
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__50454607105d98255553872008aadea28cf4c4c4c0b6dbcfccb3ea5c4b3cdebf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[AppSpecFunctionLogDestinationPapertrail]:
        return typing.cast(
            typing.Optional[AppSpecFunctionLogDestinationPapertrail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f1f8a545f8acb2b85f24b5de3bdb5531b0f0540f41adb7c6489bca88e1977ec
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__01f6634052b31e69f85b769d3f4e5dc0ce83594cd15e423a564bb09f4a9dd68e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecFunctionAlert, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c75b0e35d60ddccd25e45b6dccf7cb28d6760d16594658ba11be7716aec38cbf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putCors")
    def put_cors(
        self,
        *,
        allow_credentials: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[
            typing.Union[
                AppSpecFunctionCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        value = AppSpecFunctionCors(
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )

        return typing.cast(None, jsii.invoke(self, "putCors", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecFunctionEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a488b005f65666b59fbc243eea157c58f8c98aa0642cbdc4edda69dbc199d2fe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        value = AppSpecFunctionGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecFunctionGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecFunctionGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecFunctionLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8bb9eed259eb37e5246d3edde9daea3bdfbb9e2fabb4f7fcff72f2d7c15f2797
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="putRoutes")
    def put_routes(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "AppSpecFunctionRoutes", typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7affdde1e9f2b006fbfdbb2a824b3b27b2d819d4f538135b6490de28ea701acc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putRoutes", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetCors")
    def reset_cors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCors", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRoutes")
    def reset_routes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoutes", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecFunctionAlertList:
        return typing.cast(AppSpecFunctionAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="cors")
    def cors(self) -> AppSpecFunctionCorsOutputReference:
        return typing.cast(AppSpecFunctionCorsOutputReference, jsii.get(self, "cors"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecFunctionEnvList:
        return typing.cast(AppSpecFunctionEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecFunctionGitOutputReference:
        return typing.cast(AppSpecFunctionGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecFunctionGithubOutputReference:
        return typing.cast(
            AppSpecFunctionGithubOutputReference, jsii.get(self, "github")
        )

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecFunctionGitlabOutputReference:
        return typing.cast(
            AppSpecFunctionGitlabOutputReference, jsii.get(self, "gitlab")
        )

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecFunctionLogDestinationList:
        return typing.cast(
            AppSpecFunctionLogDestinationList, jsii.get(self, "logDestination")
        )

    @builtins.property
    @jsii.member(jsii_name="routes")
    def routes(self) -> "AppSpecFunctionRoutesList":
        return typing.cast("AppSpecFunctionRoutesList", jsii.get(self, "routes"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]
                ]
            ],
            jsii.get(self, "alertInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="corsInput")
    def cors_input(self) -> typing.Optional[AppSpecFunctionCors]:
        return typing.cast(
            typing.Optional[AppSpecFunctionCors], jsii.get(self, "corsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]
                ]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecFunctionGithub]:
        return typing.cast(
            typing.Optional[AppSpecFunctionGithub], jsii.get(self, "githubInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecFunctionGit]:
        return typing.cast(
            typing.Optional[AppSpecFunctionGit], jsii.get(self, "gitInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecFunctionGitlab]:
        return typing.cast(
            typing.Optional[AppSpecFunctionGitlab], jsii.get(self, "gitlabInput")
        )

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecFunctionLogDestination],
                ]
            ],
            jsii.get(self, "logDestinationInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="routesInput")
    def routes_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]
                ]
            ],
            jsii.get(self, "routesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "sourceDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bda339f2afeac86b62beb356c7f12df0878ca16df023ba0bd0a8f3f1dee28950
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c0efc4ee34c5cb64b53db0ab4fb24c3255cc0c3239ef3d6d845e332d430332d2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "sourceDir", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b8fd0fa32e34c5068a3d57d43410943f197a5ab20dc7af3120ffd4d0fc688f9e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecFunctionRoutes",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "preserve_path_prefix": "preservePathPrefix"},
)
class AppSpecFunctionRoutes:
    def __init__(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param path: Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#path App#path}
        :param preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6ca2d14868e49a58de2b505913734d01086cafee7a1f944392f551761cb0bf47
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument preserve_path_prefix",
                value=preserve_path_prefix,
                expected_type=type_hints["preserve_path_prefix"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path
        if preserve_path_prefix is not None:
            self._values["preserve_path_prefix"] = preserve_path_prefix

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path specifies an route by HTTP path prefix.

        Paths must start with / and must be unique within the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#path App#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_path_prefix(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """An optional flag to preserve the path that is forwarded to the backend service.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        """
        result = self._values.get("preserve_path_prefix")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionRoutes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionRoutesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionRoutesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b0783666b96a4132b7ea0ff9bd9a5c4cc7b5c0e12c0087e9f19b9052868fb816
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionRoutesOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e74d606d00620d592ceebe95dddac745b92fe3bbc0e6a842dc2b161ae7a8f324
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecFunctionRoutesOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aca64982cab2a540a5dcf1127be9c31a028491474fa509a9aecda40a8184eacc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1978d69df1d7ecf7e6679a86276b00c571147ff39d5630c6df463a49655c9eb0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c8ccd0ed1ba47596f2aa4bff9e84d3cf4787af871b4d8e703a9284cac548eb17
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd6fe6b32eec3d3956a9d99e74767fc17875b42d92853edc06c55d2f29666b28
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecFunctionRoutesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecFunctionRoutesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8db7e24b4a995ea9bd317f2ae3b54b08eb92e47e597e560970a6923195d229b6
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPreservePathPrefix")
    def reset_preserve_path_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreservePathPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefixInput")
    def preserve_path_prefix_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "preservePathPrefixInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5c89d3824a482a7ee13a0e9e994554b071588710c4f7f2bf664a523cf64cf2df
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefix")
    def preserve_path_prefix(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "preservePathPrefix"),
        )

    @preserve_path_prefix.setter
    def preserve_path_prefix(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__45f9e437debbe2898df0afacd83a48ff104000089a91f4a814a25e24d15e0c96
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "preservePathPrefix", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__091da90aeef315345b881fa909a8b09469ef98d42681f323b24bc81bc6913497
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJob",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "build_command": "buildCommand",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "image": "image",
        "instance_count": "instanceCount",
        "instance_size_slug": "instanceSizeSlug",
        "kind": "kind",
        "log_destination": "logDestination",
        "run_command": "runCommand",
        "source_dir": "sourceDir",
    },
)
class AppSpecJob:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecJobAlert", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        build_command: typing.Optional[builtins.str] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union["AppSpecJobEnv", typing.Dict[builtins.str, typing.Any]]
                ],
            ]
        ] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        git: typing.Optional[
            typing.Union["AppSpecJobGit", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        github: typing.Optional[
            typing.Union["AppSpecJobGithub", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        gitlab: typing.Optional[
            typing.Union["AppSpecJobGitlab", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        image: typing.Optional[
            typing.Union["AppSpecJobImage", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        instance_count: typing.Optional[jsii.Number] = None,
        instance_size_slug: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        log_destination: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecJobLogDestination",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        run_command: typing.Optional[builtins.str] = None,
        source_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        :param image: image block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#image App#image}
        :param instance_count: The amount of instances that this component should be scaled to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_count App#instance_count}
        :param instance_size_slug: The instance size to use for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_size_slug App#instance_size_slug}
        :param kind: The type of job and when it will be run during the deployment process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#kind App#kind}
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        :param run_command: An optional run command to override the component's default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#run_command App#run_command}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        if isinstance(git, dict):
            git = AppSpecJobGit(**git)
        if isinstance(github, dict):
            github = AppSpecJobGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecJobGitlab(**gitlab)
        if isinstance(image, dict):
            image = AppSpecJobImage(**image)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c7e8ec9c99d37a1aa76dfa576e8b90fbc690a24431452ab7c9be78f465adb99b
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument alert", value=alert, expected_type=type_hints["alert"]
            )
            check_type(
                argname="argument build_command",
                value=build_command,
                expected_type=type_hints["build_command"],
            )
            check_type(
                argname="argument dockerfile_path",
                value=dockerfile_path,
                expected_type=type_hints["dockerfile_path"],
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument environment_slug",
                value=environment_slug,
                expected_type=type_hints["environment_slug"],
            )
            check_type(
                argname="argument git", value=git, expected_type=type_hints["git"]
            )
            check_type(
                argname="argument github",
                value=github,
                expected_type=type_hints["github"],
            )
            check_type(
                argname="argument gitlab",
                value=gitlab,
                expected_type=type_hints["gitlab"],
            )
            check_type(
                argname="argument image", value=image, expected_type=type_hints["image"]
            )
            check_type(
                argname="argument instance_count",
                value=instance_count,
                expected_type=type_hints["instance_count"],
            )
            check_type(
                argname="argument instance_size_slug",
                value=instance_size_slug,
                expected_type=type_hints["instance_size_slug"],
            )
            check_type(
                argname="argument kind", value=kind, expected_type=type_hints["kind"]
            )
            check_type(
                argname="argument log_destination",
                value=log_destination,
                expected_type=type_hints["log_destination"],
            )
            check_type(
                argname="argument run_command",
                value=run_command,
                expected_type=type_hints["run_command"],
            )
            check_type(
                argname="argument source_dir",
                value=source_dir,
                expected_type=type_hints["source_dir"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if build_command is not None:
            self._values["build_command"] = build_command
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if image is not None:
            self._values["image"] = image
        if instance_count is not None:
            self._values["instance_count"] = instance_count
        if instance_size_slug is not None:
            self._values["instance_size_slug"] = instance_size_slug
        if kind is not None:
            self._values["kind"] = kind
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if run_command is not None:
            self._values["run_command"] = run_command
        if source_dir is not None:
            self._values["source_dir"] = source_dir

    @builtins.property
    def name(self) -> builtins.str:
        """The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlert"]]
    ]:
        """alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        """
        result = self._values.get("alert")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlert"]
                ]
            ],
            result,
        )

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        """An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        """
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        """The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        """
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobEnv"]]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobEnv"]]
            ],
            result,
        )

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        """An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        """
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecJobGit"]:
        """git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        """
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecJobGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecJobGithub"]:
        """github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        """
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecJobGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecJobGitlab"]:
        """gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        """
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecJobGitlab"], result)

    @builtins.property
    def image(self) -> typing.Optional["AppSpecJobImage"]:
        """image block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#image App#image}
        """
        result = self._values.get("image")
        return typing.cast(typing.Optional["AppSpecJobImage"], result)

    @builtins.property
    def instance_count(self) -> typing.Optional[jsii.Number]:
        """The amount of instances that this component should be scaled to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_count App#instance_count}
        """
        result = self._values.get("instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_size_slug(self) -> typing.Optional[builtins.str]:
        """The instance size to use for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_size_slug App#instance_size_slug}
        """
        result = self._values.get("instance_size_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        """The type of job and when it will be run during the deployment process.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#kind App#kind}
        """
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobLogDestination"]
        ]
    ]:
        """log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        """
        result = self._values.get("log_destination")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobLogDestination"]
                ]
            ],
            result,
        )

    @builtins.property
    def run_command(self) -> typing.Optional[builtins.str]:
        """An optional run command to override the component's default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#run_command App#run_command}
        """
        result = self._values.get("run_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        """An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJob(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "disabled": "disabled",
    },
)
class AppSpecJobAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        disabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}.
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e63017acee2aa06d0b579073323e25dee85d5f0469b147aa05b0cfd60b519b43
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument rule", value=rule, expected_type=type_hints["rule"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
            check_type(
                argname="argument window",
                value=window,
                expected_type=type_hints["window"],
            )
            check_type(
                argname="argument disabled",
                value=disabled,
                expected_type=type_hints["disabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}."""
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}."""
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}."""
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}."""
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}."""
        result = self._values.get("disabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e9fd97f45cb86fea7d1b8cfa6f76ce09120efdcbe7fbb8b0f7f706b0dcd25f52
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobAlertOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d35e19424325caf5266e3f75c1cb1631f3fdf23cb56ce2c08c904b7786cc3b4f
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecJobAlertOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c34c3a28babed84cebb2818b5f5bab49c551a828b2a6da1d59e93c086f8e9e02
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e1ae5c9b380a75c464e8ede65604492eef91c8c472dc337b9e3e843cfc388439
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__399a41fb691892965ebd298ea11b4d7f5ee736d8cea95d7c35d99eefbd5a7ab5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dfbb71570cd50899a48ff663f6dd872ccc4cd772c1a9d45e736ad621f270d20f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d14537aae0afd9207fc8a3618aef468065354b79d6fb2049a46746cbc171b10b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "disabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "disabled"),
        )

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fe9c3a2332754c62c71feb5204e50e2a79cd76e6790397ea00e9b7bf2758c72d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "disabled", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3cf14d9942abdcedc01888418cc4a639f70b53ab5d8e727211f1a21a38915de0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__996bcbdce536ac36fe292bd43f410ec56dafbcc4d0993fa0971a8cd492ab4514
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "rule", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d79a235069f222f1e22b9b139ad3b44d2eee7452e8b321d4e321a53fb806a6ad
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cb796d2cb46d38c278beaeedd52b35ce5a13e7f857cfa40625145eb1b0227ce9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "window", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b5712c6b65600e43d811cfd4bce20b8e7427573166844990c4ead91e642e65ea
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecJobEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15ae820b7b6ecf88c3f3273fd65ed44d6a0056e159a8ab5c0da82c3d78cc9910
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        """The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        """
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__053e356cc168fd34f33ff975e043ca1e6dd817d30813b3e6be84b979e2be6d9f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2109f2550d7ee9eaa82e7667d83e6f149e7a5f266b3c04a529447909290ca5ad
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecJobEnvOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__70fc48d996185a4f4d1ab9b89c7f265cac4e6da044d551e86fbf5efd28d33018
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f14a01dfdb408bb3e435fdd71f336a53831c13a7e227790a0c8d6d0bd6de8405
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aa7f7cf9c89056266a1ae5a0aa125adfa36e604fe33543b28e9c60a803689ef2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2921ada85a270f07bd3e6149dfa11036e4520c022e6b2d8414c7e2108cb1ab3b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c936b273e720dcfe9420955e441ab0c35265fd48f81ccdb5be7e421d0e5397b7
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aefd4be59fdc135e7cf7fdf01666f4cc4a1924890417c0603af4d17b3e41ca00
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bb2b934a2a7757911646725917c724ad3f0716414b6d61e3f83f1ef160bb1d51
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scope", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca9b0da7db3f976cfe5390275260f8c077726bb2ceabde54407887ae1997abc9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__14f573e68a8b9a469e640c7bfc25e4a4e9ee2422a8d90d2d20594d5d85b40ffb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__98978b77a0d12a3f99bcca511aadd9f29c0e0fa4e89439f5375858425b2ebd9f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecJobGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__363565efc96ba7ac31265ae54fae2dcb14d0580bc6ec894ae8a414c374a0cd35
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument repo_clone_url",
                value=repo_clone_url,
                expected_type=type_hints["repo_clone_url"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        """The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__701bd4c7176cdbda7979081143e079a6d231208cb02e4d2c6d38ab3e54c56e80
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput")
        )

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f806de3df1569aab6f21f346279d7a6feb2da6be51b59ebe30dbbab3a4ef5fb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__40fe5979c3477eb46146714fcbc3b1f0cf430b196b9795725ad60173f038609c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repoCloneUrl", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobGit]:
        return typing.cast(
            typing.Optional[AppSpecJobGit], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b6ce060e55407e9ed62fa66e5da731c1b968e69393fa37364d0bdbef010ea4c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecJobGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__adafad65266c8df1cea1469bd85c0b4d2afcae151a1e52ec7322d0d948ebfd21
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5a4e12e5c36a24619414027aecd41f1053eb51fad584d3283b273c4204092b5b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7506ba981be99f398307f1b7bf43cfa3c2cc3b5e3992737c931b3c1714dad568
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4531a31a09dd465661d58df1fa67b1cdace71112e878a3c17d108c7bf07bc467
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1ab5f3ecada5e1911783c9fd49065e05ef6a60c350d18ce0f5a436f831ef8854
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobGithub]:
        return typing.cast(
            typing.Optional[AppSpecJobGithub], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8fcfb9c8d315b12ba0b713b7c25851590e6058957ef04e083eed30437d731205
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecJobGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f294692bf3f83b2735ab554c382eff16ac8c0bd117fbc97a31bf6215bfd2121d
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3bb4f93244832314f84d85960d6c6b15ed2ca77b55567735a34855b894d9ce05
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__40d9646a1cc811839a03231cc4cd72c52a7435f1b040c6f0d85bd4f33e01432e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ef59055696a271187e28d32ef63d797b2113a50bbd9ac0f7db6a6766209f912e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__99b3dd75fc52ab2f264762a408e49d98cbb821341d22f1c927645cdf5f239847
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobGitlab]:
        return typing.cast(
            typing.Optional[AppSpecJobGitlab], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__12de7779be4e3b264d30af0cb716ce78bc96cf03da22671f595a9a60e4da51e9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobImage",
    jsii_struct_bases=[],
    name_mapping={
        "registry_type": "registryType",
        "repository": "repository",
        "deploy_on_push": "deployOnPush",
        "registry": "registry",
        "tag": "tag",
    },
)
class AppSpecJobImage:
    def __init__(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecJobImageDeployOnPush",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        registry: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        :param tag: The repository tag. Defaults to latest if not provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a4c21f141fa35fff02299d45a74c7c196ddef153232893a1d894287801be6f9f
            )
            check_type(
                argname="argument registry_type",
                value=registry_type,
                expected_type=type_hints["registry_type"],
            )
            check_type(
                argname="argument repository",
                value=repository,
                expected_type=type_hints["repository"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument registry",
                value=registry,
                expected_type=type_hints["registry"],
            )
            check_type(
                argname="argument tag", value=tag, expected_type=type_hints["tag"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "registry_type": registry_type,
            "repository": repository,
        }
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if registry is not None:
            self._values["registry"] = registry
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def registry_type(self) -> builtins.str:
        """The registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        """
        result = self._values.get("registry_type")
        assert result is not None, "Required property 'registry_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        """The repository name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        """
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobImageDeployOnPush"]
        ]
    ]:
        """deploy_on_push block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["AppSpecJobImageDeployOnPush"],
                ]
            ],
            result,
        )

    @builtins.property
    def registry(self) -> typing.Optional[builtins.str]:
        """The registry name. Must be left empty for the DOCR registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        """
        result = self._values.get("registry")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag(self) -> typing.Optional[builtins.str]:
        """The repository tag. Defaults to latest if not provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        result = self._values.get("tag")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobImage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobImageDeployOnPush",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AppSpecJobImageDeployOnPush:
    def __init__(
        self,
        *,
        enabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param enabled: Whether to automatically deploy images pushed to DOCR. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#enabled App#enabled}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__896407ad426a72e4f16b3b0f944e3cf0c56b7007060486fe2f51d5d1a01c9f91
            )
            check_type(
                argname="argument enabled",
                value=enabled,
                expected_type=type_hints["enabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy images pushed to DOCR.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#enabled App#enabled}
        """
        result = self._values.get("enabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobImageDeployOnPush(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobImageDeployOnPushList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobImageDeployOnPushList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a9bc7555b9721052a7d4674d0c6c02da05c6d87912e50fbac2c131d81f148e53
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobImageDeployOnPushOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__933b41680106ac61da661e7fa871388a7e964d44e257ece2de6b0ca4e44696c8
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecJobImageDeployOnPushOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ec62abbfb9cee1ddb7b31b180c3d67413a5dda33e442fc74cf200cc63a100b0d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7f434ac3ef71ca599cb1176f556b32af6afc9e869b3f08b7a796a04ae5af6c3a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ed1ae0f5f40effe17f443c3895644b6482b9ba092981ef236460857ff9d1e717
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecJobImageDeployOnPush],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8492e91c4022316cff31a503e54e054aef7135c4b45c1bfabd33fe058687a489
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobImageDeployOnPushOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobImageDeployOnPushOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d7b532283a02000f987e60cbe148aa5519bee818e84e74b40ba3ba4c718bdcd3
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "enabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "enabled"),
        )

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85f326684634192cf8386c41cb0f187cce26eab03ca1813edf58ebc597983504
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "enabled", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c315e7c1d80053a10766459b6d53704bec457bcb761552f86631f80e63dad4f3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobImageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobImageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__75ca5d1f673747354bb4841f18c7e7678d32d5b4039ec3d2f81a010054d129c7
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDeployOnPush")
    def put_deploy_on_push(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecJobImageDeployOnPush, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5d8ff90c6ef8a024d432776afaa80f7a0fe1edab9df77fe02eb25cf11eb5e879
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putDeployOnPush", [value]))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRegistry")
    def reset_registry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistry", []))

    @jsii.member(jsii_name="resetTag")
    def reset_tag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTag", []))

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(self) -> AppSpecJobImageDeployOnPushList:
        return typing.cast(
            AppSpecJobImageDeployOnPushList, jsii.get(self, "deployOnPush")
        )

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecJobImageDeployOnPush],
                ]
            ],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="registryInput")
    def registry_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "registryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="registryTypeInput")
    def registry_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "registryTypeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="repositoryInput")
    def repository_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repositoryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tagInput")
    def tag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagInput"))

    @builtins.property
    @jsii.member(jsii_name="registry")
    def registry(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registry"))

    @registry.setter
    def registry(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__06633f6703c56eb222928516ae6160b30e1c34470f9cd8ec9b0aa1a869876a3a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "registry", value)

    @builtins.property
    @jsii.member(jsii_name="registryType")
    def registry_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryType"))

    @registry_type.setter
    def registry_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8c129ab7ad95b6a16b3d09811c71dc8a2b1c5550d32285486b89973f5f131f49
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "registryType", value)

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repository"))

    @repository.setter
    def repository(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ff6ff0e2c699630bd1e33b83e4bc770188e243f5ce07bc85424a0f8000ef4b98
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repository", value)

    @builtins.property
    @jsii.member(jsii_name="tag")
    def tag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tag"))

    @tag.setter
    def tag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__abeea83690f20bb36de806995080521e2fc34a77fa901cd89df2a46b651b657e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "tag", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobImage]:
        return typing.cast(
            typing.Optional[AppSpecJobImage], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobImage]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__38101bef42168677ea8a67a97e0a76372e76175fee2895d609f599201b022962
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9c2dbec2e8f8cf6e55badcd92e02083ed29af65926893bc3332f74333646ee6b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__36912900e6b339674f206778642410bde3f8968798deb8efab8ed40610f13b0b
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecJobOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dea49d50840f0e6147fd6c9587ed4803ba824171d7077b527c4ad109ab0e3806
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0e0f37e00b80f27ec927b9ac6952a9e64bc6a1f0f81cfbc6dac96e2914ba465
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0c48fe6b93b085efb64b74d17f4ca8ee33651ba052e8df484cd1ff4ff4aa26b5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb0174e30dbb20f8c2b1bfab10568ec9f572cde9822388095966323c84e4338b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "papertrail": "papertrail",
    },
)
class AppSpecJobLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[
            typing.Union[
                "AppSpecJobLogDestinationDatadog", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        logtail: typing.Optional[
            typing.Union[
                "AppSpecJobLogDestinationLogtail", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        papertrail: typing.Optional[
            typing.Union[
                "AppSpecJobLogDestinationPapertrail",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        if isinstance(datadog, dict):
            datadog = AppSpecJobLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecJobLogDestinationLogtail(**logtail)
        if isinstance(papertrail, dict):
            papertrail = AppSpecJobLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__da4d891e56ee9612d2140e139d0cec4675205d881b26492d72333012fce9127f
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument datadog",
                value=datadog,
                expected_type=type_hints["datadog"],
            )
            check_type(
                argname="argument logtail",
                value=logtail,
                expected_type=type_hints["logtail"],
            )
            check_type(
                argname="argument papertrail",
                value=papertrail,
                expected_type=type_hints["papertrail"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecJobLogDestinationDatadog"]:
        """datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        """
        result = self._values.get("datadog")
        return typing.cast(typing.Optional["AppSpecJobLogDestinationDatadog"], result)

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecJobLogDestinationLogtail"]:
        """logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        """
        result = self._values.get("logtail")
        return typing.cast(typing.Optional["AppSpecJobLogDestinationLogtail"], result)

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecJobLogDestinationPapertrail"]:
        """papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        result = self._values.get("papertrail")
        return typing.cast(
            typing.Optional["AppSpecJobLogDestinationPapertrail"], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecJobLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__06a982958a79b209a9a2b14b446abd7b94f4311dab9061a8eae6079962971d88
            )
            check_type(
                argname="argument api_key",
                value=api_key,
                expected_type=type_hints["api_key"],
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        """Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        """
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        """Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a2bcbc33ce91149126ce37109899d135870990381870a52baa091b7617a680ce
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__50ea4743e37f8fa9e29230715fd40244995c076f179bd608eeb26c180df400f7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiKey", value)

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0908dd73842b3f9d35e783dd5fb577f650cda1b6e420c0832d317957c24c842b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecJobLogDestinationDatadog],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc8b4f3a74ef351a465d4f8e28ec2a2dc578d496b8a6451938176f0a085d5ffe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47c1fb938104fdef2c48fb9d755c9f37a7795daf968e28d4afee1112a6e362fe
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobLogDestinationOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__18024ed31118c620e42e27d50910a51b743597fdda06360de5316855f0a1b8a1
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecJobLogDestinationOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__969e75a46bb3a57a548694ee78a8bc40b4747a06114b38c1daf542216be94d97
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5eee59976d76be0e90947f56c6ada5245c6a0a378b1ef7b24f74a0534a9e1b89
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08de18e9557720ac67a1957b51dcca6d7d958c94404961ca41c36acdaf63e0f4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2aae275ff3b73b4f123a3844ec7c53891661ca70cf1ca69cb0153af5990cf9a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecJobLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8ed52d800368c9b1b72a702a890ca03102941e4f44990219cb166a2f95df0167
            )
            check_type(
                argname="argument token", value=token, expected_type=type_hints["token"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        """Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__27fa063f72bced8b69445dd916d0bf18a70de6d1f275e8060127737d55e56b7b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bc5c4d0a2bbd67979d3cb4427619857b07d5b0a93a94d8c442c95364a89a695a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "token", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecJobLogDestinationLogtail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d0dc9f61f2a10596cf1e4cdc2fdb4406e43ba4b7404ae471e52f4b0c50efeb12
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb3e8cc42c0c191cfa47eac586907cdf179e44f30a8918878dfe35585ae033be
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecJobLogDestinationDatadog(api_key=api_key, endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        value = AppSpecJobLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecJobLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecJobLogDestinationDatadogOutputReference:
        return typing.cast(
            AppSpecJobLogDestinationDatadogOutputReference, jsii.get(self, "datadog")
        )

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecJobLogDestinationLogtailOutputReference:
        return typing.cast(
            AppSpecJobLogDestinationLogtailOutputReference, jsii.get(self, "logtail")
        )

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecJobLogDestinationPapertrailOutputReference":
        return typing.cast(
            "AppSpecJobLogDestinationPapertrailOutputReference",
            jsii.get(self, "papertrail"),
        )

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecJobLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecJobLogDestinationDatadog],
            jsii.get(self, "datadogInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecJobLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecJobLogDestinationLogtail],
            jsii.get(self, "logtailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(self) -> typing.Optional["AppSpecJobLogDestinationPapertrail"]:
        return typing.cast(
            typing.Optional["AppSpecJobLogDestinationPapertrail"],
            jsii.get(self, "papertrailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f3f01dcba16fd9e01fc8557d63220e2e5f6df5fbc3c7935059d7d52018404b15
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__58ec58c175dd35b46cd91de81d9fd930796b6414099b2516b1f6ba5a0d90d36b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecJobLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecJobLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bf3ce00e9a6fd024b7e9da6212944d2cb1783588baf59d69f7885ba0b88aa196
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        """Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9023757d58612395b59d8914930d98c3a4be3f65c0dffb10d83b100c5252e00f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__874a25afb39efdb044b8643480f62deab72f2712368c75188eb74994936d95b3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobLogDestinationPapertrail]:
        return typing.cast(
            typing.Optional[AppSpecJobLogDestinationPapertrail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__008512f89ae4d7591fcc83a1d2028a51120b57d1b140ff7272331538dd33d53c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecJobOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecJobOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1331bf25ef498110b53c51ca0a907080f3e86b6f48990e478e560b6501641925
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecJobAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c5c0ee9342d66b3b66b0bc33527360338b74a3a45b9c5ad91a715f5fc7ee6036
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecJobEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__098d41b1c984fb6b654cb577c790ad4f2ded593cca2d15905254f2c0a9057930
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        value = AppSpecJobGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecJobGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecJobGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putImage")
    def put_image(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        AppSpecJobImageDeployOnPush,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        registry: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        :param tag: The repository tag. Defaults to latest if not provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        value = AppSpecJobImage(
            registry_type=registry_type,
            repository=repository,
            deploy_on_push=deploy_on_push,
            registry=registry,
            tag=tag,
        )

        return typing.cast(None, jsii.invoke(self, "putImage", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecJobLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c3599731a4d446b8e13b1a8a979ad2d7a786c194a7d448939fc794cdbf87998d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetInstanceCount")
    def reset_instance_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceCount", []))

    @jsii.member(jsii_name="resetInstanceSizeSlug")
    def reset_instance_size_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceSizeSlug", []))

    @jsii.member(jsii_name="resetKind")
    def reset_kind(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKind", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRunCommand")
    def reset_run_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunCommand", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecJobAlertList:
        return typing.cast(AppSpecJobAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecJobEnvList:
        return typing.cast(AppSpecJobEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecJobGitOutputReference:
        return typing.cast(AppSpecJobGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecJobGithubOutputReference:
        return typing.cast(AppSpecJobGithubOutputReference, jsii.get(self, "github"))

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecJobGitlabOutputReference:
        return typing.cast(AppSpecJobGitlabOutputReference, jsii.get(self, "gitlab"))

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> AppSpecJobImageOutputReference:
        return typing.cast(AppSpecJobImageOutputReference, jsii.get(self, "image"))

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecJobLogDestinationList:
        return typing.cast(
            AppSpecJobLogDestinationList, jsii.get(self, "logDestination")
        )

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]
            ],
            jsii.get(self, "alertInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "buildCommandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput")
        )

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecJobGithub]:
        return typing.cast(
            typing.Optional[AppSpecJobGithub], jsii.get(self, "githubInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecJobGit]:
        return typing.cast(typing.Optional[AppSpecJobGit], jsii.get(self, "gitInput"))

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecJobGitlab]:
        return typing.cast(
            typing.Optional[AppSpecJobGitlab], jsii.get(self, "gitlabInput")
        )

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[AppSpecJobImage]:
        return typing.cast(
            typing.Optional[AppSpecJobImage], jsii.get(self, "imageInput")
        )

    @builtins.property
    @jsii.member(jsii_name="instanceCountInput")
    def instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "instanceCountInput")
        )

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlugInput")
    def instance_size_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "instanceSizeSlugInput")
        )

    @builtins.property
    @jsii.member(jsii_name="kindInput")
    def kind_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kindInput"))

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]
                ]
            ],
            jsii.get(self, "logDestinationInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="runCommandInput")
    def run_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runCommandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "sourceDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__541ed059f3d23ac20cbad6d30b9d6ced0933a98684a5bee1c98f0bf97ee303de
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "buildCommand", value)

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5aa691f5b6014019a68abb184196112ba4afd50a435f7e586e8aaf39c95c4c5e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dockerfilePath", value)

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a7f5063fb1777b0bfa1d4d02e5e00ec1ce7c1573746a2e6fa39e1d621893ce1a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "environmentSlug", value)

    @builtins.property
    @jsii.member(jsii_name="instanceCount")
    def instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "instanceCount"))

    @instance_count.setter
    def instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9070c2757c42675982bc6920d56e6200492418d82182a86dec3b838cdbde2fd1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "instanceCount", value)

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlug")
    def instance_size_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "instanceSizeSlug"))

    @instance_size_slug.setter
    def instance_size_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__23b545eb78bc8b31af96f1bedaf9c45cd090921b9911ff7ac3194166fd574d6a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "instanceSizeSlug", value)

    @builtins.property
    @jsii.member(jsii_name="kind")
    def kind(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "kind"))

    @kind.setter
    def kind(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf6e4dbdb234264609a4731089bd6999f328fc1820b8604ddf47342c762b9f7b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "kind", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c50115af27fc913e3a0c7a16dcd2f99e84cee90985a18f4765cd18e53ee9f948
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runCommand"))

    @run_command.setter
    def run_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2987b58b97fc12c9690b70a7b2c2b2aaee1b3ceae3d90ff8349d9d667c9d52a3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runCommand", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4d84bf95f3fd7f54c67bb186f5f8450b1f36a1c0bdd44bd69b7c1065904ad97f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "sourceDir", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1d2e7ee21465e443d732df4adf091345ff1d803ca466a98fde19dfb80218068f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f5affd94543b19131e413dffa6b886a32946e140826a97d872b030f8d73c6b50
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d66af5d5e75c58c85c1a0fe749a4395523186b6101ddb3af3dba5e6400940802
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putDatabase")
    def put_database(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecDatabase, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__05a32c5caa4b7b535e35477534b740415985ff3bb3064a0e6e2229d3107c17d7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putDatabase", [value]))

    @jsii.member(jsii_name="putDomain")
    def put_domain(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecDomain, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3954c3f416eec79a2fceec2a14b1f0a1c8e9d4f7732a86b4dd5af510b0a07bf1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putDomain", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47f9dfc421f844845e65fcdbd9667f7af7ba07e8e813259077718f7a15220c67
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putFunction")
    def put_function(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecFunction, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1346adfa98afad89811053b89caaf85ef9222dcd2c760a15b05d9c82ae4959b0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putFunction", [value]))

    @jsii.member(jsii_name="putJob")
    def put_job(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecJob, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__05ad0afef313a9c2ee8719f8469f02b516eb6925386e13abc785b2cb35cddb51
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putJob", [value]))

    @jsii.member(jsii_name="putService")
    def put_service(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union["AppSpecService", typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dbb8a7e660899d46dfa9902344020450aa098d8e5a7be2087117647d1fd37f02
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putService", [value]))

    @jsii.member(jsii_name="putStaticSite")
    def put_static_site(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union["AppSpecStaticSite", typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__247f609a9c819216f3b002754222c1529b86b1fb8b98fa472e3a8c3d5bd5c977
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putStaticSite", [value]))

    @jsii.member(jsii_name="putWorker")
    def put_worker(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union["AppSpecWorker", typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1b48c470052035c4fdd79353b4008c179fb57e0efdc5906b6699c3148c3d27ec
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putWorker", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetDatabase")
    def reset_database(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatabase", []))

    @jsii.member(jsii_name="resetDomain")
    def reset_domain(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDomain", []))

    @jsii.member(jsii_name="resetDomains")
    def reset_domains(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDomains", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetFunction")
    def reset_function(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFunction", []))

    @jsii.member(jsii_name="resetJob")
    def reset_job(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetJob", []))

    @jsii.member(jsii_name="resetRegion")
    def reset_region(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegion", []))

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @jsii.member(jsii_name="resetStaticSite")
    def reset_static_site(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStaticSite", []))

    @jsii.member(jsii_name="resetWorker")
    def reset_worker(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorker", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecAlertList:
        return typing.cast(AppSpecAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="database")
    def database(self) -> AppSpecDatabaseList:
        return typing.cast(AppSpecDatabaseList, jsii.get(self, "database"))

    @builtins.property
    @jsii.member(jsii_name="domain")
    def domain(self) -> AppSpecDomainList:
        return typing.cast(AppSpecDomainList, jsii.get(self, "domain"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecEnvList:
        return typing.cast(AppSpecEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="function")
    def function(self) -> AppSpecFunctionList:
        return typing.cast(AppSpecFunctionList, jsii.get(self, "function"))

    @builtins.property
    @jsii.member(jsii_name="job")
    def job(self) -> AppSpecJobList:
        return typing.cast(AppSpecJobList, jsii.get(self, "job"))

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> "AppSpecServiceList":
        return typing.cast("AppSpecServiceList", jsii.get(self, "service"))

    @builtins.property
    @jsii.member(jsii_name="staticSite")
    def static_site(self) -> "AppSpecStaticSiteList":
        return typing.cast("AppSpecStaticSiteList", jsii.get(self, "staticSite"))

    @builtins.property
    @jsii.member(jsii_name="worker")
    def worker(self) -> "AppSpecWorkerList":
        return typing.cast("AppSpecWorkerList", jsii.get(self, "worker"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]
            ],
            jsii.get(self, "alertInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="databaseInput")
    def database_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]
            ],
            jsii.get(self, "databaseInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="domainInput")
    def domain_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]
            ],
            jsii.get(self, "domainInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="domainsInput")
    def domains_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]], jsii.get(self, "domainsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="functionInput")
    def function_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]
            ],
            jsii.get(self, "functionInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="jobInput")
    def job_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]
            ],
            jsii.get(self, "jobInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="regionInput")
    def region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regionInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]
            ],
            jsii.get(self, "serviceInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="staticSiteInput")
    def static_site_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]
                ]
            ],
            jsii.get(self, "staticSiteInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="workerInput")
    def worker_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]
            ],
            jsii.get(self, "workerInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="domains")
    def domains(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "domains"))

    @domains.setter
    def domains(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bfc461e9eef5086593bcd4fc8435fb792f037ecf70acbb3cb6cbc7df7522718e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "domains", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b503cb8582b9df5f8cde463f625d61e9cf613d1a0eb0e5078e4eed7f8ee10b7d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @region.setter
    def region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6fa0473f8fa417f5df16827a3934a0ef29b5e454dab3ff610dc1b525533c5132
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "region", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpec]:
        return typing.cast(typing.Optional[AppSpec], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpec]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4325c7caf53a09c9a31814f14af59b4ef7a2eabd14130531d804d2ff082edcd6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecService",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "build_command": "buildCommand",
        "cors": "cors",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "health_check": "healthCheck",
        "http_port": "httpPort",
        "image": "image",
        "instance_count": "instanceCount",
        "instance_size_slug": "instanceSizeSlug",
        "internal_ports": "internalPorts",
        "log_destination": "logDestination",
        "routes": "routes",
        "run_command": "runCommand",
        "source_dir": "sourceDir",
    },
)
class AppSpecService:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecServiceAlert", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        build_command: typing.Optional[builtins.str] = None,
        cors: typing.Optional[
            typing.Union["AppSpecServiceCors", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecServiceEnv", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        git: typing.Optional[
            typing.Union["AppSpecServiceGit", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        github: typing.Optional[
            typing.Union["AppSpecServiceGithub", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        gitlab: typing.Optional[
            typing.Union["AppSpecServiceGitlab", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        health_check: typing.Optional[
            typing.Union[
                "AppSpecServiceHealthCheck", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        http_port: typing.Optional[jsii.Number] = None,
        image: typing.Optional[
            typing.Union["AppSpecServiceImage", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        instance_count: typing.Optional[jsii.Number] = None,
        instance_size_slug: typing.Optional[builtins.str] = None,
        internal_ports: typing.Optional[typing.Sequence[jsii.Number]] = None,
        log_destination: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecServiceLogDestination",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        routes: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecServiceRoutes", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        run_command: typing.Optional[builtins.str] = None,
        source_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        :param cors: cors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cors App#cors}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        :param health_check: health_check block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#health_check App#health_check}
        :param http_port: The internal port on which this service's run command will listen. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#http_port App#http_port}
        :param image: image block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#image App#image}
        :param instance_count: The amount of instances that this component should be scaled to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_count App#instance_count}
        :param instance_size_slug: The instance size to use for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_size_slug App#instance_size_slug}
        :param internal_ports: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#internal_ports App#internal_ports}.
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        :param routes: routes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#routes App#routes}
        :param run_command: An optional run command to override the component's default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#run_command App#run_command}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        if isinstance(cors, dict):
            cors = AppSpecServiceCors(**cors)
        if isinstance(git, dict):
            git = AppSpecServiceGit(**git)
        if isinstance(github, dict):
            github = AppSpecServiceGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecServiceGitlab(**gitlab)
        if isinstance(health_check, dict):
            health_check = AppSpecServiceHealthCheck(**health_check)
        if isinstance(image, dict):
            image = AppSpecServiceImage(**image)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4635df1fcb6062883acbe9d368eadc4b7523b5008c75f264f35ceea301e4e02a
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument alert", value=alert, expected_type=type_hints["alert"]
            )
            check_type(
                argname="argument build_command",
                value=build_command,
                expected_type=type_hints["build_command"],
            )
            check_type(
                argname="argument cors", value=cors, expected_type=type_hints["cors"]
            )
            check_type(
                argname="argument dockerfile_path",
                value=dockerfile_path,
                expected_type=type_hints["dockerfile_path"],
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument environment_slug",
                value=environment_slug,
                expected_type=type_hints["environment_slug"],
            )
            check_type(
                argname="argument git", value=git, expected_type=type_hints["git"]
            )
            check_type(
                argname="argument github",
                value=github,
                expected_type=type_hints["github"],
            )
            check_type(
                argname="argument gitlab",
                value=gitlab,
                expected_type=type_hints["gitlab"],
            )
            check_type(
                argname="argument health_check",
                value=health_check,
                expected_type=type_hints["health_check"],
            )
            check_type(
                argname="argument http_port",
                value=http_port,
                expected_type=type_hints["http_port"],
            )
            check_type(
                argname="argument image", value=image, expected_type=type_hints["image"]
            )
            check_type(
                argname="argument instance_count",
                value=instance_count,
                expected_type=type_hints["instance_count"],
            )
            check_type(
                argname="argument instance_size_slug",
                value=instance_size_slug,
                expected_type=type_hints["instance_size_slug"],
            )
            check_type(
                argname="argument internal_ports",
                value=internal_ports,
                expected_type=type_hints["internal_ports"],
            )
            check_type(
                argname="argument log_destination",
                value=log_destination,
                expected_type=type_hints["log_destination"],
            )
            check_type(
                argname="argument routes",
                value=routes,
                expected_type=type_hints["routes"],
            )
            check_type(
                argname="argument run_command",
                value=run_command,
                expected_type=type_hints["run_command"],
            )
            check_type(
                argname="argument source_dir",
                value=source_dir,
                expected_type=type_hints["source_dir"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if build_command is not None:
            self._values["build_command"] = build_command
        if cors is not None:
            self._values["cors"] = cors
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if health_check is not None:
            self._values["health_check"] = health_check
        if http_port is not None:
            self._values["http_port"] = http_port
        if image is not None:
            self._values["image"] = image
        if instance_count is not None:
            self._values["instance_count"] = instance_count
        if instance_size_slug is not None:
            self._values["instance_size_slug"] = instance_size_slug
        if internal_ports is not None:
            self._values["internal_ports"] = internal_ports
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if routes is not None:
            self._values["routes"] = routes
        if run_command is not None:
            self._values["run_command"] = run_command
        if source_dir is not None:
            self._values["source_dir"] = source_dir

    @builtins.property
    def name(self) -> builtins.str:
        """The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlert"]]
    ]:
        """alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        """
        result = self._values.get("alert")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlert"]
                ]
            ],
            result,
        )

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        """An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        """
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cors(self) -> typing.Optional["AppSpecServiceCors"]:
        """cors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cors App#cors}
        """
        result = self._values.get("cors")
        return typing.cast(typing.Optional["AppSpecServiceCors"], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        """The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        """
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceEnv"]]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceEnv"]
                ]
            ],
            result,
        )

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        """An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        """
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecServiceGit"]:
        """git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        """
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecServiceGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecServiceGithub"]:
        """github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        """
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecServiceGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecServiceGitlab"]:
        """gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        """
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecServiceGitlab"], result)

    @builtins.property
    def health_check(self) -> typing.Optional["AppSpecServiceHealthCheck"]:
        """health_check block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#health_check App#health_check}
        """
        result = self._values.get("health_check")
        return typing.cast(typing.Optional["AppSpecServiceHealthCheck"], result)

    @builtins.property
    def http_port(self) -> typing.Optional[jsii.Number]:
        """The internal port on which this service's run command will listen.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#http_port App#http_port}
        """
        result = self._values.get("http_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image(self) -> typing.Optional["AppSpecServiceImage"]:
        """image block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#image App#image}
        """
        result = self._values.get("image")
        return typing.cast(typing.Optional["AppSpecServiceImage"], result)

    @builtins.property
    def instance_count(self) -> typing.Optional[jsii.Number]:
        """The amount of instances that this component should be scaled to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_count App#instance_count}
        """
        result = self._values.get("instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_size_slug(self) -> typing.Optional[builtins.str]:
        """The instance size to use for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_size_slug App#instance_size_slug}
        """
        result = self._values.get("instance_size_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def internal_ports(self) -> typing.Optional[typing.List[jsii.Number]]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#internal_ports App#internal_ports}."""
        result = self._values.get("internal_ports")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceLogDestination"]
        ]
    ]:
        """log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        """
        result = self._values.get("log_destination")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["AppSpecServiceLogDestination"],
                ]
            ],
            result,
        )

    @builtins.property
    def routes(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]]
    ]:
        """routes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#routes App#routes}
        """
        result = self._values.get("routes")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]
                ]
            ],
            result,
        )

    @builtins.property
    def run_command(self) -> typing.Optional[builtins.str]:
        """An optional run command to override the component's default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#run_command App#run_command}
        """
        result = self._values.get("run_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        """An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecService(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "disabled": "disabled",
    },
)
class AppSpecServiceAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        disabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}.
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c4af67c565d3ecf565000872cc7f0b50b1be73dad5369ad84e71700456d9c4f7
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument rule", value=rule, expected_type=type_hints["rule"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
            check_type(
                argname="argument window",
                value=window,
                expected_type=type_hints["window"],
            )
            check_type(
                argname="argument disabled",
                value=disabled,
                expected_type=type_hints["disabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}."""
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}."""
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}."""
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}."""
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}."""
        result = self._values.get("disabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2c0a9a3db6ce0032440cf9b9929ef28ada7976660908748ee9a22742c002a162
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceAlertOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f4d0896aae5eaf05da0ceb538626560c70f39fbdd813e6116d83027fb2e3332
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecServiceAlertOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bfd81adc3d61316c364f097b80d4b8fa2c75298e67868c1afff0e955225f3a90
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0c083933f74698f799b333e892fb26708ef5b35595ae245b016a819d0e9490b5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2a3fdc1e0b9daac4c454a54a8bba56d9c04b7fcfab34059a876a09f978258419
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__de9692d39cdf54dcb149a6c8ce9343b53262de68621b63f0d6ddc85c8e054efe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__06dd7feec7593ee022f56089ee47be7cfdc619445a1aeb6e81483eaa30e50895
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "disabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "disabled"),
        )

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a1456212afbdffd15e9e1bf56444f600439593ecbec7a2841c3918cc0e560a91
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "disabled", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__89990b0e554ff313a04ec44d2a5a65f003347d62a8a9e9cd7ba7e18959bfc6a5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dd55c309e6d56ee8f317f251249d8a6faf20b71ebf1e5799de52882ea8632fde
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "rule", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__95c3bf4b606bd3e4f372466269e946ae591207461fe58545fdb8da578b866f4d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a6a875b2bf26ec0c9730deec09f855a81af48cc1b37065e2fd6a3bf01466ce20
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "window", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__446fffd3481f66760097a870c317922839dd2d4309bab6c952316b60fb0baca2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceCors",
    jsii_struct_bases=[],
    name_mapping={
        "allow_credentials": "allowCredentials",
        "allow_headers": "allowHeaders",
        "allow_methods": "allowMethods",
        "allow_origins": "allowOrigins",
        "expose_headers": "exposeHeaders",
        "max_age": "maxAge",
    },
)
class AppSpecServiceCors:
    def __init__(
        self,
        *,
        allow_credentials: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[
            typing.Union[
                "AppSpecServiceCorsAllowOrigins", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        if isinstance(allow_origins, dict):
            allow_origins = AppSpecServiceCorsAllowOrigins(**allow_origins)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1408b738d4e2cc1e1d295a677e6785c7744bab4f421305fc233c0e7ca28a154e
            )
            check_type(
                argname="argument allow_credentials",
                value=allow_credentials,
                expected_type=type_hints["allow_credentials"],
            )
            check_type(
                argname="argument allow_headers",
                value=allow_headers,
                expected_type=type_hints["allow_headers"],
            )
            check_type(
                argname="argument allow_methods",
                value=allow_methods,
                expected_type=type_hints["allow_methods"],
            )
            check_type(
                argname="argument allow_origins",
                value=allow_origins,
                expected_type=type_hints["allow_origins"],
            )
            check_type(
                argname="argument expose_headers",
                value=expose_headers,
                expected_type=type_hints["expose_headers"],
            )
            check_type(
                argname="argument max_age",
                value=max_age,
                expected_type=type_hints["max_age"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_credentials is not None:
            self._values["allow_credentials"] = allow_credentials
        if allow_headers is not None:
            self._values["allow_headers"] = allow_headers
        if allow_methods is not None:
            self._values["allow_methods"] = allow_methods
        if allow_origins is not None:
            self._values["allow_origins"] = allow_origins
        if expose_headers is not None:
            self._values["expose_headers"] = expose_headers
        if max_age is not None:
            self._values["max_age"] = max_age

    @builtins.property
    def allow_credentials(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``.

        This configures the Access-Control-Allow-Credentials header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        """
        result = self._values.get("allow_credentials")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def allow_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        """
        result = self._values.get("allow_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_methods(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        """
        result = self._values.get("allow_methods")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_origins(self) -> typing.Optional["AppSpecServiceCorsAllowOrigins"]:
        """allow_origins block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        """
        result = self._values.get("allow_origins")
        return typing.cast(typing.Optional["AppSpecServiceCorsAllowOrigins"], result)

    @builtins.property
    def expose_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        """
        result = self._values.get("expose_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def max_age(self) -> typing.Optional[builtins.str]:
        """An optional duration specifying how long browsers can cache the results of a preflight request.

        This configures the Access-Control-Max-Age header. Example: ``5h30m``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        result = self._values.get("max_age")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceCors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceCorsAllowOrigins",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact", "prefix": "prefix", "regex": "regex"},
)
class AppSpecServiceCorsAllowOrigins:
    def __init__(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3f3bae7413bd4ea8f84765c2e59e334a7d4cd60a5115dcbb197b8fd5bde6004b
            )
            check_type(
                argname="argument exact", value=exact, expected_type=type_hints["exact"]
            )
            check_type(
                argname="argument prefix",
                value=prefix,
                expected_type=type_hints["prefix"],
            )
            check_type(
                argname="argument regex", value=regex, expected_type=type_hints["regex"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact
        if prefix is not None:
            self._values["prefix"] = prefix
        if regex is not None:
            self._values["regex"] = regex

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        """Exact string match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        """
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        """Prefix-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        """
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def regex(self) -> typing.Optional[builtins.str]:
        """RE2 style regex-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        result = self._values.get("regex")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceCorsAllowOrigins(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceCorsAllowOriginsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceCorsAllowOriginsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4617a78d777aa907d3591a6ed4d74dc3fea69e5c1f655107af245bc494de65f0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetRegex")
    def reset_regex(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegex", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regexInput")
    def regex_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1c9f5762c69485891bdfcb63c03bf747923e6500e0e5d7a30fffcbad327b4b60
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "exact", value)

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b1b83467c06177fb55f2cd45515b2de27c6374b24a4349610bd4eea3f1e022d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "prefix", value)

    @builtins.property
    @jsii.member(jsii_name="regex")
    def regex(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "regex"))

    @regex.setter
    def regex(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d18600012050ad742463d4e382a900e6d0720ab4d25afdfad66d734788f77e98
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "regex", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceCorsAllowOrigins]:
        return typing.cast(
            typing.Optional[AppSpecServiceCorsAllowOrigins],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceCorsAllowOrigins],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5476a3aa364a0df5bd6ffb182e2acb09d763c6fd5d35c3b98d5d95b346954d30
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceCorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceCorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d63c291ca76b56fa688e9ce6a6efb5acedaa29d6a5308f6fbdbc8f33f1a205e4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAllowOrigins")
    def put_allow_origins(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        value = AppSpecServiceCorsAllowOrigins(exact=exact, prefix=prefix, regex=regex)

        return typing.cast(None, jsii.invoke(self, "putAllowOrigins", [value]))

    @jsii.member(jsii_name="resetAllowCredentials")
    def reset_allow_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowCredentials", []))

    @jsii.member(jsii_name="resetAllowHeaders")
    def reset_allow_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowHeaders", []))

    @jsii.member(jsii_name="resetAllowMethods")
    def reset_allow_methods(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowMethods", []))

    @jsii.member(jsii_name="resetAllowOrigins")
    def reset_allow_origins(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowOrigins", []))

    @jsii.member(jsii_name="resetExposeHeaders")
    def reset_expose_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExposeHeaders", []))

    @jsii.member(jsii_name="resetMaxAge")
    def reset_max_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxAge", []))

    @builtins.property
    @jsii.member(jsii_name="allowOrigins")
    def allow_origins(self) -> AppSpecServiceCorsAllowOriginsOutputReference:
        return typing.cast(
            AppSpecServiceCorsAllowOriginsOutputReference,
            jsii.get(self, "allowOrigins"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowCredentialsInput")
    def allow_credentials_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "allowCredentialsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowHeadersInput")
    def allow_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "allowHeadersInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowMethodsInput")
    def allow_methods_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "allowMethodsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowOriginsInput")
    def allow_origins_input(self) -> typing.Optional[AppSpecServiceCorsAllowOrigins]:
        return typing.cast(
            typing.Optional[AppSpecServiceCorsAllowOrigins],
            jsii.get(self, "allowOriginsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="exposeHeadersInput")
    def expose_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "exposeHeadersInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="maxAgeInput")
    def max_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentials")
    def allow_credentials(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "allowCredentials"),
        )

    @allow_credentials.setter
    def allow_credentials(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb5f415188a921c7c56668f9121814b6d2d4695f62eab52b5c017192e2174eca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowCredentials", value)

    @builtins.property
    @jsii.member(jsii_name="allowHeaders")
    def allow_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowHeaders"))

    @allow_headers.setter
    def allow_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8b33ad30f9d919d91911dfdbc99c607504245deb382b69444d28a2371d6549d5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowHeaders", value)

    @builtins.property
    @jsii.member(jsii_name="allowMethods")
    def allow_methods(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowMethods"))

    @allow_methods.setter
    def allow_methods(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__df5af2717761758c3baa6d8021a44fedf09b0a1b2cf14590d51a0ae2166c29f7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowMethods", value)

    @builtins.property
    @jsii.member(jsii_name="exposeHeaders")
    def expose_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "exposeHeaders"))

    @expose_headers.setter
    def expose_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ca71032d5ad329b58c7657839b4852a7fdd2123e84375158a0baf1bb6695972c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "exposeHeaders", value)

    @builtins.property
    @jsii.member(jsii_name="maxAge")
    def max_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxAge"))

    @max_age.setter
    def max_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cc3583646912bedc24a24a48d3abe31b85a7e1cc7215bc70df13801e2cf87af2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "maxAge", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceCors]:
        return typing.cast(
            typing.Optional[AppSpecServiceCors], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceCors]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__74468648a81272ee06d51c6526f2d24fc069fb5af74d209dfe87ea401bd8acc3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecServiceEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b06788a5fa960e4b3569062bf0ce4f5a53174a96f3e4f99884d4ebde9580af50
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        """The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        """
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4e00c8bae8ddb9c39125631701fc301b6974eed8cc4ff3bbfff649bd38c9e139
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__843ce5dfe136c2f952bb9801c18612c24f719da2beb8f4ab58bcf3e6e4e15651
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecServiceEnvOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__48445706962bf981049a460b6a62bf8b5f3e4cebcb69881dabd86adb7a20caab
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c07076cea7118a508902e57f213996295a9fa27e639751de384590bf8af8ee8a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e62db108c2b9294d049569ebb84c3ed83e3c190a32d098a7679b54d2a32d52a2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4206965f1df9bdecfd9eedc691525d5aaadca7de8a6d18fbe7b34d9ec8a5626b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2b4b3ac420ec8f7d36f21e1ccdeb662dd1f095584aa35ca25ea8888e0ccb28a1
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8a645319e5994679d35b5e6baad8e3ef18bdc265ecc599f1693f7a53b6ea5eb4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__08b3caa69acb8aad8d666ff2a9f2522d147273a9d1936ba8be79fa5105c3921e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scope", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6899f2bb7e2992ed9af0c1258437ad3afba90fd6454148b2e3f9dab95c9c66e4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__328a6deff925fd01eb4215c12f9e060640c6b5953523081a4e803be86ef1f8cd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6d23fa9d5559b0c0467106bfe338cf21aeee669630491cce4af175cc33cd0de6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecServiceGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a3d809b374a928f9a114d06fc6e3d82c080acc129540a81ddbc33bedb4293016
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument repo_clone_url",
                value=repo_clone_url,
                expected_type=type_hints["repo_clone_url"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        """The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7154be0f83ef0bd5cbcde4e9864580e3880aac895de56eee04a2c172ca0a878d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput")
        )

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__319290e2389d97b7a9a05d06a5956d995d47f97d97ff8dbe89bbc2a256d49c70
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__25e60c743dd3ba689e14f0345f2e9cbad60f77f3dd29f9e4f89ad9f97ed06388
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repoCloneUrl", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceGit]:
        return typing.cast(
            typing.Optional[AppSpecServiceGit], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__74cea2d7c0084506ae434b72a388979740b65212f8f5f7ae02566b50898a88c6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecServiceGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d76e5963b8e57cb236d19f379e1a8ec98e0fa7387c915c9395718f082be8a8ab
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d7ba9719c1e06532e24ae32fa1154cd1f95e17ffb546ece0739ee5ede093cccb
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__78fc7b8ab07c19dbcd1a1ac8eadc8836d7f943f89e066b4f3fdc026215c5539d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__661bec120e09429947989700512814c8cee5b72f6581b19a034718ad5cd7728f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bbc31bf97039acb289bd47b672bca23cdcc774f8463b2772a29dc607d75ef698
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceGithub]:
        return typing.cast(
            typing.Optional[AppSpecServiceGithub], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__828b1f80571d91ddaf95118315eceeecdfc2b9c317536decb5e98f015495eb5c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecServiceGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e0cc73984d23f9785affd45db84939817f88ce3f2260d5504ada613b8f7b631d
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__50fe55ea880bd01938f29459faeb44ce8dc899d2b7ccffc519f6db913c2ca702
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e51132715bcd9d550bcd393b0f928096ba82ecd83340cfce585a6e31af1d2d11
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__98f3830428ec164c7fae3df563e5107b9ef6c0d6491ac374db78eea6b5fe18c1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b26e9c2fcc2fe83c684bfe67b9798845a2d2afb4673cb041530d5294d9949b06
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceGitlab]:
        return typing.cast(
            typing.Optional[AppSpecServiceGitlab], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d81dc9744472f05e4a1631e92f00b9cffef08f479e605bccac3117ad23a62fb0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceHealthCheck",
    jsii_struct_bases=[],
    name_mapping={
        "failure_threshold": "failureThreshold",
        "http_path": "httpPath",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "timeout_seconds": "timeoutSeconds",
    },
)
class AppSpecServiceHealthCheck:
    def __init__(
        self,
        *,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_path: typing.Optional[builtins.str] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param failure_threshold: The number of failed health checks before considered unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#failure_threshold App#failure_threshold}
        :param http_path: The route path used for the HTTP health check ping. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#http_path App#http_path}
        :param initial_delay_seconds: The number of seconds to wait before beginning health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#initial_delay_seconds App#initial_delay_seconds}
        :param period_seconds: The number of seconds to wait between health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#period_seconds App#period_seconds}
        :param success_threshold: The number of successful health checks before considered healthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#success_threshold App#success_threshold}
        :param timeout_seconds: The number of seconds after which the check times out. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#timeout_seconds App#timeout_seconds}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b767c27332ca812d9f0df3d6802bb7e6272798b94978ebed1ea0cab9584cd340
            )
            check_type(
                argname="argument failure_threshold",
                value=failure_threshold,
                expected_type=type_hints["failure_threshold"],
            )
            check_type(
                argname="argument http_path",
                value=http_path,
                expected_type=type_hints["http_path"],
            )
            check_type(
                argname="argument initial_delay_seconds",
                value=initial_delay_seconds,
                expected_type=type_hints["initial_delay_seconds"],
            )
            check_type(
                argname="argument period_seconds",
                value=period_seconds,
                expected_type=type_hints["period_seconds"],
            )
            check_type(
                argname="argument success_threshold",
                value=success_threshold,
                expected_type=type_hints["success_threshold"],
            )
            check_type(
                argname="argument timeout_seconds",
                value=timeout_seconds,
                expected_type=type_hints["timeout_seconds"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_path is not None:
            self._values["http_path"] = http_path
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        """The number of failed health checks before considered unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#failure_threshold App#failure_threshold}
        """
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_path(self) -> typing.Optional[builtins.str]:
        """The route path used for the HTTP health check ping.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#http_path App#http_path}
        """
        result = self._values.get("http_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        """The number of seconds to wait before beginning health checks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#initial_delay_seconds App#initial_delay_seconds}
        """
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        """The number of seconds to wait between health checks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#period_seconds App#period_seconds}
        """
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        """The number of successful health checks before considered healthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#success_threshold App#success_threshold}
        """
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        """The number of seconds after which the check times out.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#timeout_seconds App#timeout_seconds}
        """
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceHealthCheck(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceHealthCheckOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceHealthCheckOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__13999b6b884a14eb9a04cf0c384bc9ab5de9b88a02f7234bce1df5f6fedb53d8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetHttpPath")
    def reset_http_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpPath", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="httpPathInput")
    def http_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "httpPathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput")
        )

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ce754d488b56fc3af12db2d2b871bcfc2ac2d94b571ec1d6f12da80af1849050
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "failureThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="httpPath")
    def http_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "httpPath"))

    @http_path.setter
    def http_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a88c6ae2473a7ab4724696a254bd74af3891971e45a6843b39cb99612c1714a4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "httpPath", value)

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d812834490b09ce733991fdb5071d041c052dfe387c0fb741f540c2a23c82150
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "initialDelaySeconds", value)

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__467b5cf0fa3955578b48d89519cbca2179abd6dcf3e02d176928cbc88366f193
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "periodSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8d64ad94f7da95e0ec9b06d37682e039a85d93a6cf6b5dfe2f5b6639b0deb67f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "successThreshold", value)

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__34ea94bfd0d1cf65b47a7dbb60cc34a403d2d322442ded9ad1b271dcfc92e56e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "timeoutSeconds", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceHealthCheck]:
        return typing.cast(
            typing.Optional[AppSpecServiceHealthCheck], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceHealthCheck]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4c22792cfcbdecfbb4e6a250b5c52d659e2499eba54e1a61fc53f551173fe479
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceImage",
    jsii_struct_bases=[],
    name_mapping={
        "registry_type": "registryType",
        "repository": "repository",
        "deploy_on_push": "deployOnPush",
        "registry": "registry",
        "tag": "tag",
    },
)
class AppSpecServiceImage:
    def __init__(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecServiceImageDeployOnPush",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        registry: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        :param tag: The repository tag. Defaults to latest if not provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__472885621ee51253e9bed11e8f3463b86855779804a76f767840f7d7ff85bc0b
            )
            check_type(
                argname="argument registry_type",
                value=registry_type,
                expected_type=type_hints["registry_type"],
            )
            check_type(
                argname="argument repository",
                value=repository,
                expected_type=type_hints["repository"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument registry",
                value=registry,
                expected_type=type_hints["registry"],
            )
            check_type(
                argname="argument tag", value=tag, expected_type=type_hints["tag"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "registry_type": registry_type,
            "repository": repository,
        }
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if registry is not None:
            self._values["registry"] = registry
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def registry_type(self) -> builtins.str:
        """The registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        """
        result = self._values.get("registry_type")
        assert result is not None, "Required property 'registry_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        """The repository name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        """
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceImageDeployOnPush"]
        ]
    ]:
        """deploy_on_push block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["AppSpecServiceImageDeployOnPush"],
                ]
            ],
            result,
        )

    @builtins.property
    def registry(self) -> typing.Optional[builtins.str]:
        """The registry name. Must be left empty for the DOCR registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        """
        result = self._values.get("registry")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag(self) -> typing.Optional[builtins.str]:
        """The repository tag. Defaults to latest if not provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        result = self._values.get("tag")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceImage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceImageDeployOnPush",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AppSpecServiceImageDeployOnPush:
    def __init__(
        self,
        *,
        enabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param enabled: Whether to automatically deploy images pushed to DOCR. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#enabled App#enabled}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__11169000a9e7bd85e601514117245942c84bb1e5011aa9275132228f8509dd6e
            )
            check_type(
                argname="argument enabled",
                value=enabled,
                expected_type=type_hints["enabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy images pushed to DOCR.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#enabled App#enabled}
        """
        result = self._values.get("enabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceImageDeployOnPush(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceImageDeployOnPushList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceImageDeployOnPushList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3df609f43219b4993b1d8716b7174e0e55de1046bfabc0c71a5b20d295aa2666
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecServiceImageDeployOnPushOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f0a819e73e903c6b039e8fc467291205e02c7b5947d9f54f549c402eb33e888
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecServiceImageDeployOnPushOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__935caf0eeb50efe4cc1698debd0431ee7f5e5d0193413444e45a0076e97989e4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__61124e965b6a0e790f46b6bdfce28b8a3b443e4ca0fd2ddd2907d6de0ac78823
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7b0203f54c8a0e99d32bcbaebeffc698e2c19f9447eec4292ac38295626e154
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecServiceImageDeployOnPush],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.List[AppSpecServiceImageDeployOnPush],
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b37d372e51004ee5e8a2923cfb47f94bc3d365a8dbdf452ebf45bbbb044c52ab
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceImageDeployOnPushOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceImageDeployOnPushOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c8d82963d601e4dc8528894730c39613bde1d6022c9f2bd45969377a2f8eaecf
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "enabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "enabled"),
        )

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f34f5fc4bf6688f559d14b96e1d6ce4c7427ff2f743b6020597355cd46ea18a0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "enabled", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__84b79cdfb41f63704a241764e64075b84cbcc7611c8e89a988325b9452d92270
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceImageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceImageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c0adebb8b466c2d56380609aafc871f059a5712424061b074e7c385e3e9c30f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDeployOnPush")
    def put_deploy_on_push(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecServiceImageDeployOnPush,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b8bfcaccb870a3d9aa6f45678962c55c1369e903eaefe0333978abc45b43638d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putDeployOnPush", [value]))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRegistry")
    def reset_registry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistry", []))

    @jsii.member(jsii_name="resetTag")
    def reset_tag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTag", []))

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(self) -> AppSpecServiceImageDeployOnPushList:
        return typing.cast(
            AppSpecServiceImageDeployOnPushList, jsii.get(self, "deployOnPush")
        )

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecServiceImageDeployOnPush],
                ]
            ],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="registryInput")
    def registry_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "registryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="registryTypeInput")
    def registry_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "registryTypeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="repositoryInput")
    def repository_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repositoryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tagInput")
    def tag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagInput"))

    @builtins.property
    @jsii.member(jsii_name="registry")
    def registry(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registry"))

    @registry.setter
    def registry(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__143b7ebb96267fb822911f0750d9d7085560a87f85f51b831dd679d2be94ae0f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "registry", value)

    @builtins.property
    @jsii.member(jsii_name="registryType")
    def registry_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryType"))

    @registry_type.setter
    def registry_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fa7db024040f1d0dbaa2f044888741b47ef48eefc362235d614e263c7cb852f6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "registryType", value)

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repository"))

    @repository.setter
    def repository(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d4e4885a96c1dc040fc98626d7b418cc8c74ad256b839d1051b59230b8822ed5
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repository", value)

    @builtins.property
    @jsii.member(jsii_name="tag")
    def tag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tag"))

    @tag.setter
    def tag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__240448594b7ee74aa38b1b1f2a0e9b3d485f972f9a2d603c6fd423d45270e219
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "tag", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceImage]:
        return typing.cast(
            typing.Optional[AppSpecServiceImage], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceImage]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3ccd32dbc312c471c240878273e02f4c4f9181eeebaed6f132c8b76a5fbd1a66
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a4d95fd0066013f42a53d224ccbf3b58f7a2e2fe1aaaa2129fc1186a92114967
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c069f90da1b057f8d41316a39004f0d2e1c72ab8a31e0fd50cdbc55c37d23e07
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecServiceOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4b627b5aea962ebb51cf51f44be2be8dc33d8dc8d931eda93f678cc6c98e0851
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ea57b7a977aa68f42f24953c22c82bbbeb7250b6e846b8b8baa04a6569b5af3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__06ea1e3904f2983a2caeb8d53646d20b9263a77817266ee338de7d93213ec083
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e62a6c502cfbcad3d4d29a0112a592f769778dfdc144d9630ee4efa1ee790c1e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "papertrail": "papertrail",
    },
)
class AppSpecServiceLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[
            typing.Union[
                "AppSpecServiceLogDestinationDatadog",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        logtail: typing.Optional[
            typing.Union[
                "AppSpecServiceLogDestinationLogtail",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        papertrail: typing.Optional[
            typing.Union[
                "AppSpecServiceLogDestinationPapertrail",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        if isinstance(datadog, dict):
            datadog = AppSpecServiceLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecServiceLogDestinationLogtail(**logtail)
        if isinstance(papertrail, dict):
            papertrail = AppSpecServiceLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f4d3ed23273387fc6fb22ab64971b445d64cd9bd67480e66f77c390255d482d0
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument datadog",
                value=datadog,
                expected_type=type_hints["datadog"],
            )
            check_type(
                argname="argument logtail",
                value=logtail,
                expected_type=type_hints["logtail"],
            )
            check_type(
                argname="argument papertrail",
                value=papertrail,
                expected_type=type_hints["papertrail"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecServiceLogDestinationDatadog"]:
        """datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        """
        result = self._values.get("datadog")
        return typing.cast(
            typing.Optional["AppSpecServiceLogDestinationDatadog"], result
        )

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecServiceLogDestinationLogtail"]:
        """logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        """
        result = self._values.get("logtail")
        return typing.cast(
            typing.Optional["AppSpecServiceLogDestinationLogtail"], result
        )

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecServiceLogDestinationPapertrail"]:
        """papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        result = self._values.get("papertrail")
        return typing.cast(
            typing.Optional["AppSpecServiceLogDestinationPapertrail"], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecServiceLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__46dc76ba433e1242c0cc53c37209411e16678267917cc16b122455d1c006413b
            )
            check_type(
                argname="argument api_key",
                value=api_key,
                expected_type=type_hints["api_key"],
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        """Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        """
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        """Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__05c14c8c0bdb6279bbbf088271bf38af6ec9502f1e7df528546a63a75cbb8c1b
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1d1478198ba28c3f1453578736924603c6cd2288602dfa96971387781af04a51
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiKey", value)

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a8efd04a8931531e27b99a24e884155ae1a1f209504b853226a3b6560a5639fd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecServiceLogDestinationDatadog],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d84d0b5d21026f39bd96826be01fb96c88d9c1f2266407f695e0d8bbf0fa0f59
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ab146a752fc05fd3af3c0099804e6faaecc2fd6980a689b85edcde520e47d6b3
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceLogDestinationOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5a56a1a98928ed4bc2366f309c7f4776d9165e2ce91c6abfc2de20b6d1ae5811
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecServiceLogDestinationOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5a6d9965e076bb506c2329a2faff8f04f73133fb6089b2af00ac048ed894f643
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1aa43e96f1a15030b3761cb6ad64542b60ab02e6bbb9175672274e8fe45a13cb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__da36677f9e533bf05193661bc92f86736d9a914ac7d7dbfc351274445fa4713b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecServiceLogDestination],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__caa35ce51122d7ad26c619c0aa2cdf46e0fe7f79a5cf5e6133a2fdb822c64b85
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecServiceLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f7b33b38ac6f4ebf95705a326e1d91c27a1c84fed972bb7a006aa4754727a8fc
            )
            check_type(
                argname="argument token", value=token, expected_type=type_hints["token"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        """Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1f662d37a5fa3ed173f3bb516241d2a5394db975f761a7edc30d54b9226839f9
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1295cb1ff56ce36e8db1bee9aef824c4dbb1d9c3b12d5378f6d32bd5b33eb726
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "token", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecServiceLogDestinationLogtail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ef67806c4019bb582c81b613ffc745c9c4f1c24cbb08a2191969a541d84ce2af
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__57d166b6ee9d48cac27b72470e53c32570ff60b8b235cc1283324768eb6a7aab
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecServiceLogDestinationDatadog(api_key=api_key, endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        value = AppSpecServiceLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecServiceLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecServiceLogDestinationDatadogOutputReference:
        return typing.cast(
            AppSpecServiceLogDestinationDatadogOutputReference,
            jsii.get(self, "datadog"),
        )

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecServiceLogDestinationLogtailOutputReference:
        return typing.cast(
            AppSpecServiceLogDestinationLogtailOutputReference,
            jsii.get(self, "logtail"),
        )

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecServiceLogDestinationPapertrailOutputReference":
        return typing.cast(
            "AppSpecServiceLogDestinationPapertrailOutputReference",
            jsii.get(self, "papertrail"),
        )

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecServiceLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecServiceLogDestinationDatadog],
            jsii.get(self, "datadogInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecServiceLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecServiceLogDestinationLogtail],
            jsii.get(self, "logtailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(
        self,
    ) -> typing.Optional["AppSpecServiceLogDestinationPapertrail"]:
        return typing.cast(
            typing.Optional["AppSpecServiceLogDestinationPapertrail"],
            jsii.get(self, "papertrailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__59ea8c6283dea0f4d7d25d9c0de15ace727b2ab4a3b0c07f9e4e0536d0c5f9be
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f8cf359fd49fc792dbe817eac453cd033ce98c35acff7df33367fa2a02eb03c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecServiceLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1cc51bcbbe7caac89a4feb641da1f8b030a81b186ee60906e6bd2a000e0215a2
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        """Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d87f10fa2ef2edebabc0fc2da279524e9d5230bc911eac89f44bd8d60cc19b14
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1c3c13e9ca1e230003e7f4dcd936a2d0cbe35539464cf8fee38cf48af0c67b24
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceLogDestinationPapertrail]:
        return typing.cast(
            typing.Optional[AppSpecServiceLogDestinationPapertrail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4a3c1979deb6116ddfad67e5eb664ba1156d5c8870fae81e0bf30031718f275e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__52b707c82c7980f64c728b1c699664fab42d326f982caf3fe103aa4ac5af25dd
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecServiceAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d2d8e1a7ed890d49fc1f46419c687f965d547982b6bfac8d566d82caa86c4bf6
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putCors")
    def put_cors(
        self,
        *,
        allow_credentials: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[
            typing.Union[
                AppSpecServiceCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        value = AppSpecServiceCors(
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )

        return typing.cast(None, jsii.invoke(self, "putCors", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecServiceEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8b46f21a24ab401ef90a0b55aea058108ae8bc9ca00ce43ff8cc8208c9d57239
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        value = AppSpecServiceGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecServiceGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecServiceGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putHealthCheck")
    def put_health_check(
        self,
        *,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_path: typing.Optional[builtins.str] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        """
        :param failure_threshold: The number of failed health checks before considered unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#failure_threshold App#failure_threshold}
        :param http_path: The route path used for the HTTP health check ping. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#http_path App#http_path}
        :param initial_delay_seconds: The number of seconds to wait before beginning health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#initial_delay_seconds App#initial_delay_seconds}
        :param period_seconds: The number of seconds to wait between health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#period_seconds App#period_seconds}
        :param success_threshold: The number of successful health checks before considered healthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#success_threshold App#success_threshold}
        :param timeout_seconds: The number of seconds after which the check times out. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#timeout_seconds App#timeout_seconds}
        """
        value = AppSpecServiceHealthCheck(
            failure_threshold=failure_threshold,
            http_path=http_path,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putHealthCheck", [value]))

    @jsii.member(jsii_name="putImage")
    def put_image(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        AppSpecServiceImageDeployOnPush,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        registry: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        :param tag: The repository tag. Defaults to latest if not provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        value = AppSpecServiceImage(
            registry_type=registry_type,
            repository=repository,
            deploy_on_push=deploy_on_push,
            registry=registry,
            tag=tag,
        )

        return typing.cast(None, jsii.invoke(self, "putImage", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecServiceLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac4fbf8417370e2e5c4f3eb10c56ab7ef868de7e129a9712b39a23a6b837232e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="putRoutes")
    def put_routes(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "AppSpecServiceRoutes", typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__70fd7af471c23ccffd4d0042507afdb4e96d5e997ee5675d9a21f3dcdfed2c1d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putRoutes", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetCors")
    def reset_cors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCors", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetHealthCheck")
    def reset_health_check(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHealthCheck", []))

    @jsii.member(jsii_name="resetHttpPort")
    def reset_http_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpPort", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetInstanceCount")
    def reset_instance_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceCount", []))

    @jsii.member(jsii_name="resetInstanceSizeSlug")
    def reset_instance_size_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceSizeSlug", []))

    @jsii.member(jsii_name="resetInternalPorts")
    def reset_internal_ports(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInternalPorts", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRoutes")
    def reset_routes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoutes", []))

    @jsii.member(jsii_name="resetRunCommand")
    def reset_run_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunCommand", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecServiceAlertList:
        return typing.cast(AppSpecServiceAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="cors")
    def cors(self) -> AppSpecServiceCorsOutputReference:
        return typing.cast(AppSpecServiceCorsOutputReference, jsii.get(self, "cors"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecServiceEnvList:
        return typing.cast(AppSpecServiceEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecServiceGitOutputReference:
        return typing.cast(AppSpecServiceGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecServiceGithubOutputReference:
        return typing.cast(
            AppSpecServiceGithubOutputReference, jsii.get(self, "github")
        )

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecServiceGitlabOutputReference:
        return typing.cast(
            AppSpecServiceGitlabOutputReference, jsii.get(self, "gitlab")
        )

    @builtins.property
    @jsii.member(jsii_name="healthCheck")
    def health_check(self) -> AppSpecServiceHealthCheckOutputReference:
        return typing.cast(
            AppSpecServiceHealthCheckOutputReference, jsii.get(self, "healthCheck")
        )

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> AppSpecServiceImageOutputReference:
        return typing.cast(AppSpecServiceImageOutputReference, jsii.get(self, "image"))

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecServiceLogDestinationList:
        return typing.cast(
            AppSpecServiceLogDestinationList, jsii.get(self, "logDestination")
        )

    @builtins.property
    @jsii.member(jsii_name="routes")
    def routes(self) -> "AppSpecServiceRoutesList":
        return typing.cast("AppSpecServiceRoutesList", jsii.get(self, "routes"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]
                ]
            ],
            jsii.get(self, "alertInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "buildCommandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="corsInput")
    def cors_input(self) -> typing.Optional[AppSpecServiceCors]:
        return typing.cast(
            typing.Optional[AppSpecServiceCors], jsii.get(self, "corsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]
                ]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput")
        )

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecServiceGithub]:
        return typing.cast(
            typing.Optional[AppSpecServiceGithub], jsii.get(self, "githubInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecServiceGit]:
        return typing.cast(
            typing.Optional[AppSpecServiceGit], jsii.get(self, "gitInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecServiceGitlab]:
        return typing.cast(
            typing.Optional[AppSpecServiceGitlab], jsii.get(self, "gitlabInput")
        )

    @builtins.property
    @jsii.member(jsii_name="healthCheckInput")
    def health_check_input(self) -> typing.Optional[AppSpecServiceHealthCheck]:
        return typing.cast(
            typing.Optional[AppSpecServiceHealthCheck],
            jsii.get(self, "healthCheckInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="httpPortInput")
    def http_port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "httpPortInput")
        )

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[AppSpecServiceImage]:
        return typing.cast(
            typing.Optional[AppSpecServiceImage], jsii.get(self, "imageInput")
        )

    @builtins.property
    @jsii.member(jsii_name="instanceCountInput")
    def instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "instanceCountInput")
        )

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlugInput")
    def instance_size_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "instanceSizeSlugInput")
        )

    @builtins.property
    @jsii.member(jsii_name="internalPortsInput")
    def internal_ports_input(self) -> typing.Optional[typing.List[jsii.Number]]:
        return typing.cast(
            typing.Optional[typing.List[jsii.Number]],
            jsii.get(self, "internalPortsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecServiceLogDestination],
                ]
            ],
            jsii.get(self, "logDestinationInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="routesInput")
    def routes_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]
                ]
            ],
            jsii.get(self, "routesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="runCommandInput")
    def run_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runCommandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "sourceDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__098afe1ead2c9c0e8b5c2b6fc6ed2579400565f1d784e0fb66f3e7770346fd31
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "buildCommand", value)

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3831da11b618796a73fc1bb6f5f1664de553228ea77a9ff9253f10e5f5074dc0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dockerfilePath", value)

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ddd367ba3e88656fc77df745652df22fa06c81dfc2e24bcae3607b29169bb4da
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "environmentSlug", value)

    @builtins.property
    @jsii.member(jsii_name="httpPort")
    def http_port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "httpPort"))

    @http_port.setter
    def http_port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__53f244fccd4c0230069f63a65571ae69c5817dcbd64d2dd75148368e16213b08
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "httpPort", value)

    @builtins.property
    @jsii.member(jsii_name="instanceCount")
    def instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "instanceCount"))

    @instance_count.setter
    def instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7db899c7207084e0bee6b6eb54b9715c0de2e0eae567faac316bac28c595edf2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "instanceCount", value)

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlug")
    def instance_size_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "instanceSizeSlug"))

    @instance_size_slug.setter
    def instance_size_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2571d9a128ddc4c615b001263f33b0873a767c089d8e7ece5cfefab7de12d8ac
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "instanceSizeSlug", value)

    @builtins.property
    @jsii.member(jsii_name="internalPorts")
    def internal_ports(self) -> typing.List[jsii.Number]:
        return typing.cast(typing.List[jsii.Number], jsii.get(self, "internalPorts"))

    @internal_ports.setter
    def internal_ports(self, value: typing.List[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b7d79d27cea155b6aa30d73d5977046334b874206455c1ca6b2d77319dac93b3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalPorts", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7a5a5b4e4340e45e604b633e0798511cb1a173326ec87e9ac492a7089fefa20c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runCommand"))

    @run_command.setter
    def run_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__459c7054b34bf59530ac2581b3dedffc9be6e02eec283d95699bd5549b6e7010
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runCommand", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__05df0f6fb1adbfe948b5f0c759bec4542c049e8042aeb4b33bbfd9582278755d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "sourceDir", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ec40edbd6a6514ab44a64659976a477c8d524c6cabd296ed76fad8feb152f10d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecServiceRoutes",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "preserve_path_prefix": "preservePathPrefix"},
)
class AppSpecServiceRoutes:
    def __init__(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param path: Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#path App#path}
        :param preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__036b51f32cb5e1b6647d371ad0e32cbc9227721a6e4ec0c29b0fa11eb124d5bb
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument preserve_path_prefix",
                value=preserve_path_prefix,
                expected_type=type_hints["preserve_path_prefix"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path
        if preserve_path_prefix is not None:
            self._values["preserve_path_prefix"] = preserve_path_prefix

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path specifies an route by HTTP path prefix.

        Paths must start with / and must be unique within the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#path App#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_path_prefix(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """An optional flag to preserve the path that is forwarded to the backend service.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        """
        result = self._values.get("preserve_path_prefix")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceRoutes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceRoutesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceRoutesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d1113f7b88b3c4ec8e09890a8b7b61c5addf99ea3ffad1bb28bee59998042ad5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceRoutesOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__05197c59392c7b837a4a4656a6d5098f2b03f89b1f25efbd40fae3e2c1c80fc9
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecServiceRoutesOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fb9cdc3043a7ddf24e4a129e2a952deb9394b4a24830f6c9b7f54db99b786edc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__330c33717eb4253ce6f17cbaf656948b63bf74537c7538802b9249f1b7ae786b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aea0161a0d88ee9380e043a3fc9f1524bed4a940ee3712be38ce8f1a0664a65a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3095e0f8dcde298db05403f010c0eb0d17d9f0f167811b22b64abbb4ee5aac07
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecServiceRoutesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecServiceRoutesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__223d5ffb23d8faf5e8c3d3f4d0d68575e22f660fa34a5cc4b9ac1d1538173fa5
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPreservePathPrefix")
    def reset_preserve_path_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreservePathPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefixInput")
    def preserve_path_prefix_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "preservePathPrefixInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__137d9dd0f9b6493c28844426ef3ef803af0f3aae7c50d9f75896078664e0a0fb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefix")
    def preserve_path_prefix(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "preservePathPrefix"),
        )

    @preserve_path_prefix.setter
    def preserve_path_prefix(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__867e825d94b4ee38522d9471d8b6cdc9455fe6b30e23862b877976527f330cc9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "preservePathPrefix", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__790f603b6fb1462c24f6b7e4d91cc1ba8087df8ac36eaf426ab31ae97a3405cc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSite",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "build_command": "buildCommand",
        "catchall_document": "catchallDocument",
        "cors": "cors",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "error_document": "errorDocument",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "index_document": "indexDocument",
        "output_dir": "outputDir",
        "routes": "routes",
        "source_dir": "sourceDir",
    },
)
class AppSpecStaticSite:
    def __init__(
        self,
        *,
        name: builtins.str,
        build_command: typing.Optional[builtins.str] = None,
        catchall_document: typing.Optional[builtins.str] = None,
        cors: typing.Optional[
            typing.Union["AppSpecStaticSiteCors", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecStaticSiteEnv", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        error_document: typing.Optional[builtins.str] = None,
        git: typing.Optional[
            typing.Union["AppSpecStaticSiteGit", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        github: typing.Optional[
            typing.Union[
                "AppSpecStaticSiteGithub", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        gitlab: typing.Optional[
            typing.Union[
                "AppSpecStaticSiteGitlab", typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        index_document: typing.Optional[builtins.str] = None,
        output_dir: typing.Optional[builtins.str] = None,
        routes: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecStaticSiteRoutes", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        source_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        :param catchall_document: The name of the document to use as the fallback for any requests to documents that are not found when serving this static site. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#catchall_document App#catchall_document}
        :param cors: cors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cors App#cors}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        :param error_document: The name of the error document to use when serving this static site. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#error_document App#error_document}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        :param index_document: The name of the index document to use when serving this static site. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#index_document App#index_document}
        :param output_dir: An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: ``_static``, ``dist``, ``public``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#output_dir App#output_dir}
        :param routes: routes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#routes App#routes}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        if isinstance(cors, dict):
            cors = AppSpecStaticSiteCors(**cors)
        if isinstance(git, dict):
            git = AppSpecStaticSiteGit(**git)
        if isinstance(github, dict):
            github = AppSpecStaticSiteGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecStaticSiteGitlab(**gitlab)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__15199275ae4e19113c4bacde81cee9f1d3c819a5ae8823b35e0dfb72302f6f2c
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument build_command",
                value=build_command,
                expected_type=type_hints["build_command"],
            )
            check_type(
                argname="argument catchall_document",
                value=catchall_document,
                expected_type=type_hints["catchall_document"],
            )
            check_type(
                argname="argument cors", value=cors, expected_type=type_hints["cors"]
            )
            check_type(
                argname="argument dockerfile_path",
                value=dockerfile_path,
                expected_type=type_hints["dockerfile_path"],
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument environment_slug",
                value=environment_slug,
                expected_type=type_hints["environment_slug"],
            )
            check_type(
                argname="argument error_document",
                value=error_document,
                expected_type=type_hints["error_document"],
            )
            check_type(
                argname="argument git", value=git, expected_type=type_hints["git"]
            )
            check_type(
                argname="argument github",
                value=github,
                expected_type=type_hints["github"],
            )
            check_type(
                argname="argument gitlab",
                value=gitlab,
                expected_type=type_hints["gitlab"],
            )
            check_type(
                argname="argument index_document",
                value=index_document,
                expected_type=type_hints["index_document"],
            )
            check_type(
                argname="argument output_dir",
                value=output_dir,
                expected_type=type_hints["output_dir"],
            )
            check_type(
                argname="argument routes",
                value=routes,
                expected_type=type_hints["routes"],
            )
            check_type(
                argname="argument source_dir",
                value=source_dir,
                expected_type=type_hints["source_dir"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if build_command is not None:
            self._values["build_command"] = build_command
        if catchall_document is not None:
            self._values["catchall_document"] = catchall_document
        if cors is not None:
            self._values["cors"] = cors
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if error_document is not None:
            self._values["error_document"] = error_document
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if index_document is not None:
            self._values["index_document"] = index_document
        if output_dir is not None:
            self._values["output_dir"] = output_dir
        if routes is not None:
            self._values["routes"] = routes
        if source_dir is not None:
            self._values["source_dir"] = source_dir

    @builtins.property
    def name(self) -> builtins.str:
        """The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        """An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        """
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def catchall_document(self) -> typing.Optional[builtins.str]:
        """The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#catchall_document App#catchall_document}
        """
        result = self._values.get("catchall_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cors(self) -> typing.Optional["AppSpecStaticSiteCors"]:
        """cors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#cors App#cors}
        """
        result = self._values.get("cors")
        return typing.cast(typing.Optional["AppSpecStaticSiteCors"], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        """The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        """
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteEnv"]]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteEnv"]
                ]
            ],
            result,
        )

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        """An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        """
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def error_document(self) -> typing.Optional[builtins.str]:
        """The name of the error document to use when serving this static site.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#error_document App#error_document}
        """
        result = self._values.get("error_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecStaticSiteGit"]:
        """git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        """
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecStaticSiteGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecStaticSiteGithub"]:
        """github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        """
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecStaticSiteGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecStaticSiteGitlab"]:
        """gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        """
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecStaticSiteGitlab"], result)

    @builtins.property
    def index_document(self) -> typing.Optional[builtins.str]:
        """The name of the index document to use when serving this static site.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#index_document App#index_document}
        """
        result = self._values.get("index_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_dir(self) -> typing.Optional[builtins.str]:
        """An optional path to where the built assets will be located, relative to the build context.

        If not set, App Platform will automatically scan for these directory names: ``_static``, ``dist``, ``public``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#output_dir App#output_dir}
        """
        result = self._values.get("output_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def routes(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]
        ]
    ]:
        """routes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#routes App#routes}
        """
        result = self._values.get("routes")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]
                ]
            ],
            result,
        )

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        """An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSite(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSiteCors",
    jsii_struct_bases=[],
    name_mapping={
        "allow_credentials": "allowCredentials",
        "allow_headers": "allowHeaders",
        "allow_methods": "allowMethods",
        "allow_origins": "allowOrigins",
        "expose_headers": "exposeHeaders",
        "max_age": "maxAge",
    },
)
class AppSpecStaticSiteCors:
    def __init__(
        self,
        *,
        allow_credentials: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[
            typing.Union[
                "AppSpecStaticSiteCorsAllowOrigins",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        if isinstance(allow_origins, dict):
            allow_origins = AppSpecStaticSiteCorsAllowOrigins(**allow_origins)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f2966edfb4d5dfe842443547fc005f89c287b2f419c8fba13684cc54e929a723
            )
            check_type(
                argname="argument allow_credentials",
                value=allow_credentials,
                expected_type=type_hints["allow_credentials"],
            )
            check_type(
                argname="argument allow_headers",
                value=allow_headers,
                expected_type=type_hints["allow_headers"],
            )
            check_type(
                argname="argument allow_methods",
                value=allow_methods,
                expected_type=type_hints["allow_methods"],
            )
            check_type(
                argname="argument allow_origins",
                value=allow_origins,
                expected_type=type_hints["allow_origins"],
            )
            check_type(
                argname="argument expose_headers",
                value=expose_headers,
                expected_type=type_hints["expose_headers"],
            )
            check_type(
                argname="argument max_age",
                value=max_age,
                expected_type=type_hints["max_age"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_credentials is not None:
            self._values["allow_credentials"] = allow_credentials
        if allow_headers is not None:
            self._values["allow_headers"] = allow_headers
        if allow_methods is not None:
            self._values["allow_methods"] = allow_methods
        if allow_origins is not None:
            self._values["allow_origins"] = allow_origins
        if expose_headers is not None:
            self._values["expose_headers"] = expose_headers
        if max_age is not None:
            self._values["max_age"] = max_age

    @builtins.property
    def allow_credentials(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``.

        This configures the Access-Control-Allow-Credentials header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        """
        result = self._values.get("allow_credentials")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def allow_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        """
        result = self._values.get("allow_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_methods(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        """
        result = self._values.get("allow_methods")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_origins(self) -> typing.Optional["AppSpecStaticSiteCorsAllowOrigins"]:
        """allow_origins block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        """
        result = self._values.get("allow_origins")
        return typing.cast(typing.Optional["AppSpecStaticSiteCorsAllowOrigins"], result)

    @builtins.property
    def expose_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        """The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        """
        result = self._values.get("expose_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def max_age(self) -> typing.Optional[builtins.str]:
        """An optional duration specifying how long browsers can cache the results of a preflight request.

        This configures the Access-Control-Max-Age header. Example: ``5h30m``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        result = self._values.get("max_age")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteCors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSiteCorsAllowOrigins",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact", "prefix": "prefix", "regex": "regex"},
)
class AppSpecStaticSiteCorsAllowOrigins:
    def __init__(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0d3d129ae1ab2c13538e75b6e7c622878dff3538b0901b3e6f9df3544cec39fa
            )
            check_type(
                argname="argument exact", value=exact, expected_type=type_hints["exact"]
            )
            check_type(
                argname="argument prefix",
                value=prefix,
                expected_type=type_hints["prefix"],
            )
            check_type(
                argname="argument regex", value=regex, expected_type=type_hints["regex"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact
        if prefix is not None:
            self._values["prefix"] = prefix
        if regex is not None:
            self._values["regex"] = regex

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        """Exact string match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        """
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        """Prefix-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        """
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def regex(self) -> typing.Optional[builtins.str]:
        """RE2 style regex-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        result = self._values.get("regex")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteCorsAllowOrigins(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteCorsAllowOriginsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteCorsAllowOriginsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__727c76e71711575b368b4d2e44bb5a0b865a72af543cf5fb9fb3d0c24620252f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetRegex")
    def reset_regex(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegex", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regexInput")
    def regex_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5c460b1c4c4809ff063ffbd49e8e98f80d975c58b4cc62c85ed0c2d3eadc3e12
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "exact", value)

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9f6350fe6efc7933ce4cc626377fafe247dcf08fed3c3c58c6f3e1ee5315de70
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "prefix", value)

    @builtins.property
    @jsii.member(jsii_name="regex")
    def regex(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "regex"))

    @regex.setter
    def regex(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6328b0eb6dc7cfab737206ecf76a09b334aa0d7751242154ba1862bc1c9cec72
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "regex", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteCorsAllowOrigins]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteCorsAllowOrigins],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecStaticSiteCorsAllowOrigins],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b047590504ff4d8189c0f0bb8beddc3b34b084588be783c51357d9ff1fb7db46
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecStaticSiteCorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteCorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ffbb39f404a0469f44892abb7ed2afb0b4fa23e498e939889d4c8dcef0dbee94
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAllowOrigins")
    def put_allow_origins(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#regex App#regex}
        """
        value = AppSpecStaticSiteCorsAllowOrigins(
            exact=exact, prefix=prefix, regex=regex
        )

        return typing.cast(None, jsii.invoke(self, "putAllowOrigins", [value]))

    @jsii.member(jsii_name="resetAllowCredentials")
    def reset_allow_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowCredentials", []))

    @jsii.member(jsii_name="resetAllowHeaders")
    def reset_allow_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowHeaders", []))

    @jsii.member(jsii_name="resetAllowMethods")
    def reset_allow_methods(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowMethods", []))

    @jsii.member(jsii_name="resetAllowOrigins")
    def reset_allow_origins(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowOrigins", []))

    @jsii.member(jsii_name="resetExposeHeaders")
    def reset_expose_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExposeHeaders", []))

    @jsii.member(jsii_name="resetMaxAge")
    def reset_max_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxAge", []))

    @builtins.property
    @jsii.member(jsii_name="allowOrigins")
    def allow_origins(self) -> AppSpecStaticSiteCorsAllowOriginsOutputReference:
        return typing.cast(
            AppSpecStaticSiteCorsAllowOriginsOutputReference,
            jsii.get(self, "allowOrigins"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowCredentialsInput")
    def allow_credentials_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "allowCredentialsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowHeadersInput")
    def allow_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "allowHeadersInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowMethodsInput")
    def allow_methods_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "allowMethodsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="allowOriginsInput")
    def allow_origins_input(self) -> typing.Optional[AppSpecStaticSiteCorsAllowOrigins]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteCorsAllowOrigins],
            jsii.get(self, "allowOriginsInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="exposeHeadersInput")
    def expose_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(
            typing.Optional[typing.List[builtins.str]],
            jsii.get(self, "exposeHeadersInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="maxAgeInput")
    def max_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentials")
    def allow_credentials(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "allowCredentials"),
        )

    @allow_credentials.setter
    def allow_credentials(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cfa5046ac5e594067e8a1af3c232abc45a1b67ee525636509b80d2c60ef7a89f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowCredentials", value)

    @builtins.property
    @jsii.member(jsii_name="allowHeaders")
    def allow_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowHeaders"))

    @allow_headers.setter
    def allow_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__696e347b0aa4d034bd8a4dd77152bcb7eea2b23b9780912f652d7c05b88a0707
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowHeaders", value)

    @builtins.property
    @jsii.member(jsii_name="allowMethods")
    def allow_methods(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowMethods"))

    @allow_methods.setter
    def allow_methods(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d7d794cf99076a5472838ffb4f35f783f9ad4eacf5ef72bd9e51b6a69ff44ee4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "allowMethods", value)

    @builtins.property
    @jsii.member(jsii_name="exposeHeaders")
    def expose_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "exposeHeaders"))

    @expose_headers.setter
    def expose_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7e7aefbb8f95d16cad631a30df4cf019f1307b0606b34d86ab6eede9a696a099
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "exposeHeaders", value)

    @builtins.property
    @jsii.member(jsii_name="maxAge")
    def max_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxAge"))

    @max_age.setter
    def max_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a8540deaafe84ab57ac7c46ac616384007ae0dbeaf007f08c1e5f8c42429026b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "maxAge", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteCors]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteCors], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteCors]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1488346b7e9b272ceb958dbe2942fb6ba31e841dd1ecb0d66a6bbbd15984325a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSiteEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecStaticSiteEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__784217f468dfa7bf6719640908c5488add706720cb7c17ef0f2781858b0c046a
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        """The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        """
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__59c3befb1632fbb70b61008f1696ad43dc77285ead0df07760494cfdf72a4f90
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecStaticSiteEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__536300f92a840650228a98b19f7012c936859923c4935a482295392475cb5a0c
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecStaticSiteEnvOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf1fa310bfa38b77ff141af5296fe431ffb2a041606448fd49ec15339ed6ab45
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f010705861e13c861cbf8a575351064c77824eafac1c16a54ae6f4c11a96de71
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a8d7dd303192c2b6d0f5213fc021c2a1ff0197087f56080ab9760434317334f2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__63a7493e8d422ffc6e49fe082c77d623bba25436416e68f25c478bb51bb40348
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecStaticSiteEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__da5c2914e3af0a9bd4417155de95daec89db506f312fbaeeeb92b4368674ab23
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cb93e963fb4dd3f85579415e0a6417f87f3a47ac6543b6672cf97c1450282d46
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b135cde22e1cd1de0199d7c2c19e2f656643df3a51c9842ee768e7839cf5a209
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scope", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6b80ac70966d12bf480d84651e55d441789447e40781da68bf55aa95eb136c7c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2403dfe6f56dc187c5469236c4aa9e57ff73e8a4b56501162136962e0d9f61f7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d8eb7e61d177fe68d5f83e48aefa12d734a51e5eaaed5b995a1a240267c586bc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSiteGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecStaticSiteGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b9002649e7632089484374e5d404acb76ad7d877f8d2e5c95c4a9ef2842bb3cf
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument repo_clone_url",
                value=repo_clone_url,
                expected_type=type_hints["repo_clone_url"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        """The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ef2a35411e4b877440b9f1f0923522361a1259cc46c4d89637e7d252d6125ab7
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput")
        )

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3be343d274bfdbb87104459d40fa7bc30cb65716aabe37c2548f7e1ed64d4106
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e7ca59c9c072b93280a43faa9d605bf05dda9e79247dd60b75a281b21b33d5c8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repoCloneUrl", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteGit]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteGit], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7d5173762b044d6e438fd30c77474b463d476c97835212e2bb88b7f206f0610b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSiteGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecStaticSiteGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c4501ee5477a4201414c6c43489ac369a1ef476228b14dfda38a7d8f253569dd
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3097259408cec4e91696f2bb4167fd0e7a7b896a36980c6116188cb75ce3576e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7b990d6a359fada13d26d3b513e2865435edd481fab1fce64d2b4122b5714274
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85d03eab2c94ca80f8364c79ea3264265954ab6a1aabafc1ff424bdb9f117b0b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__78c729f264913a2700300a158ef3bf8eef131a4667c3ed04dec98c333ef6b3ad
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteGithub]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteGithub], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d31534570c9443a05915548a38afceba7884953d1ef17e6a32c1e3d94705b140
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSiteGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecStaticSiteGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0355eb619dfbe825eaca7a401fba1661eb87b0187e71856722ec03a330b55365
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__42d8605eedf8c442c247dcd244f5fe323c8e22007ee9370ff7c06044937ebbd4
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__780bee121ef1c88264ac14858b45dd5574449de1256b4d8d3173eaea86c10609
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__eca1c6a4122af5b449535f50f4c676a34ccfc3c6a7c2ec8a2f60069ef996ad79
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__525b55574792ad62a6520b022af625692d36d712ad6a3dcd927b1422bca1af19
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteGitlab]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteGitlab], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c91508086b1e82f5536252e5ee0e5af1143af743b006e62c64b920d32a03675f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecStaticSiteList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9b52cf541dd6d3c18b7585238d5598ead15e26ba1791129bcbbf91b353c71802
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecStaticSiteOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__97c7688b9e06226914b9a7b8e2a76c5d5e278b74d48af52010f20d43d2202b72
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecStaticSiteOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fce83900a455b387d715f30b3fc1b957c1f06fd6cda70c247aa4ef758cc01bbc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__449a1e8739add9cbe4147d02248d6921441aa16cc65a15eed377b1d7740c1a11
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__25808dcf828fd68bc736eb6300b4d32bae8561ffe7e1d8497a23a810eba90fa1
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1fe6e50c1f7a0c06794d413479475e49237057adbdf6e9de818b2d690dd4f853
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecStaticSiteOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__17e1fe4b186339f18ce408ab7fcc9d05b5fcb097dbf8b11b8fe9ef208dfdbd04
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putCors")
    def put_cors(
        self,
        *,
        allow_credentials: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[
            typing.Union[
                AppSpecStaticSiteCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]
            ]
        ] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#max_age App#max_age}
        """
        value = AppSpecStaticSiteCors(
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )

        return typing.cast(None, jsii.invoke(self, "putCors", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecStaticSiteEnv, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__89c9286f6fbf8ad2336b8335f905dd4b49c49bf24e579fa50abe0a8ebcba8d3a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        value = AppSpecStaticSiteGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecStaticSiteGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecStaticSiteGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putRoutes")
    def put_routes(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    "AppSpecStaticSiteRoutes", typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6d26a7718b46aefd0a1c98e17bcaa972150e0215497810190aa2a10b04ecf635
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putRoutes", [value]))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetCatchallDocument")
    def reset_catchall_document(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCatchallDocument", []))

    @jsii.member(jsii_name="resetCors")
    def reset_cors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCors", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetErrorDocument")
    def reset_error_document(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetErrorDocument", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetIndexDocument")
    def reset_index_document(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIndexDocument", []))

    @jsii.member(jsii_name="resetOutputDir")
    def reset_output_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOutputDir", []))

    @jsii.member(jsii_name="resetRoutes")
    def reset_routes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoutes", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @builtins.property
    @jsii.member(jsii_name="cors")
    def cors(self) -> AppSpecStaticSiteCorsOutputReference:
        return typing.cast(AppSpecStaticSiteCorsOutputReference, jsii.get(self, "cors"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecStaticSiteEnvList:
        return typing.cast(AppSpecStaticSiteEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecStaticSiteGitOutputReference:
        return typing.cast(AppSpecStaticSiteGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecStaticSiteGithubOutputReference:
        return typing.cast(
            AppSpecStaticSiteGithubOutputReference, jsii.get(self, "github")
        )

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecStaticSiteGitlabOutputReference:
        return typing.cast(
            AppSpecStaticSiteGitlabOutputReference, jsii.get(self, "gitlab")
        )

    @builtins.property
    @jsii.member(jsii_name="routes")
    def routes(self) -> "AppSpecStaticSiteRoutesList":
        return typing.cast("AppSpecStaticSiteRoutesList", jsii.get(self, "routes"))

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "buildCommandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="catchallDocumentInput")
    def catchall_document_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "catchallDocumentInput")
        )

    @builtins.property
    @jsii.member(jsii_name="corsInput")
    def cors_input(self) -> typing.Optional[AppSpecStaticSiteCors]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteCors], jsii.get(self, "corsInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]
                ]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput")
        )

    @builtins.property
    @jsii.member(jsii_name="errorDocumentInput")
    def error_document_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "errorDocumentInput")
        )

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecStaticSiteGithub]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteGithub], jsii.get(self, "githubInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecStaticSiteGit]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteGit], jsii.get(self, "gitInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecStaticSiteGitlab]:
        return typing.cast(
            typing.Optional[AppSpecStaticSiteGitlab], jsii.get(self, "gitlabInput")
        )

    @builtins.property
    @jsii.member(jsii_name="indexDocumentInput")
    def index_document_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "indexDocumentInput")
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="outputDirInput")
    def output_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "outputDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="routesInput")
    def routes_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]
                ]
            ],
            jsii.get(self, "routesInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "sourceDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__83ee4436fb8080e61513535b9acd11b4d4dba9e68c08ed34e3a1b5ea08a935ec
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "buildCommand", value)

    @builtins.property
    @jsii.member(jsii_name="catchallDocument")
    def catchall_document(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "catchallDocument"))

    @catchall_document.setter
    def catchall_document(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1e8ff29492686432c78c20dddb63e98e38e9e63e66bd6f9d13cd0bdcec6eee09
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "catchallDocument", value)

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1b5c41dbb0e9bcf8c091d75fdf9bba58654995aad09414b8efe6b072a56869f9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dockerfilePath", value)

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__588fe45a217e0408ddc662a3fe505f899858b096e0d372756bad5cf11244700f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "environmentSlug", value)

    @builtins.property
    @jsii.member(jsii_name="errorDocument")
    def error_document(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "errorDocument"))

    @error_document.setter
    def error_document(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__01e2e5a049a0e4c2a013c1081e52ec41424edf811dcb9b8c4e9b4fc61e44551e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "errorDocument", value)

    @builtins.property
    @jsii.member(jsii_name="indexDocument")
    def index_document(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "indexDocument"))

    @index_document.setter
    def index_document(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0f10b8f5c2d63b24e0da628a49245e44d878ed06d668e029b16e7f6d664ee9f9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "indexDocument", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e2fa9ea2684d137d6ef349bc211a0e616a26ee8b69fe807749c4cecdbe796a53
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="outputDir")
    def output_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "outputDir"))

    @output_dir.setter
    def output_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b77685e847774eaea5cd47782d456fc582961ca50566122347fb406b99501911
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "outputDir", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ff723c3b6ab07d6a5bc2f36d4889afd3b17e34660c3141d0d65024a0a195e160
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "sourceDir", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__979640ecb296ba8269762b13b71a45283b615fa0984f0e6de58b29712bf17211
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecStaticSiteRoutes",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "preserve_path_prefix": "preservePathPrefix"},
)
class AppSpecStaticSiteRoutes:
    def __init__(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param path: Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#path App#path}
        :param preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__94eb801d912cbb47eb67786aceacb609dfd17e6d754dd9ea87a12355a9b4c18b
            )
            check_type(
                argname="argument path", value=path, expected_type=type_hints["path"]
            )
            check_type(
                argname="argument preserve_path_prefix",
                value=preserve_path_prefix,
                expected_type=type_hints["preserve_path_prefix"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path
        if preserve_path_prefix is not None:
            self._values["preserve_path_prefix"] = preserve_path_prefix

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        """Path specifies an route by HTTP path prefix.

        Paths must start with / and must be unique within the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#path App#path}
        """
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_path_prefix(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """An optional flag to preserve the path that is forwarded to the backend service.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        """
        result = self._values.get("preserve_path_prefix")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteRoutes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteRoutesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteRoutesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__716d569a99cd4fc48c88f923ccb38ab8527d8b41f3e1548facbb59b9cf204cab
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecStaticSiteRoutesOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c58d1c3b0c0e1d3c948e60b7f65b291401b7c4f3c31f66839089c35c08b8cd7a
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecStaticSiteRoutesOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__21e2cf12f857947694645f23521388b289bd7f61f3eb3f1a71a0ad031b8ea052
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c340af492ee12975816474e55e05a3a073659c84fb859c6e6eb5716d57d4c787
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1abfe0c8d1614d77fccac5c0f881f68608e6ad3ea2280cc5a32589ba59a28608
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__682921897b31141476b90f3c59ed58f54471d78aee4876e75cf7401f5037b9fc
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecStaticSiteRoutesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecStaticSiteRoutesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__297ad80a7a0e10b24f7d2ec1e3e2b7ffd67bc3d16ee6fe69418c2cd72db3d06f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPreservePathPrefix")
    def reset_preserve_path_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreservePathPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefixInput")
    def preserve_path_prefix_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "preservePathPrefixInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1d7387e0f82b11275d364e64be2aa16b9000454f6b70561ed19829719f5715dd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "path", value)

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefix")
    def preserve_path_prefix(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "preservePathPrefix"),
        )

    @preserve_path_prefix.setter
    def preserve_path_prefix(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__dcd78a15bec8ec5213a816153ab2014659172e0f6cc63477e0d4372a440bc18f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "preservePathPrefix", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c79c25e10b04e79be890695efb72d665035ef409c1ec7dedf582fcdc0ca8d67
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorker",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "build_command": "buildCommand",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "image": "image",
        "instance_count": "instanceCount",
        "instance_size_slug": "instanceSizeSlug",
        "log_destination": "logDestination",
        "run_command": "runCommand",
        "source_dir": "sourceDir",
    },
)
class AppSpecWorker:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecWorkerAlert", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        build_command: typing.Optional[builtins.str] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecWorkerEnv", typing.Dict[builtins.str, typing.Any]
                    ]
                ],
            ]
        ] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        git: typing.Optional[
            typing.Union["AppSpecWorkerGit", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        github: typing.Optional[
            typing.Union["AppSpecWorkerGithub", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        gitlab: typing.Optional[
            typing.Union["AppSpecWorkerGitlab", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        image: typing.Optional[
            typing.Union["AppSpecWorkerImage", typing.Dict[builtins.str, typing.Any]]
        ] = None,
        instance_count: typing.Optional[jsii.Number] = None,
        instance_size_slug: typing.Optional[builtins.str] = None,
        log_destination: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecWorkerLogDestination",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        run_command: typing.Optional[builtins.str] = None,
        source_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        :param image: image block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#image App#image}
        :param instance_count: The amount of instances that this component should be scaled to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_count App#instance_count}
        :param instance_size_slug: The instance size to use for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_size_slug App#instance_size_slug}
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        :param run_command: An optional run command to override the component's default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#run_command App#run_command}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        if isinstance(git, dict):
            git = AppSpecWorkerGit(**git)
        if isinstance(github, dict):
            github = AppSpecWorkerGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecWorkerGitlab(**gitlab)
        if isinstance(image, dict):
            image = AppSpecWorkerImage(**image)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f946ea53a22fdef3c96339d75e6bb12991e6166216e8fd57328742384f62c701
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument alert", value=alert, expected_type=type_hints["alert"]
            )
            check_type(
                argname="argument build_command",
                value=build_command,
                expected_type=type_hints["build_command"],
            )
            check_type(
                argname="argument dockerfile_path",
                value=dockerfile_path,
                expected_type=type_hints["dockerfile_path"],
            )
            check_type(
                argname="argument env", value=env, expected_type=type_hints["env"]
            )
            check_type(
                argname="argument environment_slug",
                value=environment_slug,
                expected_type=type_hints["environment_slug"],
            )
            check_type(
                argname="argument git", value=git, expected_type=type_hints["git"]
            )
            check_type(
                argname="argument github",
                value=github,
                expected_type=type_hints["github"],
            )
            check_type(
                argname="argument gitlab",
                value=gitlab,
                expected_type=type_hints["gitlab"],
            )
            check_type(
                argname="argument image", value=image, expected_type=type_hints["image"]
            )
            check_type(
                argname="argument instance_count",
                value=instance_count,
                expected_type=type_hints["instance_count"],
            )
            check_type(
                argname="argument instance_size_slug",
                value=instance_size_slug,
                expected_type=type_hints["instance_size_slug"],
            )
            check_type(
                argname="argument log_destination",
                value=log_destination,
                expected_type=type_hints["log_destination"],
            )
            check_type(
                argname="argument run_command",
                value=run_command,
                expected_type=type_hints["run_command"],
            )
            check_type(
                argname="argument source_dir",
                value=source_dir,
                expected_type=type_hints["source_dir"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if build_command is not None:
            self._values["build_command"] = build_command
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if image is not None:
            self._values["image"] = image
        if instance_count is not None:
            self._values["instance_count"] = instance_count
        if instance_size_slug is not None:
            self._values["instance_size_slug"] = instance_size_slug
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if run_command is not None:
            self._values["run_command"] = run_command
        if source_dir is not None:
            self._values["source_dir"] = source_dir

    @builtins.property
    def name(self) -> builtins.str:
        """The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlert"]]
    ]:
        """alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#alert App#alert}
        """
        result = self._values.get("alert")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlert"]
                ]
            ],
            result,
        )

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        """An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#build_command App#build_command}
        """
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        """The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#dockerfile_path App#dockerfile_path}
        """
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerEnv"]]
    ]:
        """env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#env App#env}
        """
        result = self._values.get("env")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerEnv"]
                ]
            ],
            result,
        )

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        """An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#environment_slug App#environment_slug}
        """
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecWorkerGit"]:
        """git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#git App#git}
        """
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecWorkerGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecWorkerGithub"]:
        """github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#github App#github}
        """
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecWorkerGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecWorkerGitlab"]:
        """gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#gitlab App#gitlab}
        """
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecWorkerGitlab"], result)

    @builtins.property
    def image(self) -> typing.Optional["AppSpecWorkerImage"]:
        """image block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#image App#image}
        """
        result = self._values.get("image")
        return typing.cast(typing.Optional["AppSpecWorkerImage"], result)

    @builtins.property
    def instance_count(self) -> typing.Optional[jsii.Number]:
        """The amount of instances that this component should be scaled to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_count App#instance_count}
        """
        result = self._values.get("instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_size_slug(self) -> typing.Optional[builtins.str]:
        """The instance size to use for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#instance_size_slug App#instance_size_slug}
        """
        result = self._values.get("instance_size_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerLogDestination"]
        ]
    ]:
        """log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#log_destination App#log_destination}
        """
        result = self._values.get("log_destination")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["AppSpecWorkerLogDestination"],
                ]
            ],
            result,
        )

    @builtins.property
    def run_command(self) -> typing.Optional[builtins.str]:
        """An optional run command to override the component's default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#run_command App#run_command}
        """
        result = self._values.get("run_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        """An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#source_dir App#source_dir}
        """
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorker(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "disabled": "disabled",
    },
)
class AppSpecWorkerAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        disabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}.
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__83c3a523ab2ac6e9cc50b24d907f7079136ca006914f1bb2d74f20b6c8bfafbb
            )
            check_type(
                argname="argument operator",
                value=operator,
                expected_type=type_hints["operator"],
            )
            check_type(
                argname="argument rule", value=rule, expected_type=type_hints["rule"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
            check_type(
                argname="argument window",
                value=window,
                expected_type=type_hints["window"],
            )
            check_type(
                argname="argument disabled",
                value=disabled,
                expected_type=type_hints["disabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#operator App#operator}."""
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#rule App#rule}."""
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}."""
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#window App#window}."""
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#disabled App#disabled}."""
        result = self._values.get("disabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9d57b2bef7fb51f1cf52f808a4e98919e36ada79df513e70f2a2502e26243cb8
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerAlertOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__59757b1048bd342ba29290e9e19cccc30dfc89e3fb1889ba0bf95d51584c02d4
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecWorkerAlertOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cf1248017b0c7d90dd3442bf3e58c6cf00305d30a52bcb3ffbbfd86b804a2780
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aae635d9ff76ba2a376bdb6f2d43e10b858540d0aa31eb746cc3d7e932af4daa
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4d95b76f043a20e526c5224e675b5e11dada4679599b3dc2ada8b8ca9917d082
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__038a9a156f2640521abc8cd1882b19bec8fa8814d9494550b7f9e82720b41566
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c096fe7bf5ab1a67c36d0a5c28c48f6cd6a61f0747c27c8acdee7fd56aaa7cf2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "disabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "operatorInput")
        )

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "disabled"),
        )

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__88a4e5650232c02cf7625d3e65b4665159696e2ad518a3eb870ca26545eeb3e0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "disabled", value)

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__858707f3b31571fab8bc98b1f96e27ef52a74fe3745e0699a4440c45a0360eb4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "operator", value)

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3c6ec22c10a023a9befc349084f0e3b8fcc83b364db895350c91503e2cc64bbf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "rule", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a033494a51aa421174f8b7dc2a6391f74756d823ce51f47bfffcca6a1ffeb488
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7abe109f4cb2067b8c9a5e016ddb09e09578b8e30abdbde188dab72f4746d82f
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "window", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__419d9312fea3b26941f4a6d8aa5f3d95fcaf377c7f8601fa1fb61eb447702fcd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecWorkerEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a645c0b33bca8c7a59bbadb6bd839fbc625126dfe7e536bbeb3abfdf1736547f
            )
            check_type(
                argname="argument key", value=key, expected_type=type_hints["key"]
            )
            check_type(
                argname="argument scope", value=scope, expected_type=type_hints["scope"]
            )
            check_type(
                argname="argument type", value=type, expected_type=type_hints["type"]
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        """The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#key App#key}
        """
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        """The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#scope App#scope}
        """
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        """The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#type App#type}
        """
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        """The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#value App#value}
        """
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__4141c142524b8c4d5e9b2af7a0b1f4633fc7e67ae6e9b7d90af80484aa503342
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerEnvOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8c171fc3c2bee3883e8b29cac1b48e59e9ec31e75ad72a86c0467e5ed20539de
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecWorkerEnvOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e923914c24bbfca7a510c7b6a90bde473f966f05618ca06f4a919e88e1475ba0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6d0f5513b5170c340fa9f75717580e1742b4ce59f0aef5e9d6e10769dd1d3dfd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3514d24a4cf414f347c1dee4d3b7a536aa197474465ef83a8f51ef01002da3c8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e88c5a01a81738a108e5391731ce5aab60dbd75a8fed024f67b3462a7e55c85e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8dfec70aeba9eec50f45f2e66ff6ec980613cc1e426fd130c371708bf7971ee2
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2be4e821bb503862cc3d37b9e33c40420d76be47453f3edf8d953e277f1ae311
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "key", value)

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__9e6e5252522758f599b587edc08424f69993507965738095b9aec5d7ddfde08e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "scope", value)

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__70ca2b0556ace5233e61d4231974eff53cf93066158d667761564d175947dfff
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "type", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e81073cbb140a782514f5c5126cfbe67bc30a264cc271603f065174c39f0e69e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "value", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2bb73294e08973a2d5e33cde5a34a06fa4714ed666b3e8305d5830a5fa816f4b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecWorkerGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__65ed3bd4be20a855935f6f40017b704e2d37416b9ce9d16c7783fe19c39dd57f
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument repo_clone_url",
                value=repo_clone_url,
                expected_type=type_hints["repo_clone_url"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        """The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__36ac71b677c56acd939a3de03257c14faa31ff9f51bc2649ade2c8d255fe1480
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput")
        )

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__195ed50e042b9df5cf52151c5ae144ffb2ccbc83e7559374fab0a52b90029766
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e7eed93051c8049e65f3d285f4470d025be36c2bf0c18bd4a92e72c2e25feff3
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repoCloneUrl", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerGit]:
        return typing.cast(
            typing.Optional[AppSpecWorkerGit], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__3a3734c1b059e661b6d4e3927141b855ce62fb55811a0d541de7e73681088580
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecWorkerGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e510330fb3616d9be716a83a171c95c65ddbebe16e9f39db1469cff8cce1c05e
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f73a598726d3e60688971b4bbbf345c3f3fe2c2ce84997dd0a776030b43eaf95
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fe8e3c28d2e4272210fcc3c39e68c25e0a6b6165ee8d141ad5ab38f63def0777
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c476e6b66788258795af3f27e6b0deed17f011f8cee5e81cb2af2cd33ee2a52b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f3c04d35d84f3fe30852f8141e41783774b5b7cb4afc096d538d15952870a033
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerGithub]:
        return typing.cast(
            typing.Optional[AppSpecWorkerGithub], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5ce0dd4977afc7c9e432947db58fb82d2ae3530034644e4363eb885756edba7e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecWorkerGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__092c69f3ef1099eda4c776fa1708e3338d5e43c4cb2f0aa26cb43b9b3014dde4
            )
            check_type(
                argname="argument branch",
                value=branch,
                expected_type=type_hints["branch"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument repo", value=repo, expected_type=type_hints["repo"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        """The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        """
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        """The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fcbe0e441f9e34cb46812c4df80801e93978dbe6a7db708f513957ec6836125e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2fa12a3af0dbbda9039cdd8706a0a3c88d14794d40cb2fd2b0833ad9d12991e8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "branch", value)

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "deployOnPush"),
        )

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1920d0c4c28cb2bcbfd9f4135c1ff72ba0779034b39f0e14a8d2ae37dd4c5c02
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "deployOnPush", value)

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cde272430d9a695db598cf0dd586f33c719d07443d6ce6e8810289c151869277
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repo", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerGitlab]:
        return typing.cast(
            typing.Optional[AppSpecWorkerGitlab], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c7e6230257c9f4cd135c493c467293d9d768797640cbd9d2377e18371031515b
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerImage",
    jsii_struct_bases=[],
    name_mapping={
        "registry_type": "registryType",
        "repository": "repository",
        "deploy_on_push": "deployOnPush",
        "registry": "registry",
        "tag": "tag",
    },
)
class AppSpecWorkerImage:
    def __init__(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        "AppSpecWorkerImageDeployOnPush",
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        registry: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        :param tag: The repository tag. Defaults to latest if not provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__07ceda44d34c848103d56190074ef0646e3b5ae00d3a952277de75fe5fd2f738
            )
            check_type(
                argname="argument registry_type",
                value=registry_type,
                expected_type=type_hints["registry_type"],
            )
            check_type(
                argname="argument repository",
                value=repository,
                expected_type=type_hints["repository"],
            )
            check_type(
                argname="argument deploy_on_push",
                value=deploy_on_push,
                expected_type=type_hints["deploy_on_push"],
            )
            check_type(
                argname="argument registry",
                value=registry,
                expected_type=type_hints["registry"],
            )
            check_type(
                argname="argument tag", value=tag, expected_type=type_hints["tag"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "registry_type": registry_type,
            "repository": repository,
        }
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if registry is not None:
            self._values["registry"] = registry
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def registry_type(self) -> builtins.str:
        """The registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        """
        result = self._values.get("registry_type")
        assert result is not None, "Required property 'registry_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        """The repository name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        """
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerImageDeployOnPush"]
        ]
    ]:
        """deploy_on_push block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        """
        result = self._values.get("deploy_on_push")
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List["AppSpecWorkerImageDeployOnPush"],
                ]
            ],
            result,
        )

    @builtins.property
    def registry(self) -> typing.Optional[builtins.str]:
        """The registry name. Must be left empty for the DOCR registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        """
        result = self._values.get("registry")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag(self) -> typing.Optional[builtins.str]:
        """The repository tag. Defaults to latest if not provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        result = self._values.get("tag")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerImage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerImageDeployOnPush",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AppSpecWorkerImageDeployOnPush:
    def __init__(
        self,
        *,
        enabled: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
    ) -> None:
        """
        :param enabled: Whether to automatically deploy images pushed to DOCR. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#enabled App#enabled}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bb1e78017d6a19cca2b6ca4f4305afdfdb24297bccf8a359ec9ad69e74518a9d
            )
            check_type(
                argname="argument enabled",
                value=enabled,
                expected_type=type_hints["enabled"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        """Whether to automatically deploy images pushed to DOCR.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#enabled App#enabled}
        """
        result = self._values.get("enabled")
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            result,
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerImageDeployOnPush(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerImageDeployOnPushList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerImageDeployOnPushList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__fc117821e6e970f17f2c4081ea8eb8ae92d98528e70efa3bff8df3d83f7f57ba
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecWorkerImageDeployOnPushOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f978bd7fc8dcfa31304faa7821661b27ca888aa249383329ba1661ab695bb3a5
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecWorkerImageDeployOnPushOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c1a5956b82c75075c74522cc2dbc8a6fa9d2134980941bc17eeadb7901ee3469
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__843d4b4ca76cee0674b546596c94517ea22b694f01bf96329c3017717752f079
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__434e1b9b5c1a84e76eb1ec11ffac155cc008b87aa8ffe1f5999b9a95f4fed062
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecWorkerImageDeployOnPush],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__486c8fbf72b8a42dd1f0ae68023d0813907ea17f1d189945ae20fe9eb2904794
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerImageDeployOnPushOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerImageDeployOnPushOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__705c04a632810e987c1064cdb654eabd300437f7f6eb716ecc6d4626df09fd32
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(
            typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
            jsii.get(self, "enabledInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
            jsii.get(self, "enabled"),
        )

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__28d1bc095393a8976a186ede97716a5675f9691f8970bf62e1731b82d77b0964
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "enabled", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ce2ded9e15de3e36519b44651f02dac2a99f7a60d8ea5ee026ac1433691e4c7d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerImageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerImageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__cad1e5b34d0662b052f4c77eb025c2cbe775e0b4aadc5061c4017c88e1aea28d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDeployOnPush")
    def put_deploy_on_push(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecWorkerImageDeployOnPush,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1aaee4269b8304d0738d92921b17f1e6174ca813394c04d84f902c08f7153093
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putDeployOnPush", [value]))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRegistry")
    def reset_registry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistry", []))

    @jsii.member(jsii_name="resetTag")
    def reset_tag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTag", []))

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(self) -> AppSpecWorkerImageDeployOnPushList:
        return typing.cast(
            AppSpecWorkerImageDeployOnPushList, jsii.get(self, "deployOnPush")
        )

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecWorkerImageDeployOnPush],
                ]
            ],
            jsii.get(self, "deployOnPushInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="registryInput")
    def registry_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "registryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="registryTypeInput")
    def registry_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "registryTypeInput")
        )

    @builtins.property
    @jsii.member(jsii_name="repositoryInput")
    def repository_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "repositoryInput")
        )

    @builtins.property
    @jsii.member(jsii_name="tagInput")
    def tag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagInput"))

    @builtins.property
    @jsii.member(jsii_name="registry")
    def registry(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registry"))

    @registry.setter
    def registry(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__47d35f4e313b08615add8ecbb27318197bb9e4e38aefa90c3b0ed0e6b76f0725
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "registry", value)

    @builtins.property
    @jsii.member(jsii_name="registryType")
    def registry_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryType"))

    @registry_type.setter
    def registry_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b2966e3590d5467c29bc8ba516637f682c88546cdc19436092abeaea5ca4f76c
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "registryType", value)

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repository"))

    @repository.setter
    def repository(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5343bf30f3a569b0164ff6aa326a503acd9e7da57be484c64bed4eb0561425d4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "repository", value)

    @builtins.property
    @jsii.member(jsii_name="tag")
    def tag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tag"))

    @tag.setter
    def tag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5bc066ba25d3caddd7317de28ac51b7f9a7e29a3df6b1ccea9811dbc0f6bc14e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "tag", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerImage]:
        return typing.cast(
            typing.Optional[AppSpecWorkerImage], jsii.get(self, "internalValue")
        )

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerImage]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__efb1943a99c5a5ab77c05e9310657c7bd31186b0d76bc7e53cf419e36f86f68d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__59d0b009d1f678c54e7c84ae810a928a0fd32cebc0c87c0e1feda040209e6d30
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bd769594c050f4e63b8e5632596a8df4f162961d40d4b094ebb78f458ae3816c
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecWorkerOutputReference", jsii.invoke(self, "get", [index])
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__018552f5fa32fedc6880340fa4a3e220d1aee519bac7d1c66f26caec37320407
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7813423982af30693e6de05c363e3022f728526fc08f8c8b63e493bf6e783a80
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bba947906d69eb0ff04d2fa967c455f9fa5bee3e00f5d9b23c10da66e2f04eec
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__09e1fa846460dab7bd2593150ecd78c4d41923a5d7a81c2c0935358e4b90f88d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "papertrail": "papertrail",
    },
)
class AppSpecWorkerLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[
            typing.Union[
                "AppSpecWorkerLogDestinationDatadog",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        logtail: typing.Optional[
            typing.Union[
                "AppSpecWorkerLogDestinationLogtail",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
        papertrail: typing.Optional[
            typing.Union[
                "AppSpecWorkerLogDestinationPapertrail",
                typing.Dict[builtins.str, typing.Any],
            ]
        ] = None,
    ) -> None:
        """
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        if isinstance(datadog, dict):
            datadog = AppSpecWorkerLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecWorkerLogDestinationLogtail(**logtail)
        if isinstance(papertrail, dict):
            papertrail = AppSpecWorkerLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f9b347931b7add79158d5c2520844297f6e37e64087548b38305e67bd15577e5
            )
            check_type(
                argname="argument name", value=name, expected_type=type_hints["name"]
            )
            check_type(
                argname="argument datadog",
                value=datadog,
                expected_type=type_hints["datadog"],
            )
            check_type(
                argname="argument logtail",
                value=logtail,
                expected_type=type_hints["logtail"],
            )
            check_type(
                argname="argument papertrail",
                value=papertrail,
                expected_type=type_hints["papertrail"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        """Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#name App#name}
        """
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecWorkerLogDestinationDatadog"]:
        """datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#datadog App#datadog}
        """
        result = self._values.get("datadog")
        return typing.cast(
            typing.Optional["AppSpecWorkerLogDestinationDatadog"], result
        )

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecWorkerLogDestinationLogtail"]:
        """logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#logtail App#logtail}
        """
        result = self._values.get("logtail")
        return typing.cast(
            typing.Optional["AppSpecWorkerLogDestinationLogtail"], result
        )

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecWorkerLogDestinationPapertrail"]:
        """papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#papertrail App#papertrail}
        """
        result = self._values.get("papertrail")
        return typing.cast(
            typing.Optional["AppSpecWorkerLogDestinationPapertrail"], result
        )

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecWorkerLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__735f21f93267e274392256fe922af284aeb6fd9a329e67cd886738061aac9d4f
            )
            check_type(
                argname="argument api_key",
                value=api_key,
                expected_type=type_hints["api_key"],
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        """Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        """
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        """Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__67c04f2eee0437e2856acc3faf15b93f43f87026feadcf2514797a6940c5dd9d
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d957886868ed6515c2246ab07754c2c200decdee9a1d97d7d361652c3fe278fe
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "apiKey", value)

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__6c600f38f3b603debd4382cec01b6324d714e71296b8609027b4e9421b7c9851
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecWorkerLogDestinationDatadog],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7f0e149171a27a1446274390f2db1ca5fdb559967daf135629f36f145db46309
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__8c885600ecbdeb7c8d8237a95248d0248ca025e286495e3c972501232a6821a0
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument wraps_set",
                value=wraps_set,
                expected_type=type_hints["wraps_set"],
            )
        jsii.create(
            self.__class__, self, [terraform_resource, terraform_attribute, wraps_set]
        )

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerLogDestinationOutputReference":
        """
        :param index: the index of the item to return.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5654e7bedd39d2098c61f4f42b4a1c256105e5c129541c0ff7f53c30c5da4e31
            )
            check_type(
                argname="argument index", value=index, expected_type=type_hints["index"]
            )
        return typing.cast(
            "AppSpecWorkerLogDestinationOutputReference",
            jsii.invoke(self, "get", [index]),
        )

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        """The attribute on the parent resource this class is referencing."""
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f60ee8acc6fd6a2400da15c8547543ddcad2514cd17a2e49187148ec667267e2
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformAttribute", value)

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        """The parent resource."""
        return typing.cast(
            _cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource")
        )

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__85f01336d1ced1eac46cf49d16078af32fdba9ddc868eadb94fc863af9b15850
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "terraformResource", value)

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        """whether the list is wrapping a set (will add tolist() to be able to access an item via an index)."""
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e66a998bd5b2dac6eb5a7baa40dc910d91e82cc35a24742e9549db5b798c66b8
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "wrapsSet", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecWorkerLogDestination],
                ]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]
            ]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d329df2f0719570784fe407c7b758a6acfa2c3e6f1fb01845fae3e782e619beb
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecWorkerLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b548b79b793340ff4a7573a993ea626801381f91924f873dbc759f11005fcc20
            )
            check_type(
                argname="argument token", value=token, expected_type=type_hints["token"]
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        """Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__2b5f349d911c2fdbb56d28c6e5166ead5ca2a424e55870679e0939f2ecbaec55
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__698531dcc3f7104f97325d873facd64337e31aef5cc3a9d26221072e503b5047
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "token", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecWorkerLogDestinationLogtail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ab62324ba65ec8421ba529b746de0193d0d66848cef09893ca1f8b64e30ab324
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__ac32eb3acf6e18506ac3cf63cd808331df6ec8613584190cd4c6d5565143862f
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecWorkerLogDestinationDatadog(api_key=api_key, endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        """
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#token App#token}
        """
        value = AppSpecWorkerLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        value = AppSpecWorkerLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecWorkerLogDestinationDatadogOutputReference:
        return typing.cast(
            AppSpecWorkerLogDestinationDatadogOutputReference, jsii.get(self, "datadog")
        )

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecWorkerLogDestinationLogtailOutputReference:
        return typing.cast(
            AppSpecWorkerLogDestinationLogtailOutputReference, jsii.get(self, "logtail")
        )

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecWorkerLogDestinationPapertrailOutputReference":
        return typing.cast(
            "AppSpecWorkerLogDestinationPapertrailOutputReference",
            jsii.get(self, "papertrail"),
        )

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecWorkerLogDestinationDatadog]:
        return typing.cast(
            typing.Optional[AppSpecWorkerLogDestinationDatadog],
            jsii.get(self, "datadogInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecWorkerLogDestinationLogtail]:
        return typing.cast(
            typing.Optional[AppSpecWorkerLogDestinationLogtail],
            jsii.get(self, "logtailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(
        self,
    ) -> typing.Optional["AppSpecWorkerLogDestinationPapertrail"]:
        return typing.cast(
            typing.Optional["AppSpecWorkerLogDestinationPapertrail"],
            jsii.get(self, "papertrailInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__7a95d3f41d95a8aefd2e379c7a946cbbba0994c4ac04e16f0d556283fc6752a0
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]
            ],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__0dad53b84e891f17f58002b215e86bf5909949eae69d836034d2798f3543dddd
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecWorkerLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        """
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f1e5075457fe41ac61a4969d21bd2938de80094ee5fbece592d15094094bb8a4
            )
            check_type(
                argname="argument endpoint",
                value=endpoint,
                expected_type=type_hints["endpoint"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        """Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#endpoint App#endpoint}
        """
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__c811f525dae470e5e1f7d9ebcf8f91c87d866473cce542bbe3468a5ec5780573
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "endpointInput")
        )

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1395156b4e1ce2438b6acaa722c26a38a118bcd0c68a863229823ced7c8bf3b9
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerLogDestinationPapertrail]:
        return typing.cast(
            typing.Optional[AppSpecWorkerLogDestinationPapertrail],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__222dcae7e28e90435272f0acca02db897db984e276ab53b0f0a5a129414828ce
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


class AppSpecWorkerOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppSpecWorkerOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__e8a3e4d07a2d1fa7a88fcedb16a59cd83031cf6a0594582476ad148d1e68921e
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
            check_type(
                argname="argument complex_object_index",
                value=complex_object_index,
                expected_type=type_hints["complex_object_index"],
            )
            check_type(
                argname="argument complex_object_is_from_set",
                value=complex_object_is_from_set,
                expected_type=type_hints["complex_object_is_from_set"],
            )
        jsii.create(
            self.__class__,
            self,
            [
                terraform_resource,
                terraform_attribute,
                complex_object_index,
                complex_object_is_from_set,
            ],
        )

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecWorkerAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__71afa39146360719470fcfba6f82ea67e2ae3dfa17bdd2b69b8bd9bdaa42c550
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecWorkerEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__f731ece5f505b4aeef53b419892ef39dd8b95cc7548ed3c314f5a41ebd55b343
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo_clone_url App#repo_clone_url}
        """
        value = AppSpecWorkerGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecWorkerGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[
            typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
        ] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repo App#repo}
        """
        value = AppSpecWorkerGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putImage")
    def put_image(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[
            typing.Union[
                _cdktf_9a9027ec.IResolvable,
                typing.Sequence[
                    typing.Union[
                        AppSpecWorkerImageDeployOnPush,
                        typing.Dict[builtins.str, typing.Any],
                    ]
                ],
            ]
        ] = None,
        registry: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        """
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#registry App#registry}
        :param tag: The repository tag. Defaults to latest if not provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#tag App#tag}
        """
        value = AppSpecWorkerImage(
            registry_type=registry_type,
            repository=repository,
            deploy_on_push=deploy_on_push,
            registry=registry,
            tag=tag,
        )

        return typing.cast(None, jsii.invoke(self, "putImage", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecWorkerLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ],
    ) -> None:
        """
        :param value: -
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a0e7592e6e6cce68dbd808ce356f06f2f3f9a4be845d0c080dd74f7011f789d4
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetInstanceCount")
    def reset_instance_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceCount", []))

    @jsii.member(jsii_name="resetInstanceSizeSlug")
    def reset_instance_size_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceSizeSlug", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRunCommand")
    def reset_run_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunCommand", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecWorkerAlertList:
        return typing.cast(AppSpecWorkerAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecWorkerEnvList:
        return typing.cast(AppSpecWorkerEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecWorkerGitOutputReference:
        return typing.cast(AppSpecWorkerGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecWorkerGithubOutputReference:
        return typing.cast(AppSpecWorkerGithubOutputReference, jsii.get(self, "github"))

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecWorkerGitlabOutputReference:
        return typing.cast(AppSpecWorkerGitlabOutputReference, jsii.get(self, "gitlab"))

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> AppSpecWorkerImageOutputReference:
        return typing.cast(AppSpecWorkerImageOutputReference, jsii.get(self, "image"))

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecWorkerLogDestinationList:
        return typing.cast(
            AppSpecWorkerLogDestinationList, jsii.get(self, "logDestination")
        )

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]
                ]
            ],
            jsii.get(self, "alertInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "buildCommandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput")
        )

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]
            ],
            jsii.get(self, "envInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput")
        )

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecWorkerGithub]:
        return typing.cast(
            typing.Optional[AppSpecWorkerGithub], jsii.get(self, "githubInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecWorkerGit]:
        return typing.cast(
            typing.Optional[AppSpecWorkerGit], jsii.get(self, "gitInput")
        )

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecWorkerGitlab]:
        return typing.cast(
            typing.Optional[AppSpecWorkerGitlab], jsii.get(self, "gitlabInput")
        )

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[AppSpecWorkerImage]:
        return typing.cast(
            typing.Optional[AppSpecWorkerImage], jsii.get(self, "imageInput")
        )

    @builtins.property
    @jsii.member(jsii_name="instanceCountInput")
    def instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(
            typing.Optional[jsii.Number], jsii.get(self, "instanceCountInput")
        )

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlugInput")
    def instance_size_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "instanceSizeSlugInput")
        )

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]
        ]
    ]:
        return typing.cast(
            typing.Optional[
                typing.Union[
                    _cdktf_9a9027ec.IResolvable,
                    typing.List[AppSpecWorkerLogDestination],
                ]
            ],
            jsii.get(self, "logDestinationInput"),
        )

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="runCommandInput")
    def run_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "runCommandInput")
        )

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(
            typing.Optional[builtins.str], jsii.get(self, "sourceDirInput")
        )

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__aaaa5ad0e680d4675295689a235b369626464dce314c58604800bf606c7e3882
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "buildCommand", value)

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a172f6591b422bf72bd74aae3936c939418247bb15f10b2aa61f1d59424b51f7
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "dockerfilePath", value)

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__d8b4500b1b05cf98fd166636a846b59275424a3254a6ffe687604b9e6bf1bb80
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "environmentSlug", value)

    @builtins.property
    @jsii.member(jsii_name="instanceCount")
    def instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "instanceCount"))

    @instance_count.setter
    def instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__a5ac52b134cd4ec73118acacab7b36e10de6adfa93b089c66ed9426c738e59ca
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "instanceCount", value)

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlug")
    def instance_size_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "instanceSizeSlug"))

    @instance_size_slug.setter
    def instance_size_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__de0fb4065e1f356f4a9078abef4da0026196c065c45e3239d2bebaca486e2630
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "instanceSizeSlug", value)

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__00dbd8034b4ade52071a948a4a5df9c10a50a43c9517d5246d8ac59fa10d478a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "name", value)

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runCommand"))

    @run_command.setter
    def run_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__5efe0a244e80c19f0f5c896738ca406b34e5edcc14f604f3a0405b61e3f8608a
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "runCommand", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__1d038b0ef4e8361a2cee9db23a500a842984b59271cba195f5b857184f3ed69e
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "sourceDir", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[
            typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]
        ],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bcbeed2d3c449b58623f2ccfe05554031ebcb697e5ee31ae451b3c58624aa655
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


@jsii.data_type(
    jsii_type="digitalocean.app.AppTimeouts",
    jsii_struct_bases=[],
    name_mapping={"create": "create"},
)
class AppTimeouts:
    def __init__(self, *, create: typing.Optional[builtins.str] = None) -> None:
        """
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#create App#create}.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__30ad37303995ea1d7133866ab2a23a3500d973dc3c8ba80685023b04b46dd585
            )
            check_type(
                argname="argument create",
                value=create,
                expected_type=type_hints["create"],
            )
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if create is not None:
            self._values["create"] = create

    @builtins.property
    def create(self) -> typing.Optional[builtins.str]:
        """Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.28.1/docs/resources/app#create App#create}."""
        result = self._values.get("create")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="digitalocean.app.AppTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        """
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        """
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__bb1235d4faeb8c5d0a852bdef48511faa5279a37243073f15d9aae25ba2deaaa
            )
            check_type(
                argname="argument terraform_resource",
                value=terraform_resource,
                expected_type=type_hints["terraform_resource"],
            )
            check_type(
                argname="argument terraform_attribute",
                value=terraform_attribute,
                expected_type=type_hints["terraform_attribute"],
            )
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCreate")
    def reset_create(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreate", []))

    @builtins.property
    @jsii.member(jsii_name="createInput")
    def create_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "createInput"))

    @builtins.property
    @jsii.member(jsii_name="create")
    def create(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "create"))

    @create.setter
    def create(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__00e8b50d51ddcf2fe5d7d805e656fd92e710089f352eca95db4f16b96e78e8bf
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "create", value)

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]]:
        return typing.cast(
            typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]],
            jsii.get(self, "internalValue"),
        )

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(
                _typecheckingstub__b91a02aa6070fd052e12784bede6620fa82cdfd2ce89c035170f2bb5480e258d
            )
            check_type(
                argname="argument value", value=value, expected_type=type_hints["value"]
            )
        jsii.set(self, "internalValue", value)


__all__ = [
    "App",
    "AppConfig",
    "AppSpec",
    "AppSpecAlert",
    "AppSpecAlertList",
    "AppSpecAlertOutputReference",
    "AppSpecDatabase",
    "AppSpecDatabaseList",
    "AppSpecDatabaseOutputReference",
    "AppSpecDomain",
    "AppSpecDomainList",
    "AppSpecDomainOutputReference",
    "AppSpecEnv",
    "AppSpecEnvList",
    "AppSpecEnvOutputReference",
    "AppSpecFunction",
    "AppSpecFunctionAlert",
    "AppSpecFunctionAlertList",
    "AppSpecFunctionAlertOutputReference",
    "AppSpecFunctionCors",
    "AppSpecFunctionCorsAllowOrigins",
    "AppSpecFunctionCorsAllowOriginsOutputReference",
    "AppSpecFunctionCorsOutputReference",
    "AppSpecFunctionEnv",
    "AppSpecFunctionEnvList",
    "AppSpecFunctionEnvOutputReference",
    "AppSpecFunctionGit",
    "AppSpecFunctionGitOutputReference",
    "AppSpecFunctionGithub",
    "AppSpecFunctionGithubOutputReference",
    "AppSpecFunctionGitlab",
    "AppSpecFunctionGitlabOutputReference",
    "AppSpecFunctionList",
    "AppSpecFunctionLogDestination",
    "AppSpecFunctionLogDestinationDatadog",
    "AppSpecFunctionLogDestinationDatadogOutputReference",
    "AppSpecFunctionLogDestinationList",
    "AppSpecFunctionLogDestinationLogtail",
    "AppSpecFunctionLogDestinationLogtailOutputReference",
    "AppSpecFunctionLogDestinationOutputReference",
    "AppSpecFunctionLogDestinationPapertrail",
    "AppSpecFunctionLogDestinationPapertrailOutputReference",
    "AppSpecFunctionOutputReference",
    "AppSpecFunctionRoutes",
    "AppSpecFunctionRoutesList",
    "AppSpecFunctionRoutesOutputReference",
    "AppSpecJob",
    "AppSpecJobAlert",
    "AppSpecJobAlertList",
    "AppSpecJobAlertOutputReference",
    "AppSpecJobEnv",
    "AppSpecJobEnvList",
    "AppSpecJobEnvOutputReference",
    "AppSpecJobGit",
    "AppSpecJobGitOutputReference",
    "AppSpecJobGithub",
    "AppSpecJobGithubOutputReference",
    "AppSpecJobGitlab",
    "AppSpecJobGitlabOutputReference",
    "AppSpecJobImage",
    "AppSpecJobImageDeployOnPush",
    "AppSpecJobImageDeployOnPushList",
    "AppSpecJobImageDeployOnPushOutputReference",
    "AppSpecJobImageOutputReference",
    "AppSpecJobList",
    "AppSpecJobLogDestination",
    "AppSpecJobLogDestinationDatadog",
    "AppSpecJobLogDestinationDatadogOutputReference",
    "AppSpecJobLogDestinationList",
    "AppSpecJobLogDestinationLogtail",
    "AppSpecJobLogDestinationLogtailOutputReference",
    "AppSpecJobLogDestinationOutputReference",
    "AppSpecJobLogDestinationPapertrail",
    "AppSpecJobLogDestinationPapertrailOutputReference",
    "AppSpecJobOutputReference",
    "AppSpecOutputReference",
    "AppSpecService",
    "AppSpecServiceAlert",
    "AppSpecServiceAlertList",
    "AppSpecServiceAlertOutputReference",
    "AppSpecServiceCors",
    "AppSpecServiceCorsAllowOrigins",
    "AppSpecServiceCorsAllowOriginsOutputReference",
    "AppSpecServiceCorsOutputReference",
    "AppSpecServiceEnv",
    "AppSpecServiceEnvList",
    "AppSpecServiceEnvOutputReference",
    "AppSpecServiceGit",
    "AppSpecServiceGitOutputReference",
    "AppSpecServiceGithub",
    "AppSpecServiceGithubOutputReference",
    "AppSpecServiceGitlab",
    "AppSpecServiceGitlabOutputReference",
    "AppSpecServiceHealthCheck",
    "AppSpecServiceHealthCheckOutputReference",
    "AppSpecServiceImage",
    "AppSpecServiceImageDeployOnPush",
    "AppSpecServiceImageDeployOnPushList",
    "AppSpecServiceImageDeployOnPushOutputReference",
    "AppSpecServiceImageOutputReference",
    "AppSpecServiceList",
    "AppSpecServiceLogDestination",
    "AppSpecServiceLogDestinationDatadog",
    "AppSpecServiceLogDestinationDatadogOutputReference",
    "AppSpecServiceLogDestinationList",
    "AppSpecServiceLogDestinationLogtail",
    "AppSpecServiceLogDestinationLogtailOutputReference",
    "AppSpecServiceLogDestinationOutputReference",
    "AppSpecServiceLogDestinationPapertrail",
    "AppSpecServiceLogDestinationPapertrailOutputReference",
    "AppSpecServiceOutputReference",
    "AppSpecServiceRoutes",
    "AppSpecServiceRoutesList",
    "AppSpecServiceRoutesOutputReference",
    "AppSpecStaticSite",
    "AppSpecStaticSiteCors",
    "AppSpecStaticSiteCorsAllowOrigins",
    "AppSpecStaticSiteCorsAllowOriginsOutputReference",
    "AppSpecStaticSiteCorsOutputReference",
    "AppSpecStaticSiteEnv",
    "AppSpecStaticSiteEnvList",
    "AppSpecStaticSiteEnvOutputReference",
    "AppSpecStaticSiteGit",
    "AppSpecStaticSiteGitOutputReference",
    "AppSpecStaticSiteGithub",
    "AppSpecStaticSiteGithubOutputReference",
    "AppSpecStaticSiteGitlab",
    "AppSpecStaticSiteGitlabOutputReference",
    "AppSpecStaticSiteList",
    "AppSpecStaticSiteOutputReference",
    "AppSpecStaticSiteRoutes",
    "AppSpecStaticSiteRoutesList",
    "AppSpecStaticSiteRoutesOutputReference",
    "AppSpecWorker",
    "AppSpecWorkerAlert",
    "AppSpecWorkerAlertList",
    "AppSpecWorkerAlertOutputReference",
    "AppSpecWorkerEnv",
    "AppSpecWorkerEnvList",
    "AppSpecWorkerEnvOutputReference",
    "AppSpecWorkerGit",
    "AppSpecWorkerGitOutputReference",
    "AppSpecWorkerGithub",
    "AppSpecWorkerGithubOutputReference",
    "AppSpecWorkerGitlab",
    "AppSpecWorkerGitlabOutputReference",
    "AppSpecWorkerImage",
    "AppSpecWorkerImageDeployOnPush",
    "AppSpecWorkerImageDeployOnPushList",
    "AppSpecWorkerImageDeployOnPushOutputReference",
    "AppSpecWorkerImageOutputReference",
    "AppSpecWorkerList",
    "AppSpecWorkerLogDestination",
    "AppSpecWorkerLogDestinationDatadog",
    "AppSpecWorkerLogDestinationDatadogOutputReference",
    "AppSpecWorkerLogDestinationList",
    "AppSpecWorkerLogDestinationLogtail",
    "AppSpecWorkerLogDestinationLogtailOutputReference",
    "AppSpecWorkerLogDestinationOutputReference",
    "AppSpecWorkerLogDestinationPapertrail",
    "AppSpecWorkerLogDestinationPapertrailOutputReference",
    "AppSpecWorkerOutputReference",
    "AppTimeouts",
    "AppTimeoutsOutputReference",
]

publication.publish()


def _typecheckingstub__9719f48172aa2035f5d9938d6776537bfc7bd94d5f0cad4489626d8a62d17da7(
    scope: _constructs_77d1e7e8.Construct,
    id_: builtins.str,
    *,
    id: typing.Optional[builtins.str] = None,
    spec: typing.Optional[
        typing.Union[AppSpec, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    timeouts: typing.Optional[
        typing.Union[AppTimeouts, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    connection: typing.Optional[
        typing.Union[
            typing.Union[
                _cdktf_9a9027ec.SSHProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
            typing.Union[
                _cdktf_9a9027ec.WinrmProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
        ]
    ] = None,
    count: typing.Optional[
        typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
    ] = None,
    depends_on: typing.Optional[
        typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
    ] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.TerraformResourceLifecycle,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[
        typing.Sequence[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.FileProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.LocalExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.RemoteExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__25462453e965bf4db9f29422031d45d834c773a920451b794e537ca23137c526(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c779963e1fbb744b09c3c12e83b9b8eab3501d9a5e78f0f17e085df2e8dfc651(
    *,
    connection: typing.Optional[
        typing.Union[
            typing.Union[
                _cdktf_9a9027ec.SSHProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
            typing.Union[
                _cdktf_9a9027ec.WinrmProvisionerConnection,
                typing.Dict[builtins.str, typing.Any],
            ],
        ]
    ] = None,
    count: typing.Optional[
        typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]
    ] = None,
    depends_on: typing.Optional[
        typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]
    ] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.TerraformResourceLifecycle,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[
        typing.Sequence[
            typing.Union[
                typing.Union[
                    _cdktf_9a9027ec.FileProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.LocalExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
                typing.Union[
                    _cdktf_9a9027ec.RemoteExecProvisioner,
                    typing.Dict[builtins.str, typing.Any],
                ],
            ]
        ]
    ] = None,
    id: typing.Optional[builtins.str] = None,
    spec: typing.Optional[
        typing.Union[AppSpec, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    timeouts: typing.Optional[
        typing.Union[AppTimeouts, typing.Dict[builtins.str, typing.Any]]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1b82fb39ffdc69d3d1d97267325ac05b7b7483d5f92437033f065d32d94adc21(
    *,
    name: builtins.str,
    alert: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    database: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecDatabase, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    domain: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecDomain, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    domains: typing.Optional[typing.Sequence[builtins.str]] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    function: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecFunction, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    job: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecJob, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    region: typing.Optional[builtins.str] = None,
    service: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecService, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    static_site: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecStaticSite, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    worker: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecWorker, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ec82ed85c3a33e2c09dd2fa5c47d4918f72627511d49328ba566d27c48b3d8ae(
    *,
    rule: builtins.str,
    disabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08514ffdb29365a085031be373e4d9bb023f828241b6bef50ae584ae455389e5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c1a9170daf7fca72e0aba8094a30605757459e36ae86fdea35bd51750778fa8(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cb19d3b3d493702bc9ae2f6ab79694f5e23da99b3326c03a2867ec8f8579c22d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__92a354fab1890a24acdd598f5c8b6ea19e727ea1303754ccbbbb29cb78e88655(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2cd9ad1b9d2c20682052d30ffd9b619714c2f79fa82d1b1242e898f95bcb4644(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a343d27693f0a90e1a98106534d1bf4899ce79292010e12c4dbfce5f0a190a71(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c337ecdaa0de661087b1e7efac064befe352080c42d92d7a40ef9a855a1e6cb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__543d9ec2e09b576f1c8d2fb0081faaca78f3b4a05234f811eb2f2f59c4bfef85(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a8cffe9b6053184a9748da50fda5a2322578ecee660a5fc6a5d0b7133e28d72a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__459d322eb90b8c00b0607ba22f19329272aff18b9521097116e4cc6e0c4dfce2(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__804a3918707e409695bb5d473660cede76ed37be4a7066c79971549c2750e2d6(
    *,
    cluster_name: typing.Optional[builtins.str] = None,
    db_name: typing.Optional[builtins.str] = None,
    db_user: typing.Optional[builtins.str] = None,
    engine: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    production: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__84a22d253fdf753bc1d945c991827aa8b258578592891b36e2021690fa16272c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6c4ff3130bb087c6d306c0d176bc4ffbb600d17ef1683dcb9222084ccde1c791(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__03f8cbaf4d909d7ee7015d28cd91b20be23382a0d67435772e08ada3d031e445(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ec75930387e5f163026777ad49a5bf25ff90e191f182e21488b63ae10ce84d6e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4dd22be6f85b84517b1d60504b882f26a46f11a321b095dde9d7fc37d858a7bd(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1687e5582c12c262ddf5edc2e945f37de4fe27380c1fe800a3e1397ebf87b542(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__44db75570d6d5a036dca1087dd9694ccb54b5716054bf7f5c9467fc1f2bed0da(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fa57e2dfb8fe8097c92a81e9d1869fd6ee0c8824b617963aac95c8d537fdb6fd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9afd9e6d5b924bbccad5eedb713ab875a86a982bb818c91d25aade4231f08385(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a97fefad0e6630a7005ea80dfdc59811d28385a9197a23cf90765d6d2ae995aa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0b090f2979e3be7bed4605c291becd32c858482ad6109fe7ef91404bf2fea950(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__136d8e358a956026ff9e84d6b9310885051fd2470648bc42c6f022e1e00ffea5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__406ead2e00747d59251281a243b6ba00babe6b6b1cd0fabc632ef13d2e4ed75d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dc0c68e218284c8b1fd2f2123a172c060e2ef6227abca7372a31c6c0b1a32b19(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__29b7117840a44e728fbf14edad792eb2d3d345b2b2d00a419d89bc95939c2b3a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a0a95514109e9fb1e07266429b86e0b1b2a420182e790096cb1c80e9c9f5cebb(
    *,
    name: builtins.str,
    type: typing.Optional[builtins.str] = None,
    wildcard: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    zone: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ffa074cdce6ada798e59060c6a188f430e2442c55eee8ec2b0c19ebdce07000d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__794214168f73fc57f76890397a2b117b802cd39f659758b8451eddb5b99d5fa0(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5fb0f930a614cfc7c8c4567083c2ff610dbc1976489651ad3db497c99ef704b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5c6ba64ca5a6a8be9e1f5d736b68c5846e88f4fc487dded0a082d9341a7567f1(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__41b5740fcbc595d9df35321d5cf9d3fd9c8a3bb70a281255f3e050f7d603c8c1(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d7410ce653fd24cc7df485c05bd62af0b43c6488b2cfa09a031a12df63a75242(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9eba864c044fc064338347e23b31b68d111c88b4e100c274c68792d162fde44e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__624b63e3d3c1102b006b427c2dd7f2c5be0a0c7565f608f9339fbd00696cc34a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c9a0f02d7532f2a13486767e7baf24ebb2d29f4ff97a5006ccb863e52bc6b7ed(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1939fb1df3c517f5ed70af830ed75edeb1555a0053c157b12e815126b6f028e9(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d663669895832d1dc718c326d048d85eb61a985a7d33ff8c5049d0d1b0b7245e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__920f281cd80602722b26402cfb3e7b5f4a561a59093f66c9afee1f8c1b1a6e69(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3448b16d9cfd75574e259daa9e29e7357a98db7c1adfbbfb1372e7355259960c(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__49c0b9d31933b2374f58f4993803e5187c569aa0e69349d56479429c854d160c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0ef90e41c091f47875bb21b38c7400b382f48e542cd402a88c53931e67da78e6(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6c8f1798b396d4ba46fb42cee5ed4b94a35ad152ad413c41194744b14602e424(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d847096eade6f962244852701ab6315594a4c97a0f07bdefe866291bb237832b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d97fd5426a25ae09646da7c341f6334080bb24cc7be01c3c604cf6f7919a1aa9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2aef7dc475365d8dc024ab78cf6369d4af57fcae7de2472335b9759c99317085(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__86438fcee59fde0f4f4e3a3321a6908c3e85587d425703346a55c50cda36c368(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ef3a75d32d5dac35cd90aedc9140ff2891bb75bbef7031e3df3aa77c3b080e83(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__39a2a684dc3622746bb89ca0499ca4262e2b9c1b9c01071c4cb3967ed2192348(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9a4e8e6c16333841463f6b127d0d5d2fc4d969404f52aae64d027fcefed096ba(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc9d3432d58173aab9315d021a9d4fc8e5dbe51779fa1db75e837fc00d362342(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97f8448ae3d9db7b24c92a79d2e834236f0f3c8bf7dae209a15fa7f3a90454eb(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__525f9966acca88cf512b41751b1d59f0767ce801ebbe5dbfc12e6830b484279f(
    *,
    name: builtins.str,
    alert: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecFunctionAlert, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    cors: typing.Optional[
        typing.Union[AppSpecFunctionCors, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecFunctionEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    git: typing.Optional[
        typing.Union[AppSpecFunctionGit, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    github: typing.Optional[
        typing.Union[AppSpecFunctionGithub, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    gitlab: typing.Optional[
        typing.Union[AppSpecFunctionGitlab, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    log_destination: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecFunctionLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    routes: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecFunctionRoutes, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    source_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__143e3ca6aac49eadbd075154e477f46a13154364bc4e84774f7521f00d6b9431(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    disabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__039eef56c09a8b874b5085d2c4484b368f506ee512f08e0b3740d20dbe7adf74(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3ff42bf60101ff0399bc892b3277be7ce8d4042f2ef1d9a3bf5090581926b182(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__46da9eb6d97064e216efa20e3da83dafee9de8bf20dcedbade6ff0b9333cff98(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__232c2bf0222ec236dda02ca4c120453164a2c8c2547a93616993ad0fc2cfb260(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4967c800ce0d72644d288a755103967bdae87b87914ddb142f06feb5d0e5ad6c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56f5b5eae0d4dad0bac1aee3cbd270e191420b8b36b8dda7e1634df27d14bb5e(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8164affd75077e8f0de62b087ae9b1182ab2b33adc8b950a72abc631fa64c012(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cb2acd9804a502c965ae5d912e759529b68a8495d47ee44b6178e5fc2f530f8b(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__be7b28e578f671068f1fda271449cae7bee8049ae11fc21f537987884589ec15(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8769a0d23971bcc76ab4d236a4d90eac45ba3e4f531debc3f86dd5e1545091f6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__db8e51f26ef172b0e655317f4cc2b171acdf5b890b2364e2d51f28cdd0defe23(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__afbbd96dd643cb031d86f90d56bb643923a0a59ee25edd11db1fb63012467e76(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b0ee4f59e39d16e75b06c1d29021a655331629369ae8aef5d797de243d8f34af(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5e408f6ba122ddf6ba19e76ee017a841c153a01468c0cb0b67a28ff3f5bd6656(
    *,
    allow_credentials: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_origins: typing.Optional[
        typing.Union[
            AppSpecFunctionCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_age: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f1428671654e83ce5ba5594c3eefe8119fecf7d0980c6d551be82117c8a895dc(
    *,
    exact: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    regex: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15e07c50d27d6b1b498bce703c3aec295d02238298e49d7a52e091e667ebb439(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__52be6f401e908d761d34557ef6b54792edfa2fb336ec752d6165cab092915d19(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2c3cff0688eb2247d4ed132a7fbbea95e0d77ac04083c3ca0b009402f73b8048(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e56cbe488c39d9738553b6e6baa69442046145580f0ca80d06ba5c4117027c5d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4375f86e23242a19f5e9a5df5a1e5a12afce98e354333f8cc7206e40d7aa28d3(
    value: typing.Optional[AppSpecFunctionCorsAllowOrigins],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8f41864b6291c61c8aec764f060118c23260d09cde7bcf8016dd53d541d89b9f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b380c83f9ed466f1a572b4bfbfedfe3495bfe6ae548dbf49ba5ee5af24882a0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5b4eb0cb2c20ff2cfa51a4be56d267df20de07879622e980ff622c5611a88e3a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1297f31f66fd6a622ef06619d954d34264c065461cbc0f9b4b225aef3c806ad1(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4428bac869e13b208783747b4444c1655f9225e6c518c91c8c7a4d7d37edc6f9(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b07059acb73695e81334f100b8e9e14b841e9de619875b625ee2db352de2cb0a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1bdbe0b6c8ef7977a56de07d83c980cdbcb773d376810727fb9a8646ec960145(
    value: typing.Optional[AppSpecFunctionCors],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__af94710578d3426c78190364e5810cdff1b3a6eaa6837efc4418e25bf83ea1c2(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c6ddbaf2a0340f7f2addb8deb47d7b3cd84aa03fdd0accc7f771f23c8cc558c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1ab057e86169f3fb2b500254944b2faa259a2169a5b198d2fca8f334df10b3ba(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5699b64ce2e0910d54e80b76b3d6d7ad5e514fc208e912646d944457a47ee3cb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__680a11658c56b2b6b6453e019d45db6b132d1bbd18bab83cadde2812f84af35b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b649b64de73ff87426c3469e9e680297883fcc657e910311626646a084c719e2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4ccbb821e84609b883c58195c776fd85a14472d8d1ea6b307076c722dce1ccb0(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8008a9e8c2aefca9e9aa25cb53631c842e46fc6d4c7a39a5927ee1066c4b5a90(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d74d127b2b73def9daabc71008f267fd1a9417f422ff50048c4ce443c80e2cfc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2bb5c08dc1042dc4c18b70dfb4f957911c3db22e74a6682f39f19a6cca202140(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__82757b89450558d5f9762be7afabbfafb50a206e0012bef3ed1ecad247f23a94(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3059b1eaee6ea047170a6b0314f3672aa7aa7fc29a797240138b8b165769e38c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__49415869a5c9d54dfe64a83b98f14cb7af2b07826da26cdfb43189ab808f47e2(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__221635171c00a66deb1f01fdd951431a67f6ff6d470933cce4e81d6ec850cb04(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d013edb8871edb48e2eb7bb4d7250029113755161e0807d2839d3013e8073b10(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4d9bdf584b5f05d5a1b5ab9927ec881f1899343e83cd87f526772a6ffbbb8a47(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d3e2f358443402bdf1c55d2e946deea3edecdc779f94949f3dc8159f65a15b9b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f17578b946bcc3ca90f13e90fd90e62110d0285466284fce70a7cb8bb189ea3(
    value: typing.Optional[AppSpecFunctionGit],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__88d863275bccaed956728532b717debe2ae77a1edf58892ab6d085156ba84b75(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1c11c685804c14fb8d7eb317734dad37d85d25edc651f05639f0abf43fb88a83(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__078baa9b95c8cc1cb68f721979a39d3780fba4367c146f5ae6aa53aa542452f0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5082aa677781d03642318655e8e64e93221979e76e0ff1f03dc74036e9389618(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1549fc5705c4600cddcc136f34948e715be0b4b41d20ae93525b6534e2bfd3d0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bbc866ffdeb1f227d75c240e77fb4e21c84f4f7c3e553b87832e99f161254e4f(
    value: typing.Optional[AppSpecFunctionGithub],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7c3b6bb8fa457815dda961523dbce54696cb0f816f45d6af02b3610a27563c36(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__12f98109dcc3cf74b6f0e0de1300aa919560e06c0d092e0134620b0f39744cb5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ea93dc866f6317a67c6081c695a27d9b705c902ad37654e11332c4d109a41b6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__01fd76cc7ec23b1f3ee6a0e0517bf3c5885cc87776cb9cf0e68b1a8665a632a3(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5634589332fe9fe635d549626750a3c287ad15cc80491881d024f157d82578a9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5fa0c67cc34fdf4a9111ab5584ccc83372f4f2d98d020df9994584f7342833d8(
    value: typing.Optional[AppSpecFunctionGitlab],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1dd5216e710ffaaf201a9cbd4938f3e1a4387737a57e9a4896d7c6d2e1e0cd22(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d15e4780fa44e7e799a2ac4ae8178e17f04c8a8920c31273d55ee573b0366106(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a412a35cad2b82402ce06596c0d056780b88c7a8c81adaa9bbb4cd8beb9034aa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__acd15799a49d492555a7c58010d7c1e3774c40167d3c30ded26046f5a252575c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e6fd8109c8068b1d23cf81d8eadbb8956f281018bd6ff585836b24d82f7ba746(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__700e548177b0e91284d4e403d33b5789b9c9dca87c27ff967cd21948f091d220(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dfe075f8a06b478a90191a318e9d1f24f6cf5be3766abe9a1d7082a8ea9dc353(
    *,
    name: builtins.str,
    datadog: typing.Optional[
        typing.Union[
            AppSpecFunctionLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    logtail: typing.Optional[
        typing.Union[
            AppSpecFunctionLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    papertrail: typing.Optional[
        typing.Union[
            AppSpecFunctionLogDestinationPapertrail,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8192b195c034b5f8867de43a7d87b2f47d1d08b3b5f7ff9a1f753651f2fcfcda(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d6cc99b83fa835e5aa9152e8114f8b0b33675ac6d42b783f922a202a062e0b53(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fced31af0cfe57ee3d9291c634d66eaf19bd0b37a42f4886af3bb49980a662db(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__75d6217fd33a1d36b2abd1daa6ae41043103dfa1ab2bd6e8261323819f56d512(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__50fd2f2eef61729b62ce3b67ef445d90362b46718ae3530cc8d60b434c68d816(
    value: typing.Optional[AppSpecFunctionLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e91034db952403acb5c54ca4e125ba12803cbccc0e843daea17573cb266ef189(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f60da452eddd5ef33e3065fdc7fb6866c58828ee02afeb771cd7979f57766a8a(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__50574085086a9e59dcb19fe0c16cfea66b670d703a31257d408a230cc9ec574b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c3dcebae90e65ccc615a90273dd7ca081eddcb364980dbf055c6b895168cfd90(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1fde8b655ea4883e27a56a2d555315782df427683d1c7ab0360c70d5c7fd6578(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e1a6446a8c015a75ce3b7140d09ca8dc4b87ea547137b353bdd0107ea25f7e7e(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b72858795d854a40729964ca2e6092e34ef03a952a8e034ae5a47b0e295f6401(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__68c31a59f7d2d70d71f0181f5f3d4e6a772e16b5a2fb217868eb0657e1f2ca04(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__44cdd71ad157c468618942f810a8a52ec7e157b96d2df3656983c7d1415ce1ae(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__286468fc19f48a926bfd90e0fb2c082b8c1f98041aaf8c66ac1e7addd4a3ec5c(
    value: typing.Optional[AppSpecFunctionLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__56b4a95f444c34bc85e340eb17948dbb8dc770f4a6a7f41c7af1701ce666e722(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__642eeca52178449887b09e2c25a985a38e07046e8ccb6ffca2072370def4d5d0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15a885846594c2ad1bd27b17194bcc4167cc6bcd540ea4327b618996db97bed6(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f5c2cd5e2992724cafc2f8b1a4308888e4cf5176699803440507f16b0e71907(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__76a21ac0626870a2de9243ae9e97e5a6097b677f69e6fd10853e3e15fcc67c86(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__50454607105d98255553872008aadea28cf4c4c4c0b6dbcfccb3ea5c4b3cdebf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f1f8a545f8acb2b85f24b5de3bdb5531b0f0540f41adb7c6489bca88e1977ec(
    value: typing.Optional[AppSpecFunctionLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__01f6634052b31e69f85b769d3f4e5dc0ce83594cd15e423a564bb09f4a9dd68e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c75b0e35d60ddccd25e45b6dccf7cb28d6760d16594658ba11be7716aec38cbf(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecFunctionAlert, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a488b005f65666b59fbc243eea157c58f8c98aa0642cbdc4edda69dbc199d2fe(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecFunctionEnv, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8bb9eed259eb37e5246d3edde9daea3bdfbb9e2fabb4f7fcff72f2d7c15f2797(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                AppSpecFunctionLogDestination, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7affdde1e9f2b006fbfdbb2a824b3b27b2d819d4f538135b6490de28ea701acc(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecFunctionRoutes, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bda339f2afeac86b62beb356c7f12df0878ca16df023ba0bd0a8f3f1dee28950(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c0efc4ee34c5cb64b53db0ab4fb24c3255cc0c3239ef3d6d845e332d430332d2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b8fd0fa32e34c5068a3d57d43410943f197a5ab20dc7af3120ffd4d0fc688f9e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6ca2d14868e49a58de2b505913734d01086cafee7a1f944392f551761cb0bf47(
    *,
    path: typing.Optional[builtins.str] = None,
    preserve_path_prefix: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b0783666b96a4132b7ea0ff9bd9a5c4cc7b5c0e12c0087e9f19b9052868fb816(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e74d606d00620d592ceebe95dddac745b92fe3bbc0e6a842dc2b161ae7a8f324(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aca64982cab2a540a5dcf1127be9c31a028491474fa509a9aecda40a8184eacc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1978d69df1d7ecf7e6679a86276b00c571147ff39d5630c6df463a49655c9eb0(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c8ccd0ed1ba47596f2aa4bff9e84d3cf4787af871b4d8e703a9284cac548eb17(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd6fe6b32eec3d3956a9d99e74767fc17875b42d92853edc06c55d2f29666b28(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8db7e24b4a995ea9bd317f2ae3b54b08eb92e47e597e560970a6923195d229b6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5c89d3824a482a7ee13a0e9e994554b071588710c4f7f2bf664a523cf64cf2df(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__45f9e437debbe2898df0afacd83a48ff104000089a91f4a814a25e24d15e0c96(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__091da90aeef315345b881fa909a8b09469ef98d42681f323b24bc81bc6913497(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c7e8ec9c99d37a1aa76dfa576e8b90fbc690a24431452ab7c9be78f465adb99b(
    *,
    name: builtins.str,
    alert: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecJobAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    build_command: typing.Optional[builtins.str] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecJobEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    git: typing.Optional[
        typing.Union[AppSpecJobGit, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    github: typing.Optional[
        typing.Union[AppSpecJobGithub, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    gitlab: typing.Optional[
        typing.Union[AppSpecJobGitlab, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    image: typing.Optional[
        typing.Union[AppSpecJobImage, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_size_slug: typing.Optional[builtins.str] = None,
    kind: typing.Optional[builtins.str] = None,
    log_destination: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecJobLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    run_command: typing.Optional[builtins.str] = None,
    source_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e63017acee2aa06d0b579073323e25dee85d5f0469b147aa05b0cfd60b519b43(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    disabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e9fd97f45cb86fea7d1b8cfa6f76ce09120efdcbe7fbb8b0f7f706b0dcd25f52(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d35e19424325caf5266e3f75c1cb1631f3fdf23cb56ce2c08c904b7786cc3b4f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c34c3a28babed84cebb2818b5f5bab49c551a828b2a6da1d59e93c086f8e9e02(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e1ae5c9b380a75c464e8ede65604492eef91c8c472dc337b9e3e843cfc388439(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__399a41fb691892965ebd298ea11b4d7f5ee736d8cea95d7c35d99eefbd5a7ab5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dfbb71570cd50899a48ff663f6dd872ccc4cd772c1a9d45e736ad621f270d20f(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d14537aae0afd9207fc8a3618aef468065354b79d6fb2049a46746cbc171b10b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fe9c3a2332754c62c71feb5204e50e2a79cd76e6790397ea00e9b7bf2758c72d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3cf14d9942abdcedc01888418cc4a639f70b53ab5d8e727211f1a21a38915de0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__996bcbdce536ac36fe292bd43f410ec56dafbcc4d0993fa0971a8cd492ab4514(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d79a235069f222f1e22b9b139ad3b44d2eee7452e8b321d4e321a53fb806a6ad(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cb796d2cb46d38c278beaeedd52b35ce5a13e7f857cfa40625145eb1b0227ce9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b5712c6b65600e43d811cfd4bce20b8e7427573166844990c4ead91e642e65ea(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15ae820b7b6ecf88c3f3273fd65ed44d6a0056e159a8ab5c0da82c3d78cc9910(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__053e356cc168fd34f33ff975e043ca1e6dd817d30813b3e6be84b979e2be6d9f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2109f2550d7ee9eaa82e7667d83e6f149e7a5f266b3c04a529447909290ca5ad(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__70fc48d996185a4f4d1ab9b89c7f265cac4e6da044d551e86fbf5efd28d33018(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f14a01dfdb408bb3e435fdd71f336a53831c13a7e227790a0c8d6d0bd6de8405(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aa7f7cf9c89056266a1ae5a0aa125adfa36e604fe33543b28e9c60a803689ef2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2921ada85a270f07bd3e6149dfa11036e4520c022e6b2d8414c7e2108cb1ab3b(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c936b273e720dcfe9420955e441ab0c35265fd48f81ccdb5be7e421d0e5397b7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aefd4be59fdc135e7cf7fdf01666f4cc4a1924890417c0603af4d17b3e41ca00(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bb2b934a2a7757911646725917c724ad3f0716414b6d61e3f83f1ef160bb1d51(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca9b0da7db3f976cfe5390275260f8c077726bb2ceabde54407887ae1997abc9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__14f573e68a8b9a469e640c7bfc25e4a4e9ee2422a8d90d2d20594d5d85b40ffb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__98978b77a0d12a3f99bcca511aadd9f29c0e0fa4e89439f5375858425b2ebd9f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__363565efc96ba7ac31265ae54fae2dcb14d0580bc6ec894ae8a414c374a0cd35(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__701bd4c7176cdbda7979081143e079a6d231208cb02e4d2c6d38ab3e54c56e80(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f806de3df1569aab6f21f346279d7a6feb2da6be51b59ebe30dbbab3a4ef5fb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__40fe5979c3477eb46146714fcbc3b1f0cf430b196b9795725ad60173f038609c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b6ce060e55407e9ed62fa66e5da731c1b968e69393fa37364d0bdbef010ea4c(
    value: typing.Optional[AppSpecJobGit],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__adafad65266c8df1cea1469bd85c0b4d2afcae151a1e52ec7322d0d948ebfd21(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5a4e12e5c36a24619414027aecd41f1053eb51fad584d3283b273c4204092b5b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7506ba981be99f398307f1b7bf43cfa3c2cc3b5e3992737c931b3c1714dad568(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4531a31a09dd465661d58df1fa67b1cdace71112e878a3c17d108c7bf07bc467(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1ab5f3ecada5e1911783c9fd49065e05ef6a60c350d18ce0f5a436f831ef8854(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8fcfb9c8d315b12ba0b713b7c25851590e6058957ef04e083eed30437d731205(
    value: typing.Optional[AppSpecJobGithub],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f294692bf3f83b2735ab554c382eff16ac8c0bd117fbc97a31bf6215bfd2121d(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3bb4f93244832314f84d85960d6c6b15ed2ca77b55567735a34855b894d9ce05(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__40d9646a1cc811839a03231cc4cd72c52a7435f1b040c6f0d85bd4f33e01432e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ef59055696a271187e28d32ef63d797b2113a50bbd9ac0f7db6a6766209f912e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__99b3dd75fc52ab2f264762a408e49d98cbb821341d22f1c927645cdf5f239847(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__12de7779be4e3b264d30af0cb716ce78bc96cf03da22671f595a9a60e4da51e9(
    value: typing.Optional[AppSpecJobGitlab],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a4c21f141fa35fff02299d45a74c7c196ddef153232893a1d894287801be6f9f(
    *,
    registry_type: builtins.str,
    repository: builtins.str,
    deploy_on_push: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecJobImageDeployOnPush, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    registry: typing.Optional[builtins.str] = None,
    tag: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__896407ad426a72e4f16b3b0f944e3cf0c56b7007060486fe2f51d5d1a01c9f91(
    *,
    enabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a9bc7555b9721052a7d4674d0c6c02da05c6d87912e50fbac2c131d81f148e53(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__933b41680106ac61da661e7fa871388a7e964d44e257ece2de6b0ca4e44696c8(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ec62abbfb9cee1ddb7b31b180c3d67413a5dda33e442fc74cf200cc63a100b0d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7f434ac3ef71ca599cb1176f556b32af6afc9e869b3f08b7a796a04ae5af6c3a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ed1ae0f5f40effe17f443c3895644b6482b9ba092981ef236460857ff9d1e717(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8492e91c4022316cff31a503e54e054aef7135c4b45c1bfabd33fe058687a489(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d7b532283a02000f987e60cbe148aa5519bee818e84e74b40ba3ba4c718bdcd3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85f326684634192cf8386c41cb0f187cce26eab03ca1813edf58ebc597983504(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c315e7c1d80053a10766459b6d53704bec457bcb761552f86631f80e63dad4f3(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__75ca5d1f673747354bb4841f18c7e7678d32d5b4039ec3d2f81a010054d129c7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5d8ff90c6ef8a024d432776afaa80f7a0fe1edab9df77fe02eb25cf11eb5e879(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                AppSpecJobImageDeployOnPush, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__06633f6703c56eb222928516ae6160b30e1c34470f9cd8ec9b0aa1a869876a3a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8c129ab7ad95b6a16b3d09811c71dc8a2b1c5550d32285486b89973f5f131f49(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ff6ff0e2c699630bd1e33b83e4bc770188e243f5ce07bc85424a0f8000ef4b98(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__abeea83690f20bb36de806995080521e2fc34a77fa901cd89df2a46b651b657e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__38101bef42168677ea8a67a97e0a76372e76175fee2895d609f599201b022962(
    value: typing.Optional[AppSpecJobImage],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9c2dbec2e8f8cf6e55badcd92e02083ed29af65926893bc3332f74333646ee6b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__36912900e6b339674f206778642410bde3f8968798deb8efab8ed40610f13b0b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dea49d50840f0e6147fd6c9587ed4803ba824171d7077b527c4ad109ab0e3806(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0e0f37e00b80f27ec927b9ac6952a9e64bc6a1f0f81cfbc6dac96e2914ba465(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0c48fe6b93b085efb64b74d17f4ca8ee33651ba052e8df484cd1ff4ff4aa26b5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb0174e30dbb20f8c2b1bfab10568ec9f572cde9822388095966323c84e4338b(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__da4d891e56ee9612d2140e139d0cec4675205d881b26492d72333012fce9127f(
    *,
    name: builtins.str,
    datadog: typing.Optional[
        typing.Union[
            AppSpecJobLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    logtail: typing.Optional[
        typing.Union[
            AppSpecJobLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    papertrail: typing.Optional[
        typing.Union[
            AppSpecJobLogDestinationPapertrail, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__06a982958a79b209a9a2b14b446abd7b94f4311dab9061a8eae6079962971d88(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a2bcbc33ce91149126ce37109899d135870990381870a52baa091b7617a680ce(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__50ea4743e37f8fa9e29230715fd40244995c076f179bd608eeb26c180df400f7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0908dd73842b3f9d35e783dd5fb577f650cda1b6e420c0832d317957c24c842b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc8b4f3a74ef351a465d4f8e28ec2a2dc578d496b8a6451938176f0a085d5ffe(
    value: typing.Optional[AppSpecJobLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47c1fb938104fdef2c48fb9d755c9f37a7795daf968e28d4afee1112a6e362fe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__18024ed31118c620e42e27d50910a51b743597fdda06360de5316855f0a1b8a1(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__969e75a46bb3a57a548694ee78a8bc40b4747a06114b38c1daf542216be94d97(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5eee59976d76be0e90947f56c6ada5245c6a0a378b1ef7b24f74a0534a9e1b89(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08de18e9557720ac67a1957b51dcca6d7d958c94404961ca41c36acdaf63e0f4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2aae275ff3b73b4f123a3844ec7c53891661ca70cf1ca69cb0153af5990cf9a(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8ed52d800368c9b1b72a702a890ca03102941e4f44990219cb166a2f95df0167(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__27fa063f72bced8b69445dd916d0bf18a70de6d1f275e8060127737d55e56b7b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bc5c4d0a2bbd67979d3cb4427619857b07d5b0a93a94d8c442c95364a89a695a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d0dc9f61f2a10596cf1e4cdc2fdb4406e43ba4b7404ae471e52f4b0c50efeb12(
    value: typing.Optional[AppSpecJobLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb3e8cc42c0c191cfa47eac586907cdf179e44f30a8918878dfe35585ae033be(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f3f01dcba16fd9e01fc8557d63220e2e5f6df5fbc3c7935059d7d52018404b15(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__58ec58c175dd35b46cd91de81d9fd930796b6414099b2516b1f6ba5a0d90d36b(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bf3ce00e9a6fd024b7e9da6212944d2cb1783588baf59d69f7885ba0b88aa196(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9023757d58612395b59d8914930d98c3a4be3f65c0dffb10d83b100c5252e00f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__874a25afb39efdb044b8643480f62deab72f2712368c75188eb74994936d95b3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__008512f89ae4d7591fcc83a1d2028a51120b57d1b140ff7272331538dd33d53c(
    value: typing.Optional[AppSpecJobLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1331bf25ef498110b53c51ca0a907080f3e86b6f48990e478e560b6501641925(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c5c0ee9342d66b3b66b0bc33527360338b74a3a45b9c5ad91a715f5fc7ee6036(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecJobAlert, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__098d41b1c984fb6b654cb577c790ad4f2ded593cca2d15905254f2c0a9057930(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecJobEnv, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c3599731a4d446b8e13b1a8a979ad2d7a786c194a7d448939fc794cdbf87998d(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                AppSpecJobLogDestination, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__541ed059f3d23ac20cbad6d30b9d6ced0933a98684a5bee1c98f0bf97ee303de(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5aa691f5b6014019a68abb184196112ba4afd50a435f7e586e8aaf39c95c4c5e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a7f5063fb1777b0bfa1d4d02e5e00ec1ce7c1573746a2e6fa39e1d621893ce1a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9070c2757c42675982bc6920d56e6200492418d82182a86dec3b838cdbde2fd1(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__23b545eb78bc8b31af96f1bedaf9c45cd090921b9911ff7ac3194166fd574d6a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf6e4dbdb234264609a4731089bd6999f328fc1820b8604ddf47342c762b9f7b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c50115af27fc913e3a0c7a16dcd2f99e84cee90985a18f4765cd18e53ee9f948(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2987b58b97fc12c9690b70a7b2c2b2aaee1b3ceae3d90ff8349d9d667c9d52a3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4d84bf95f3fd7f54c67bb186f5f8450b1f36a1c0bdd44bd69b7c1065904ad97f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1d2e7ee21465e443d732df4adf091345ff1d803ca466a98fde19dfb80218068f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f5affd94543b19131e413dffa6b886a32946e140826a97d872b030f8d73c6b50(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d66af5d5e75c58c85c1a0fe749a4395523186b6101ddb3af3dba5e6400940802(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecAlert, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__05a32c5caa4b7b535e35477534b740415985ff3bb3064a0e6e2229d3107c17d7(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecDatabase, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3954c3f416eec79a2fceec2a14b1f0a1c8e9d4f7732a86b4dd5af510b0a07bf1(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecDomain, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47f9dfc421f844845e65fcdbd9667f7af7ba07e8e813259077718f7a15220c67(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecEnv, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1346adfa98afad89811053b89caaf85ef9222dcd2c760a15b05d9c82ae4959b0(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecFunction, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__05ad0afef313a9c2ee8719f8469f02b516eb6925386e13abc785b2cb35cddb51(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecJob, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dbb8a7e660899d46dfa9902344020450aa098d8e5a7be2087117647d1fd37f02(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecService, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__247f609a9c819216f3b002754222c1529b86b1fb8b98fa472e3a8c3d5bd5c977(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecStaticSite, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1b48c470052035c4fdd79353b4008c179fb57e0efdc5906b6699c3148c3d27ec(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecWorker, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bfc461e9eef5086593bcd4fc8435fb792f037ecf70acbb3cb6cbc7df7522718e(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b503cb8582b9df5f8cde463f625d61e9cf613d1a0eb0e5078e4eed7f8ee10b7d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6fa0473f8fa417f5df16827a3934a0ef29b5e454dab3ff610dc1b525533c5132(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4325c7caf53a09c9a31814f14af59b4ef7a2eabd14130531d804d2ff082edcd6(
    value: typing.Optional[AppSpec],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4635df1fcb6062883acbe9d368eadc4b7523b5008c75f264f35ceea301e4e02a(
    *,
    name: builtins.str,
    alert: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecServiceAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    build_command: typing.Optional[builtins.str] = None,
    cors: typing.Optional[
        typing.Union[AppSpecServiceCors, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecServiceEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    git: typing.Optional[
        typing.Union[AppSpecServiceGit, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    github: typing.Optional[
        typing.Union[AppSpecServiceGithub, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    gitlab: typing.Optional[
        typing.Union[AppSpecServiceGitlab, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    health_check: typing.Optional[
        typing.Union[AppSpecServiceHealthCheck, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    http_port: typing.Optional[jsii.Number] = None,
    image: typing.Optional[
        typing.Union[AppSpecServiceImage, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_size_slug: typing.Optional[builtins.str] = None,
    internal_ports: typing.Optional[typing.Sequence[jsii.Number]] = None,
    log_destination: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecServiceLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    routes: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecServiceRoutes, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    run_command: typing.Optional[builtins.str] = None,
    source_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c4af67c565d3ecf565000872cc7f0b50b1be73dad5369ad84e71700456d9c4f7(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    disabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2c0a9a3db6ce0032440cf9b9929ef28ada7976660908748ee9a22742c002a162(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f4d0896aae5eaf05da0ceb538626560c70f39fbdd813e6116d83027fb2e3332(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bfd81adc3d61316c364f097b80d4b8fa2c75298e67868c1afff0e955225f3a90(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0c083933f74698f799b333e892fb26708ef5b35595ae245b016a819d0e9490b5(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2a3fdc1e0b9daac4c454a54a8bba56d9c04b7fcfab34059a876a09f978258419(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__de9692d39cdf54dcb149a6c8ce9343b53262de68621b63f0d6ddc85c8e054efe(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__06dd7feec7593ee022f56089ee47be7cfdc619445a1aeb6e81483eaa30e50895(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a1456212afbdffd15e9e1bf56444f600439593ecbec7a2841c3918cc0e560a91(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__89990b0e554ff313a04ec44d2a5a65f003347d62a8a9e9cd7ba7e18959bfc6a5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dd55c309e6d56ee8f317f251249d8a6faf20b71ebf1e5799de52882ea8632fde(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__95c3bf4b606bd3e4f372466269e946ae591207461fe58545fdb8da578b866f4d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a6a875b2bf26ec0c9730deec09f855a81af48cc1b37065e2fd6a3bf01466ce20(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__446fffd3481f66760097a870c317922839dd2d4309bab6c952316b60fb0baca2(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1408b738d4e2cc1e1d295a677e6785c7744bab4f421305fc233c0e7ca28a154e(
    *,
    allow_credentials: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_origins: typing.Optional[
        typing.Union[
            AppSpecServiceCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_age: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3f3bae7413bd4ea8f84765c2e59e334a7d4cd60a5115dcbb197b8fd5bde6004b(
    *,
    exact: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    regex: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4617a78d777aa907d3591a6ed4d74dc3fea69e5c1f655107af245bc494de65f0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1c9f5762c69485891bdfcb63c03bf747923e6500e0e5d7a30fffcbad327b4b60(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b1b83467c06177fb55f2cd45515b2de27c6374b24a4349610bd4eea3f1e022d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d18600012050ad742463d4e382a900e6d0720ab4d25afdfad66d734788f77e98(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5476a3aa364a0df5bd6ffb182e2acb09d763c6fd5d35c3b98d5d95b346954d30(
    value: typing.Optional[AppSpecServiceCorsAllowOrigins],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d63c291ca76b56fa688e9ce6a6efb5acedaa29d6a5308f6fbdbc8f33f1a205e4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb5f415188a921c7c56668f9121814b6d2d4695f62eab52b5c017192e2174eca(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8b33ad30f9d919d91911dfdbc99c607504245deb382b69444d28a2371d6549d5(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__df5af2717761758c3baa6d8021a44fedf09b0a1b2cf14590d51a0ae2166c29f7(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ca71032d5ad329b58c7657839b4852a7fdd2123e84375158a0baf1bb6695972c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cc3583646912bedc24a24a48d3abe31b85a7e1cc7215bc70df13801e2cf87af2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__74468648a81272ee06d51c6526f2d24fc069fb5af74d209dfe87ea401bd8acc3(
    value: typing.Optional[AppSpecServiceCors],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b06788a5fa960e4b3569062bf0ce4f5a53174a96f3e4f99884d4ebde9580af50(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4e00c8bae8ddb9c39125631701fc301b6974eed8cc4ff3bbfff649bd38c9e139(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__843ce5dfe136c2f952bb9801c18612c24f719da2beb8f4ab58bcf3e6e4e15651(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__48445706962bf981049a460b6a62bf8b5f3e4cebcb69881dabd86adb7a20caab(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c07076cea7118a508902e57f213996295a9fa27e639751de384590bf8af8ee8a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e62db108c2b9294d049569ebb84c3ed83e3c190a32d098a7679b54d2a32d52a2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4206965f1df9bdecfd9eedc691525d5aaadca7de8a6d18fbe7b34d9ec8a5626b(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2b4b3ac420ec8f7d36f21e1ccdeb662dd1f095584aa35ca25ea8888e0ccb28a1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8a645319e5994679d35b5e6baad8e3ef18bdc265ecc599f1693f7a53b6ea5eb4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__08b3caa69acb8aad8d666ff2a9f2522d147273a9d1936ba8be79fa5105c3921e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6899f2bb7e2992ed9af0c1258437ad3afba90fd6454148b2e3f9dab95c9c66e4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__328a6deff925fd01eb4215c12f9e060640c6b5953523081a4e803be86ef1f8cd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6d23fa9d5559b0c0467106bfe338cf21aeee669630491cce4af175cc33cd0de6(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a3d809b374a928f9a114d06fc6e3d82c080acc129540a81ddbc33bedb4293016(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7154be0f83ef0bd5cbcde4e9864580e3880aac895de56eee04a2c172ca0a878d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__319290e2389d97b7a9a05d06a5956d995d47f97d97ff8dbe89bbc2a256d49c70(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__25e60c743dd3ba689e14f0345f2e9cbad60f77f3dd29f9e4f89ad9f97ed06388(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__74cea2d7c0084506ae434b72a388979740b65212f8f5f7ae02566b50898a88c6(
    value: typing.Optional[AppSpecServiceGit],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d76e5963b8e57cb236d19f379e1a8ec98e0fa7387c915c9395718f082be8a8ab(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d7ba9719c1e06532e24ae32fa1154cd1f95e17ffb546ece0739ee5ede093cccb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__78fc7b8ab07c19dbcd1a1ac8eadc8836d7f943f89e066b4f3fdc026215c5539d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__661bec120e09429947989700512814c8cee5b72f6581b19a034718ad5cd7728f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bbc31bf97039acb289bd47b672bca23cdcc774f8463b2772a29dc607d75ef698(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__828b1f80571d91ddaf95118315eceeecdfc2b9c317536decb5e98f015495eb5c(
    value: typing.Optional[AppSpecServiceGithub],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e0cc73984d23f9785affd45db84939817f88ce3f2260d5504ada613b8f7b631d(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__50fe55ea880bd01938f29459faeb44ce8dc899d2b7ccffc519f6db913c2ca702(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e51132715bcd9d550bcd393b0f928096ba82ecd83340cfce585a6e31af1d2d11(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__98f3830428ec164c7fae3df563e5107b9ef6c0d6491ac374db78eea6b5fe18c1(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b26e9c2fcc2fe83c684bfe67b9798845a2d2afb4673cb041530d5294d9949b06(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d81dc9744472f05e4a1631e92f00b9cffef08f479e605bccac3117ad23a62fb0(
    value: typing.Optional[AppSpecServiceGitlab],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b767c27332ca812d9f0df3d6802bb7e6272798b94978ebed1ea0cab9584cd340(
    *,
    failure_threshold: typing.Optional[jsii.Number] = None,
    http_path: typing.Optional[builtins.str] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__13999b6b884a14eb9a04cf0c384bc9ab5de9b88a02f7234bce1df5f6fedb53d8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ce754d488b56fc3af12db2d2b871bcfc2ac2d94b571ec1d6f12da80af1849050(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a88c6ae2473a7ab4724696a254bd74af3891971e45a6843b39cb99612c1714a4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d812834490b09ce733991fdb5071d041c052dfe387c0fb741f540c2a23c82150(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__467b5cf0fa3955578b48d89519cbca2179abd6dcf3e02d176928cbc88366f193(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8d64ad94f7da95e0ec9b06d37682e039a85d93a6cf6b5dfe2f5b6639b0deb67f(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__34ea94bfd0d1cf65b47a7dbb60cc34a403d2d322442ded9ad1b271dcfc92e56e(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4c22792cfcbdecfbb4e6a250b5c52d659e2499eba54e1a61fc53f551173fe479(
    value: typing.Optional[AppSpecServiceHealthCheck],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__472885621ee51253e9bed11e8f3463b86855779804a76f767840f7d7ff85bc0b(
    *,
    registry_type: builtins.str,
    repository: builtins.str,
    deploy_on_push: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecServiceImageDeployOnPush,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    registry: typing.Optional[builtins.str] = None,
    tag: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__11169000a9e7bd85e601514117245942c84bb1e5011aa9275132228f8509dd6e(
    *,
    enabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3df609f43219b4993b1d8716b7174e0e55de1046bfabc0c71a5b20d295aa2666(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f0a819e73e903c6b039e8fc467291205e02c7b5947d9f54f549c402eb33e888(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__935caf0eeb50efe4cc1698debd0431ee7f5e5d0193413444e45a0076e97989e4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__61124e965b6a0e790f46b6bdfce28b8a3b443e4ca0fd2ddd2907d6de0ac78823(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7b0203f54c8a0e99d32bcbaebeffc698e2c19f9447eec4292ac38295626e154(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b37d372e51004ee5e8a2923cfb47f94bc3d365a8dbdf452ebf45bbbb044c52ab(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c8d82963d601e4dc8528894730c39613bde1d6022c9f2bd45969377a2f8eaecf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f34f5fc4bf6688f559d14b96e1d6ce4c7427ff2f743b6020597355cd46ea18a0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__84b79cdfb41f63704a241764e64075b84cbcc7611c8e89a988325b9452d92270(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c0adebb8b466c2d56380609aafc871f059a5712424061b074e7c385e3e9c30f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b8bfcaccb870a3d9aa6f45678962c55c1369e903eaefe0333978abc45b43638d(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                AppSpecServiceImageDeployOnPush, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__143b7ebb96267fb822911f0750d9d7085560a87f85f51b831dd679d2be94ae0f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fa7db024040f1d0dbaa2f044888741b47ef48eefc362235d614e263c7cb852f6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d4e4885a96c1dc040fc98626d7b418cc8c74ad256b839d1051b59230b8822ed5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__240448594b7ee74aa38b1b1f2a0e9b3d485f972f9a2d603c6fd423d45270e219(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3ccd32dbc312c471c240878273e02f4c4f9181eeebaed6f132c8b76a5fbd1a66(
    value: typing.Optional[AppSpecServiceImage],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a4d95fd0066013f42a53d224ccbf3b58f7a2e2fe1aaaa2129fc1186a92114967(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c069f90da1b057f8d41316a39004f0d2e1c72ab8a31e0fd50cdbc55c37d23e07(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4b627b5aea962ebb51cf51f44be2be8dc33d8dc8d931eda93f678cc6c98e0851(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ea57b7a977aa68f42f24953c22c82bbbeb7250b6e846b8b8baa04a6569b5af3(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__06ea1e3904f2983a2caeb8d53646d20b9263a77817266ee338de7d93213ec083(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e62a6c502cfbcad3d4d29a0112a592f769778dfdc144d9630ee4efa1ee790c1e(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f4d3ed23273387fc6fb22ab64971b445d64cd9bd67480e66f77c390255d482d0(
    *,
    name: builtins.str,
    datadog: typing.Optional[
        typing.Union[
            AppSpecServiceLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    logtail: typing.Optional[
        typing.Union[
            AppSpecServiceLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    papertrail: typing.Optional[
        typing.Union[
            AppSpecServiceLogDestinationPapertrail,
            typing.Dict[builtins.str, typing.Any],
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__46dc76ba433e1242c0cc53c37209411e16678267917cc16b122455d1c006413b(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__05c14c8c0bdb6279bbbf088271bf38af6ec9502f1e7df528546a63a75cbb8c1b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1d1478198ba28c3f1453578736924603c6cd2288602dfa96971387781af04a51(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a8efd04a8931531e27b99a24e884155ae1a1f209504b853226a3b6560a5639fd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d84d0b5d21026f39bd96826be01fb96c88d9c1f2266407f695e0d8bbf0fa0f59(
    value: typing.Optional[AppSpecServiceLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ab146a752fc05fd3af3c0099804e6faaecc2fd6980a689b85edcde520e47d6b3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5a56a1a98928ed4bc2366f309c7f4776d9165e2ce91c6abfc2de20b6d1ae5811(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5a6d9965e076bb506c2329a2faff8f04f73133fb6089b2af00ac048ed894f643(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1aa43e96f1a15030b3761cb6ad64542b60ab02e6bbb9175672274e8fe45a13cb(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__da36677f9e533bf05193661bc92f86736d9a914ac7d7dbfc351274445fa4713b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__caa35ce51122d7ad26c619c0aa2cdf46e0fe7f79a5cf5e6133a2fdb822c64b85(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f7b33b38ac6f4ebf95705a326e1d91c27a1c84fed972bb7a006aa4754727a8fc(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1f662d37a5fa3ed173f3bb516241d2a5394db975f761a7edc30d54b9226839f9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1295cb1ff56ce36e8db1bee9aef824c4dbb1d9c3b12d5378f6d32bd5b33eb726(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ef67806c4019bb582c81b613ffc745c9c4f1c24cbb08a2191969a541d84ce2af(
    value: typing.Optional[AppSpecServiceLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__57d166b6ee9d48cac27b72470e53c32570ff60b8b235cc1283324768eb6a7aab(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__59ea8c6283dea0f4d7d25d9c0de15ace727b2ab4a3b0c07f9e4e0536d0c5f9be(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f8cf359fd49fc792dbe817eac453cd033ce98c35acff7df33367fa2a02eb03c(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1cc51bcbbe7caac89a4feb641da1f8b030a81b186ee60906e6bd2a000e0215a2(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d87f10fa2ef2edebabc0fc2da279524e9d5230bc911eac89f44bd8d60cc19b14(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1c3c13e9ca1e230003e7f4dcd936a2d0cbe35539464cf8fee38cf48af0c67b24(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4a3c1979deb6116ddfad67e5eb664ba1156d5c8870fae81e0bf30031718f275e(
    value: typing.Optional[AppSpecServiceLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__52b707c82c7980f64c728b1c699664fab42d326f982caf3fe103aa4ac5af25dd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d2d8e1a7ed890d49fc1f46419c687f965d547982b6bfac8d566d82caa86c4bf6(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecServiceAlert, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8b46f21a24ab401ef90a0b55aea058108ae8bc9ca00ce43ff8cc8208c9d57239(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecServiceEnv, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac4fbf8417370e2e5c4f3eb10c56ab7ef868de7e129a9712b39a23a6b837232e(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                AppSpecServiceLogDestination, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__70fd7af471c23ccffd4d0042507afdb4e96d5e997ee5675d9a21f3dcdfed2c1d(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecServiceRoutes, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__098afe1ead2c9c0e8b5c2b6fc6ed2579400565f1d784e0fb66f3e7770346fd31(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3831da11b618796a73fc1bb6f5f1664de553228ea77a9ff9253f10e5f5074dc0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ddd367ba3e88656fc77df745652df22fa06c81dfc2e24bcae3607b29169bb4da(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__53f244fccd4c0230069f63a65571ae69c5817dcbd64d2dd75148368e16213b08(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7db899c7207084e0bee6b6eb54b9715c0de2e0eae567faac316bac28c595edf2(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2571d9a128ddc4c615b001263f33b0873a767c089d8e7ece5cfefab7de12d8ac(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b7d79d27cea155b6aa30d73d5977046334b874206455c1ca6b2d77319dac93b3(
    value: typing.List[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7a5a5b4e4340e45e604b633e0798511cb1a173326ec87e9ac492a7089fefa20c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__459c7054b34bf59530ac2581b3dedffc9be6e02eec283d95699bd5549b6e7010(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__05df0f6fb1adbfe948b5f0c759bec4542c049e8042aeb4b33bbfd9582278755d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ec40edbd6a6514ab44a64659976a477c8d524c6cabd296ed76fad8feb152f10d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__036b51f32cb5e1b6647d371ad0e32cbc9227721a6e4ec0c29b0fa11eb124d5bb(
    *,
    path: typing.Optional[builtins.str] = None,
    preserve_path_prefix: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d1113f7b88b3c4ec8e09890a8b7b61c5addf99ea3ffad1bb28bee59998042ad5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__05197c59392c7b837a4a4656a6d5098f2b03f89b1f25efbd40fae3e2c1c80fc9(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fb9cdc3043a7ddf24e4a129e2a952deb9394b4a24830f6c9b7f54db99b786edc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__330c33717eb4253ce6f17cbaf656948b63bf74537c7538802b9249f1b7ae786b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aea0161a0d88ee9380e043a3fc9f1524bed4a940ee3712be38ce8f1a0664a65a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3095e0f8dcde298db05403f010c0eb0d17d9f0f167811b22b64abbb4ee5aac07(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__223d5ffb23d8faf5e8c3d3f4d0d68575e22f660fa34a5cc4b9ac1d1538173fa5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__137d9dd0f9b6493c28844426ef3ef803af0f3aae7c50d9f75896078664e0a0fb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__867e825d94b4ee38522d9471d8b6cdc9455fe6b30e23862b877976527f330cc9(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__790f603b6fb1462c24f6b7e4d91cc1ba8087df8ac36eaf426ab31ae97a3405cc(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__15199275ae4e19113c4bacde81cee9f1d3c819a5ae8823b35e0dfb72302f6f2c(
    *,
    name: builtins.str,
    build_command: typing.Optional[builtins.str] = None,
    catchall_document: typing.Optional[builtins.str] = None,
    cors: typing.Optional[
        typing.Union[AppSpecStaticSiteCors, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecStaticSiteEnv, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    error_document: typing.Optional[builtins.str] = None,
    git: typing.Optional[
        typing.Union[AppSpecStaticSiteGit, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    github: typing.Optional[
        typing.Union[AppSpecStaticSiteGithub, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    gitlab: typing.Optional[
        typing.Union[AppSpecStaticSiteGitlab, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    index_document: typing.Optional[builtins.str] = None,
    output_dir: typing.Optional[builtins.str] = None,
    routes: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecStaticSiteRoutes, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    source_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f2966edfb4d5dfe842443547fc005f89c287b2f419c8fba13684cc54e929a723(
    *,
    allow_credentials: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_origins: typing.Optional[
        typing.Union[
            AppSpecStaticSiteCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_age: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0d3d129ae1ab2c13538e75b6e7c622878dff3538b0901b3e6f9df3544cec39fa(
    *,
    exact: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    regex: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__727c76e71711575b368b4d2e44bb5a0b865a72af543cf5fb9fb3d0c24620252f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5c460b1c4c4809ff063ffbd49e8e98f80d975c58b4cc62c85ed0c2d3eadc3e12(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9f6350fe6efc7933ce4cc626377fafe247dcf08fed3c3c58c6f3e1ee5315de70(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6328b0eb6dc7cfab737206ecf76a09b334aa0d7751242154ba1862bc1c9cec72(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b047590504ff4d8189c0f0bb8beddc3b34b084588be783c51357d9ff1fb7db46(
    value: typing.Optional[AppSpecStaticSiteCorsAllowOrigins],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ffbb39f404a0469f44892abb7ed2afb0b4fa23e498e939889d4c8dcef0dbee94(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cfa5046ac5e594067e8a1af3c232abc45a1b67ee525636509b80d2c60ef7a89f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__696e347b0aa4d034bd8a4dd77152bcb7eea2b23b9780912f652d7c05b88a0707(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d7d794cf99076a5472838ffb4f35f783f9ad4eacf5ef72bd9e51b6a69ff44ee4(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7e7aefbb8f95d16cad631a30df4cf019f1307b0606b34d86ab6eede9a696a099(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a8540deaafe84ab57ac7c46ac616384007ae0dbeaf007f08c1e5f8c42429026b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1488346b7e9b272ceb958dbe2942fb6ba31e841dd1ecb0d66a6bbbd15984325a(
    value: typing.Optional[AppSpecStaticSiteCors],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__784217f468dfa7bf6719640908c5488add706720cb7c17ef0f2781858b0c046a(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__59c3befb1632fbb70b61008f1696ad43dc77285ead0df07760494cfdf72a4f90(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__536300f92a840650228a98b19f7012c936859923c4935a482295392475cb5a0c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf1fa310bfa38b77ff141af5296fe431ffb2a041606448fd49ec15339ed6ab45(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f010705861e13c861cbf8a575351064c77824eafac1c16a54ae6f4c11a96de71(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a8d7dd303192c2b6d0f5213fc021c2a1ff0197087f56080ab9760434317334f2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__63a7493e8d422ffc6e49fe082c77d623bba25436416e68f25c478bb51bb40348(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__da5c2914e3af0a9bd4417155de95daec89db506f312fbaeeeb92b4368674ab23(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cb93e963fb4dd3f85579415e0a6417f87f3a47ac6543b6672cf97c1450282d46(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b135cde22e1cd1de0199d7c2c19e2f656643df3a51c9842ee768e7839cf5a209(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6b80ac70966d12bf480d84651e55d441789447e40781da68bf55aa95eb136c7c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2403dfe6f56dc187c5469236c4aa9e57ff73e8a4b56501162136962e0d9f61f7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d8eb7e61d177fe68d5f83e48aefa12d734a51e5eaaed5b995a1a240267c586bc(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b9002649e7632089484374e5d404acb76ad7d877f8d2e5c95c4a9ef2842bb3cf(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ef2a35411e4b877440b9f1f0923522361a1259cc46c4d89637e7d252d6125ab7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3be343d274bfdbb87104459d40fa7bc30cb65716aabe37c2548f7e1ed64d4106(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e7ca59c9c072b93280a43faa9d605bf05dda9e79247dd60b75a281b21b33d5c8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7d5173762b044d6e438fd30c77474b463d476c97835212e2bb88b7f206f0610b(
    value: typing.Optional[AppSpecStaticSiteGit],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c4501ee5477a4201414c6c43489ac369a1ef476228b14dfda38a7d8f253569dd(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3097259408cec4e91696f2bb4167fd0e7a7b896a36980c6116188cb75ce3576e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7b990d6a359fada13d26d3b513e2865435edd481fab1fce64d2b4122b5714274(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85d03eab2c94ca80f8364c79ea3264265954ab6a1aabafc1ff424bdb9f117b0b(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__78c729f264913a2700300a158ef3bf8eef131a4667c3ed04dec98c333ef6b3ad(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d31534570c9443a05915548a38afceba7884953d1ef17e6a32c1e3d94705b140(
    value: typing.Optional[AppSpecStaticSiteGithub],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0355eb619dfbe825eaca7a401fba1661eb87b0187e71856722ec03a330b55365(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__42d8605eedf8c442c247dcd244f5fe323c8e22007ee9370ff7c06044937ebbd4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__780bee121ef1c88264ac14858b45dd5574449de1256b4d8d3173eaea86c10609(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__eca1c6a4122af5b449535f50f4c676a34ccfc3c6a7c2ec8a2f60069ef996ad79(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__525b55574792ad62a6520b022af625692d36d712ad6a3dcd927b1422bca1af19(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c91508086b1e82f5536252e5ee0e5af1143af743b006e62c64b920d32a03675f(
    value: typing.Optional[AppSpecStaticSiteGitlab],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9b52cf541dd6d3c18b7585238d5598ead15e26ba1791129bcbbf91b353c71802(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__97c7688b9e06226914b9a7b8e2a76c5d5e278b74d48af52010f20d43d2202b72(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fce83900a455b387d715f30b3fc1b957c1f06fd6cda70c247aa4ef758cc01bbc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__449a1e8739add9cbe4147d02248d6921441aa16cc65a15eed377b1d7740c1a11(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__25808dcf828fd68bc736eb6300b4d32bae8561ffe7e1d8497a23a810eba90fa1(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1fe6e50c1f7a0c06794d413479475e49237057adbdf6e9de818b2d690dd4f853(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__17e1fe4b186339f18ce408ab7fcc9d05b5fcb097dbf8b11b8fe9ef208dfdbd04(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__89c9286f6fbf8ad2336b8335f905dd4b49c49bf24e579fa50abe0a8ebcba8d3a(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecStaticSiteEnv, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6d26a7718b46aefd0a1c98e17bcaa972150e0215497810190aa2a10b04ecf635(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecStaticSiteRoutes, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__83ee4436fb8080e61513535b9acd11b4d4dba9e68c08ed34e3a1b5ea08a935ec(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1e8ff29492686432c78c20dddb63e98e38e9e63e66bd6f9d13cd0bdcec6eee09(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1b5c41dbb0e9bcf8c091d75fdf9bba58654995aad09414b8efe6b072a56869f9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__588fe45a217e0408ddc662a3fe505f899858b096e0d372756bad5cf11244700f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__01e2e5a049a0e4c2a013c1081e52ec41424edf811dcb9b8c4e9b4fc61e44551e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0f10b8f5c2d63b24e0da628a49245e44d878ed06d668e029b16e7f6d664ee9f9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e2fa9ea2684d137d6ef349bc211a0e616a26ee8b69fe807749c4cecdbe796a53(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b77685e847774eaea5cd47782d456fc582961ca50566122347fb406b99501911(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ff723c3b6ab07d6a5bc2f36d4889afd3b17e34660c3141d0d65024a0a195e160(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__979640ecb296ba8269762b13b71a45283b615fa0984f0e6de58b29712bf17211(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__94eb801d912cbb47eb67786aceacb609dfd17e6d754dd9ea87a12355a9b4c18b(
    *,
    path: typing.Optional[builtins.str] = None,
    preserve_path_prefix: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__716d569a99cd4fc48c88f923ccb38ab8527d8b41f3e1548facbb59b9cf204cab(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c58d1c3b0c0e1d3c948e60b7f65b291401b7c4f3c31f66839089c35c08b8cd7a(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__21e2cf12f857947694645f23521388b289bd7f61f3eb3f1a71a0ad031b8ea052(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c340af492ee12975816474e55e05a3a073659c84fb859c6e6eb5716d57d4c787(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1abfe0c8d1614d77fccac5c0f881f68608e6ad3ea2280cc5a32589ba59a28608(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__682921897b31141476b90f3c59ed58f54471d78aee4876e75cf7401f5037b9fc(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__297ad80a7a0e10b24f7d2ec1e3e2b7ffd67bc3d16ee6fe69418c2cd72db3d06f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1d7387e0f82b11275d364e64be2aa16b9000454f6b70561ed19829719f5715dd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__dcd78a15bec8ec5213a816153ab2014659172e0f6cc63477e0d4372a440bc18f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c79c25e10b04e79be890695efb72d665035ef409c1ec7dedf582fcdc0ca8d67(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f946ea53a22fdef3c96339d75e6bb12991e6166216e8fd57328742384f62c701(
    *,
    name: builtins.str,
    alert: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecWorkerAlert, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    build_command: typing.Optional[builtins.str] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[AppSpecWorkerEnv, typing.Dict[builtins.str, typing.Any]]
            ],
        ]
    ] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    git: typing.Optional[
        typing.Union[AppSpecWorkerGit, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    github: typing.Optional[
        typing.Union[AppSpecWorkerGithub, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    gitlab: typing.Optional[
        typing.Union[AppSpecWorkerGitlab, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    image: typing.Optional[
        typing.Union[AppSpecWorkerImage, typing.Dict[builtins.str, typing.Any]]
    ] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_size_slug: typing.Optional[builtins.str] = None,
    log_destination: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecWorkerLogDestination, typing.Dict[builtins.str, typing.Any]
                ]
            ],
        ]
    ] = None,
    run_command: typing.Optional[builtins.str] = None,
    source_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__83c3a523ab2ac6e9cc50b24d907f7079136ca006914f1bb2d74f20b6c8bfafbb(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    disabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9d57b2bef7fb51f1cf52f808a4e98919e36ada79df513e70f2a2502e26243cb8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__59757b1048bd342ba29290e9e19cccc30dfc89e3fb1889ba0bf95d51584c02d4(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cf1248017b0c7d90dd3442bf3e58c6cf00305d30a52bcb3ffbbfd86b804a2780(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aae635d9ff76ba2a376bdb6f2d43e10b858540d0aa31eb746cc3d7e932af4daa(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4d95b76f043a20e526c5224e675b5e11dada4679599b3dc2ada8b8ca9917d082(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__038a9a156f2640521abc8cd1882b19bec8fa8814d9494550b7f9e82720b41566(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c096fe7bf5ab1a67c36d0a5c28c48f6cd6a61f0747c27c8acdee7fd56aaa7cf2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__88a4e5650232c02cf7625d3e65b4665159696e2ad518a3eb870ca26545eeb3e0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__858707f3b31571fab8bc98b1f96e27ef52a74fe3745e0699a4440c45a0360eb4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3c6ec22c10a023a9befc349084f0e3b8fcc83b364db895350c91503e2cc64bbf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a033494a51aa421174f8b7dc2a6391f74756d823ce51f47bfffcca6a1ffeb488(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7abe109f4cb2067b8c9a5e016ddb09e09578b8e30abdbde188dab72f4746d82f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__419d9312fea3b26941f4a6d8aa5f3d95fcaf377c7f8601fa1fb61eb447702fcd(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a645c0b33bca8c7a59bbadb6bd839fbc625126dfe7e536bbeb3abfdf1736547f(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__4141c142524b8c4d5e9b2af7a0b1f4633fc7e67ae6e9b7d90af80484aa503342(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8c171fc3c2bee3883e8b29cac1b48e59e9ec31e75ad72a86c0467e5ed20539de(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e923914c24bbfca7a510c7b6a90bde473f966f05618ca06f4a919e88e1475ba0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6d0f5513b5170c340fa9f75717580e1742b4ce59f0aef5e9d6e10769dd1d3dfd(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3514d24a4cf414f347c1dee4d3b7a536aa197474465ef83a8f51ef01002da3c8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e88c5a01a81738a108e5391731ce5aab60dbd75a8fed024f67b3462a7e55c85e(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8dfec70aeba9eec50f45f2e66ff6ec980613cc1e426fd130c371708bf7971ee2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2be4e821bb503862cc3d37b9e33c40420d76be47453f3edf8d953e277f1ae311(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__9e6e5252522758f599b587edc08424f69993507965738095b9aec5d7ddfde08e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__70ca2b0556ace5233e61d4231974eff53cf93066158d667761564d175947dfff(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e81073cbb140a782514f5c5126cfbe67bc30a264cc271603f065174c39f0e69e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2bb73294e08973a2d5e33cde5a34a06fa4714ed666b3e8305d5830a5fa816f4b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__65ed3bd4be20a855935f6f40017b704e2d37416b9ce9d16c7783fe19c39dd57f(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__36ac71b677c56acd939a3de03257c14faa31ff9f51bc2649ade2c8d255fe1480(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__195ed50e042b9df5cf52151c5ae144ffb2ccbc83e7559374fab0a52b90029766(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e7eed93051c8049e65f3d285f4470d025be36c2bf0c18bd4a92e72c2e25feff3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__3a3734c1b059e661b6d4e3927141b855ce62fb55811a0d541de7e73681088580(
    value: typing.Optional[AppSpecWorkerGit],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e510330fb3616d9be716a83a171c95c65ddbebe16e9f39db1469cff8cce1c05e(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f73a598726d3e60688971b4bbbf345c3f3fe2c2ce84997dd0a776030b43eaf95(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fe8e3c28d2e4272210fcc3c39e68c25e0a6b6165ee8d141ad5ab38f63def0777(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c476e6b66788258795af3f27e6b0deed17f011f8cee5e81cb2af2cd33ee2a52b(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f3c04d35d84f3fe30852f8141e41783774b5b7cb4afc096d538d15952870a033(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5ce0dd4977afc7c9e432947db58fb82d2ae3530034644e4363eb885756edba7e(
    value: typing.Optional[AppSpecWorkerGithub],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__092c69f3ef1099eda4c776fa1708e3338d5e43c4cb2f0aa26cb43b9b3014dde4(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fcbe0e441f9e34cb46812c4df80801e93978dbe6a7db708f513957ec6836125e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2fa12a3af0dbbda9039cdd8706a0a3c88d14794d40cb2fd2b0833ad9d12991e8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1920d0c4c28cb2bcbfd9f4135c1ff72ba0779034b39f0e14a8d2ae37dd4c5c02(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cde272430d9a695db598cf0dd586f33c719d07443d6ce6e8810289c151869277(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c7e6230257c9f4cd135c493c467293d9d768797640cbd9d2377e18371031515b(
    value: typing.Optional[AppSpecWorkerGitlab],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__07ceda44d34c848103d56190074ef0646e3b5ae00d3a952277de75fe5fd2f738(
    *,
    registry_type: builtins.str,
    repository: builtins.str,
    deploy_on_push: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable,
            typing.Sequence[
                typing.Union[
                    AppSpecWorkerImageDeployOnPush,
                    typing.Dict[builtins.str, typing.Any],
                ]
            ],
        ]
    ] = None,
    registry: typing.Optional[builtins.str] = None,
    tag: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bb1e78017d6a19cca2b6ca4f4305afdfdb24297bccf8a359ec9ad69e74518a9d(
    *,
    enabled: typing.Optional[
        typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__fc117821e6e970f17f2c4081ea8eb8ae92d98528e70efa3bff8df3d83f7f57ba(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f978bd7fc8dcfa31304faa7821661b27ca888aa249383329ba1661ab695bb3a5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c1a5956b82c75075c74522cc2dbc8a6fa9d2134980941bc17eeadb7901ee3469(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__843d4b4ca76cee0674b546596c94517ea22b694f01bf96329c3017717752f079(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__434e1b9b5c1a84e76eb1ec11ffac155cc008b87aa8ffe1f5999b9a95f4fed062(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__486c8fbf72b8a42dd1f0ae68023d0813907ea17f1d189945ae20fe9eb2904794(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__705c04a632810e987c1064cdb654eabd300437f7f6eb716ecc6d4626df09fd32(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__28d1bc095393a8976a186ede97716a5675f9691f8970bf62e1731b82d77b0964(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ce2ded9e15de3e36519b44651f02dac2a99f7a60d8ea5ee026ac1433691e4c7d(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__cad1e5b34d0662b052f4c77eb025c2cbe775e0b4aadc5061c4017c88e1aea28d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1aaee4269b8304d0738d92921b17f1e6174ca813394c04d84f902c08f7153093(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                AppSpecWorkerImageDeployOnPush, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__47d35f4e313b08615add8ecbb27318197bb9e4e38aefa90c3b0ed0e6b76f0725(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b2966e3590d5467c29bc8ba516637f682c88546cdc19436092abeaea5ca4f76c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5343bf30f3a569b0164ff6aa326a503acd9e7da57be484c64bed4eb0561425d4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5bc066ba25d3caddd7317de28ac51b7f9a7e29a3df6b1ccea9811dbc0f6bc14e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__efb1943a99c5a5ab77c05e9310657c7bd31186b0d76bc7e53cf419e36f86f68d(
    value: typing.Optional[AppSpecWorkerImage],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__59d0b009d1f678c54e7c84ae810a928a0fd32cebc0c87c0e1feda040209e6d30(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bd769594c050f4e63b8e5632596a8df4f162961d40d4b094ebb78f458ae3816c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__018552f5fa32fedc6880340fa4a3e220d1aee519bac7d1c66f26caec37320407(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7813423982af30693e6de05c363e3022f728526fc08f8c8b63e493bf6e783a80(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bba947906d69eb0ff04d2fa967c455f9fa5bee3e00f5d9b23c10da66e2f04eec(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__09e1fa846460dab7bd2593150ecd78c4d41923a5d7a81c2c0935358e4b90f88d(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f9b347931b7add79158d5c2520844297f6e37e64087548b38305e67bd15577e5(
    *,
    name: builtins.str,
    datadog: typing.Optional[
        typing.Union[
            AppSpecWorkerLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    logtail: typing.Optional[
        typing.Union[
            AppSpecWorkerLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
    papertrail: typing.Optional[
        typing.Union[
            AppSpecWorkerLogDestinationPapertrail, typing.Dict[builtins.str, typing.Any]
        ]
    ] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__735f21f93267e274392256fe922af284aeb6fd9a329e67cd886738061aac9d4f(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__67c04f2eee0437e2856acc3faf15b93f43f87026feadcf2514797a6940c5dd9d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d957886868ed6515c2246ab07754c2c200decdee9a1d97d7d361652c3fe278fe(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__6c600f38f3b603debd4382cec01b6324d714e71296b8609027b4e9421b7c9851(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7f0e149171a27a1446274390f2db1ca5fdb559967daf135629f36f145db46309(
    value: typing.Optional[AppSpecWorkerLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__8c885600ecbdeb7c8d8237a95248d0248ca025e286495e3c972501232a6821a0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5654e7bedd39d2098c61f4f42b4a1c256105e5c129541c0ff7f53c30c5da4e31(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f60ee8acc6fd6a2400da15c8547543ddcad2514cd17a2e49187148ec667267e2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__85f01336d1ced1eac46cf49d16078af32fdba9ddc868eadb94fc863af9b15850(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e66a998bd5b2dac6eb5a7baa40dc910d91e82cc35a24742e9549db5b798c66b8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d329df2f0719570784fe407c7b758a6acfa2c3e6f1fb01845fae3e782e619beb(
    value: typing.Optional[
        typing.Union[
            _cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]
        ]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b548b79b793340ff4a7573a993ea626801381f91924f873dbc759f11005fcc20(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__2b5f349d911c2fdbb56d28c6e5166ead5ca2a424e55870679e0939f2ecbaec55(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__698531dcc3f7104f97325d873facd64337e31aef5cc3a9d26221072e503b5047(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ab62324ba65ec8421ba529b746de0193d0d66848cef09893ca1f8b64e30ab324(
    value: typing.Optional[AppSpecWorkerLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__ac32eb3acf6e18506ac3cf63cd808331df6ec8613584190cd4c6d5565143862f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__7a95d3f41d95a8aefd2e379c7a946cbbba0994c4ac04e16f0d556283fc6752a0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__0dad53b84e891f17f58002b215e86bf5909949eae69d836034d2798f3543dddd(
    value: typing.Optional[
        typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f1e5075457fe41ac61a4969d21bd2938de80094ee5fbece592d15094094bb8a4(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__c811f525dae470e5e1f7d9ebcf8f91c87d866473cce542bbe3468a5ec5780573(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1395156b4e1ce2438b6acaa722c26a38a118bcd0c68a863229823ced7c8bf3b9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__222dcae7e28e90435272f0acca02db897db984e276ab53b0f0a5a129414828ce(
    value: typing.Optional[AppSpecWorkerLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__e8a3e4d07a2d1fa7a88fcedb16a59cd83031cf6a0594582476ad148d1e68921e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__71afa39146360719470fcfba6f82ea67e2ae3dfa17bdd2b69b8bd9bdaa42c550(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecWorkerAlert, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__f731ece5f505b4aeef53b419892ef39dd8b95cc7548ed3c314f5a41ebd55b343(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[AppSpecWorkerEnv, typing.Dict[builtins.str, typing.Any]]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a0e7592e6e6cce68dbd808ce356f06f2f3f9a4be845d0c080dd74f7011f789d4(
    value: typing.Union[
        _cdktf_9a9027ec.IResolvable,
        typing.Sequence[
            typing.Union[
                AppSpecWorkerLogDestination, typing.Dict[builtins.str, typing.Any]
            ]
        ],
    ],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__aaaa5ad0e680d4675295689a235b369626464dce314c58604800bf606c7e3882(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a172f6591b422bf72bd74aae3936c939418247bb15f10b2aa61f1d59424b51f7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__d8b4500b1b05cf98fd166636a846b59275424a3254a6ffe687604b9e6bf1bb80(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__a5ac52b134cd4ec73118acacab7b36e10de6adfa93b089c66ed9426c738e59ca(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__de0fb4065e1f356f4a9078abef4da0026196c065c45e3239d2bebaca486e2630(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__00dbd8034b4ade52071a948a4a5df9c10a50a43c9517d5246d8ac59fa10d478a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__5efe0a244e80c19f0f5c896738ca406b34e5edcc14f604f3a0405b61e3f8608a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__1d038b0ef4e8361a2cee9db23a500a842984b59271cba195f5b857184f3ed69e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bcbeed2d3c449b58623f2ccfe05554031ebcb697e5ee31ae451b3c58624aa655(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]],
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__30ad37303995ea1d7133866ab2a23a3500d973dc3c8ba80685023b04b46dd585(
    *,
    create: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__bb1235d4faeb8c5d0a852bdef48511faa5279a37243073f15d9aae25ba2deaaa(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__00e8b50d51ddcf2fe5d7d805e656fd92e710089f352eca95db4f16b96e78e8bf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass


def _typecheckingstub__b91a02aa6070fd052e12784bede6620fa82cdfd2ce89c035170f2bb5480e258d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]],
) -> None:
    """Type checking stubs"""
    pass
